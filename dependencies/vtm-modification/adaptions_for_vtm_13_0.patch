diff --git a/source/App/BitstreamExtractorApp/BitstreamExtractorApp.cpp b/source/App/BitstreamExtractorApp/BitstreamExtractorApp.cpp
index c31a7a5..60ac8b2 100644
--- a/source/App/BitstreamExtractorApp/BitstreamExtractorApp.cpp
+++ b/source/App/BitstreamExtractorApp/BitstreamExtractorApp.cpp
@@ -54,44 +54,44 @@ BitstreamExtractorApp::BitstreamExtractorApp()
 
 void BitstreamExtractorApp::xPrintVPSInfo (VPS *vps)
 {
-  msg (VERBOSE, "VPS Info: \n");
-  msg (VERBOSE, "  VPS ID         : %d\n", vps->getVPSId());
-  msg (VERBOSE, "  Max layers     : %d\n", vps->getMaxLayers());
-  msg (VERBOSE, "  Max sub-layers : %d\n", vps->getMaxSubLayers());
-  msg (VERBOSE, "  Number of OLS  : %d\n", vps->getTotalNumOLSs());
+  msg (VTM_VERBOSE, "VPS Info: \n");
+  msg (VTM_VERBOSE, "  VPS ID         : %d\n", vps->getVPSId());
+  msg (VTM_VERBOSE, "  Max layers     : %d\n", vps->getMaxLayers());
+  msg (VTM_VERBOSE, "  Max sub-layers : %d\n", vps->getMaxSubLayers());
+  msg (VTM_VERBOSE, "  Number of OLS  : %d\n", vps->getTotalNumOLSs());
   for (int olsIdx=0; olsIdx < vps->getTotalNumOLSs(); olsIdx++)
   {
     vps->deriveTargetOutputLayerSet(olsIdx);
-    msg (VERBOSE, "    OLS # %d\n", olsIdx);
-    msg (VERBOSE, "      Output layers: ");
+    msg (VTM_VERBOSE, "    OLS # %d\n", olsIdx);
+    msg (VTM_VERBOSE, "      Output layers: ");
     for( int i = 0; i < vps->m_targetOutputLayerIdSet.size(); i++ )
     {
-      msg (VERBOSE, "%d  ", vps->m_targetOutputLayerIdSet[i]);
+      msg (VTM_VERBOSE, "%d  ", vps->m_targetOutputLayerIdSet[i]);
     }
-    msg (VERBOSE, "\n");
+    msg (VTM_VERBOSE, "\n");
 
-    msg (VERBOSE, "      Target layers: ");
+    msg (VTM_VERBOSE, "      Target layers: ");
     for( int i = 0; i < vps->m_targetLayerIdSet.size(); i++ )
     {
-      msg (VERBOSE, "%d  ", vps->m_targetLayerIdSet[i]);
+      msg (VTM_VERBOSE, "%d  ", vps->m_targetLayerIdSet[i]);
     }
-    msg (VERBOSE, "\n");
+    msg (VTM_VERBOSE, "\n");
   }
 }
 
 void BitstreamExtractorApp::xPrintSubPicInfo (PPS *pps)
 {
-  msg (VERBOSE, "Subpic Info: \n");
-  msg (VERBOSE, "  SPS ID         : %d\n", pps->getSPSId());
-  msg (VERBOSE, "  PPS ID         : %d\n", pps->getPPSId());
-  msg (VERBOSE, "  Subpic enabled : %s\n", pps->getNumSubPics() > 1 ? "yes": "no" );
+  msg (VTM_VERBOSE, "Subpic Info: \n");
+  msg (VTM_VERBOSE, "  SPS ID         : %d\n", pps->getSPSId());
+  msg (VTM_VERBOSE, "  PPS ID         : %d\n", pps->getPPSId());
+  msg (VTM_VERBOSE, "  Subpic enabled : %s\n", pps->getNumSubPics() > 1 ? "yes": "no" );
   if ( pps->getNumSubPics() > 1)
   {
-    msg (VERBOSE, "    Number of subpics : %d\n", pps->getNumSubPics() );
+    msg (VTM_VERBOSE, "    Number of subpics : %d\n", pps->getNumSubPics() );
     for (int i=0; i<pps->getNumSubPics(); i++)
     {
       SubPic subP = pps->getSubPic(i);
-      msg ( VERBOSE, "      SubpicIdx #%d : TL=(%d, %d) Size CTU=(%d, %d) Size Pel=(%d, %d) SubpicID=%d\n", i, subP.getSubPicCtuTopLeftX(), subP.getSubPicCtuTopLeftY(),
+      msg ( VTM_VERBOSE, "      SubpicIdx #%d : TL=(%d, %d) Size CTU=(%d, %d) Size Pel=(%d, %d) SubpicID=%d\n", i, subP.getSubPicCtuTopLeftX(), subP.getSubPicCtuTopLeftY(),
             subP.getSubPicWidthInCTUs(), subP.getSubPicHeightInCTUs(), subP.getSubPicWidthInLumaSample(), subP.getSubPicHeightInLumaSample(), subP.getSubPicID());
     }
   }
@@ -130,7 +130,7 @@ bool BitstreamExtractorApp::xCheckSliceSubpicture(Slice &slice, int targetSubPic
   if (sps->getSubPicInfoPresentFlag())
   {
     // subpic ID is explicitly indicated
-    msg(VERBOSE, "found slice subpic id %d\n", slice.getSliceSubPicId());
+    msg(VTM_VERBOSE, "found slice subpic id %d\n", slice.getSliceSubPicId());
     return (targetSubPicId == slice.getSliceSubPicId());
   }
   else
@@ -160,7 +160,7 @@ bool BitstreamExtractorApp::xCheckSliceSubpicture(InputNALUnit &nalu, int target
   if (sps->getSubPicInfoPresentFlag())
   {
     // subpic ID is explicitly indicated
-    msg( VERBOSE, "found slice subpic id %d\n", slice.getSliceSubPicId());
+    msg( VTM_VERBOSE, "found slice subpic id %d\n", slice.getSliceSubPicId());
     return ( targetSubPicId == slice.getSliceSubPicId());
   }
   else
@@ -600,7 +600,7 @@ uint32_t BitstreamExtractorApp::decode()
        *  - two back-to-back start_code_prefixes
        *  - start_code_prefix immediately followed by EOF
        */
-      msg(WARNING, "Warning: Attempt to decode an empty NAL unit" );
+      msg(VTM_WARNING, "Warning: Attempt to decode an empty NAL unit" );
     }
     else
     {
@@ -669,7 +669,7 @@ uint32_t BitstreamExtractorApp::decode()
         m_parameterSetManager.storeSPS( sps, nalu.getBitstream().getFifo() );
         // get SPS back
         sps = m_parameterSetManager.getSPS(spsId);
-        msg (VERBOSE, "SPS Info: SPS ID = %d\n", spsId);
+        msg (VTM_VERBOSE, "SPS Info: SPS ID = %d\n", spsId);
 
         // example: just write the parsed SPS back to the stream
         // *** add modifications here ***
@@ -704,7 +704,7 @@ uint32_t BitstreamExtractorApp::decode()
         m_parameterSetManager.storePPS( pps, nalu.getBitstream().getFifo() );
         // get PPS back
         pps = m_parameterSetManager.getPPS(ppsId);
-        msg (VERBOSE, "PPS Info: PPS ID = %d\n", pps->getPPSId());
+        msg (VTM_VERBOSE, "PPS Info: PPS ID = %d\n", pps->getPPSId());
 
         SPS *sps = m_parameterSetManager.getSPS(pps->getSPSId());
         if ( nullptr == sps)
@@ -769,7 +769,7 @@ uint32_t BitstreamExtractorApp::decode()
         APS* aps = new APS();
         m_hlSynaxReader.setBitstream( &nalu.getBitstream() );
         m_hlSynaxReader.parseAPS( aps );
-        msg (VERBOSE, "APS Info: APS ID = %d Type = %d Layer = %d\n", aps->getAPSId(), aps->getAPSType(), nalu.m_nuhLayerId);
+        msg (VTM_VERBOSE, "APS Info: APS ID = %d Type = %d Layer = %d\n", aps->getAPSId(), aps->getAPSType(), nalu.m_nuhLayerId);
         int apsId = aps->getAPSId();
         int apsType = aps->getAPSType();
         // note: storeAPS may invalidate the aps pointer!
diff --git a/source/App/BitstreamExtractorApp/BitstreamExtractorAppCfg.cpp b/source/App/BitstreamExtractorApp/BitstreamExtractorAppCfg.cpp
index 8da4816..a3e254f 100644
--- a/source/App/BitstreamExtractorApp/BitstreamExtractorAppCfg.cpp
+++ b/source/App/BitstreamExtractorApp/BitstreamExtractorAppCfg.cpp
@@ -80,7 +80,7 @@ namespace po = df::program_options_lite;
   ("TraceFile",                 tracingFile,                           string( "" ), "Tracing file" )
 #endif
 
-  ("Verbosity,v",               verbosity,                             (int)VERBOSE, "Specifies the level of the verboseness")
+  ("Verbosity,v",               verbosity,                             (int)VTM_VERBOSE, "Specifies the level of the verboseness")
   ("WarnUnknowParameter,w",     warnUnknownParameter,                  false,        "Warn for unknown configuration parameters instead of failing")
   ;
 
@@ -105,7 +105,7 @@ namespace po = df::program_options_lite;
   {
     std::string channelsList;
     g_trace_ctx->getChannelsList( channelsList );
-    msg( INFO, "\nAvailable tracing channels:\n\n%s\n", channelsList.c_str() );
+    msg( VTM_INFO, "\nAvailable tracing channels:\n\n%s\n", channelsList.c_str() );
   }
   DTRACE_UPDATE( g_trace_ctx, std::make_pair( "final", 1 ) );
 #endif
diff --git a/source/App/BitstreamExtractorApp/bitstreamextractormain.cpp b/source/App/BitstreamExtractorApp/bitstreamextractormain.cpp
index 3e7b381..7ec98de 100644
--- a/source/App/BitstreamExtractorApp/bitstreamextractormain.cpp
+++ b/source/App/BitstreamExtractorApp/bitstreamextractormain.cpp
@@ -84,7 +84,7 @@ int main(int argc, char* argv[])
 #endif // !_DEBUG
     if( 0 != extractorApp->decode() )
     {
-      printf( "\n\n***ERROR*** A decoding mismatch occured: signalled md5sum does not match\n" );
+      printf( "\n\n***VTM_ERROR*** A decoding mismatch occured: signalled md5sum does not match\n" );
       returnCode = EXIT_FAILURE;
     }
 #ifndef _DEBUG
diff --git a/source/App/DecoderApp/DecApp.cpp b/source/App/DecoderApp/DecApp.cpp
index 023ab15..8c4cb34 100644
--- a/source/App/DecoderApp/DecApp.cpp
+++ b/source/App/DecoderApp/DecApp.cpp
@@ -189,7 +189,7 @@ uint32_t DecApp::decode()
          *  - two back-to-back start_code_prefixes
          *  - start_code_prefix immediately followed by EOF
          */
-        msg( ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+        msg( VTM_ERROR, "Warning: Attempt to decode an empty NAL unit\n");
       }
       else
       {
@@ -330,7 +330,7 @@ uint32_t DecApp::decode()
       if (!loopFiltered[nalu.m_nuhLayerId] || bitstreamFile)
       {
         m_cDecLib.executeLoopFilters();
-        m_cDecLib.finishPicture(poc, pcListPic, INFO, m_newCLVS[nalu.m_nuhLayerId]);
+        m_cDecLib.finishPicture(poc, pcListPic, VTM_INFO, m_newCLVS[nalu.m_nuhLayerId]);
       }
       loopFiltered[nalu.m_nuhLayerId] = (nalu.m_nalUnitType == NAL_UNIT_EOS);
       if (nalu.m_nalUnitType == NAL_UNIT_EOS)
diff --git a/source/App/DecoderApp/DecAppCfg.cpp b/source/App/DecoderApp/DecAppCfg.cpp
index 0a126cb..d1ef1d0 100644
--- a/source/App/DecoderApp/DecAppCfg.cpp
+++ b/source/App/DecoderApp/DecAppCfg.cpp
@@ -132,7 +132,7 @@ bool DecAppCfg::parseCfg( int argc, char* argv[] )
 
   for (list<const char*>::const_iterator it = argv_unhandled.begin(); it != argv_unhandled.end(); it++)
   {
-    msg( ERROR, "Unhandled argument ignored: `%s'\n", *it);
+    msg( VTM_ERROR, "Unhandled argument ignored: `%s'\n", *it);
   }
 
   if (argc == 1 || do_help)
@@ -156,7 +156,7 @@ bool DecAppCfg::parseCfg( int argc, char* argv[] )
   {
     std::string sChannelsList;
     g_trace_ctx->getChannelsList( sChannelsList );
-    msg( INFO, "\nAvailable tracing channels:\n\n%s\n", sChannelsList.c_str() );
+    msg( VTM_INFO, "\nAvailable tracing channels:\n\n%s\n", sChannelsList.c_str() );
   }
 #endif
 
@@ -170,13 +170,13 @@ bool DecAppCfg::parseCfg( int argc, char* argv[] )
   m_outputColourSpaceConvert = stringToInputColourSpaceConvert(outputColourSpaceConvert, false);
   if (m_outputColourSpaceConvert>=NUMBER_INPUT_COLOUR_SPACE_CONVERSIONS)
   {
-    msg( ERROR, "Bad output colour space conversion string\n");
+    msg( VTM_ERROR, "Bad output colour space conversion string\n");
     return false;
   }
 
   if (m_bitstreamFileName.empty())
   {
-    msg( ERROR, "No input file specified, aborting\n");
+    msg( VTM_ERROR, "No input file specified, aborting\n");
     return false;
   }
 
@@ -193,7 +193,7 @@ bool DecAppCfg::parseCfg( int argc, char* argv[] )
         {
           if ( m_targetDecLayerIdSet.size() == 0 )
           {
-            msg( ERROR, "No LayerId could be parsed in file %s. Decoding all LayerIds as default.\n", cfg_TargetDecLayerIdSetFile.c_str() );
+            msg( VTM_ERROR, "No LayerId could be parsed in file %s. Decoding all LayerIds as default.\n", cfg_TargetDecLayerIdSetFile.c_str() );
           }
           break;
         }
@@ -204,7 +204,7 @@ bool DecAppCfg::parseCfg( int argc, char* argv[] )
         }
         if ( layerIdParsed < 0 || layerIdParsed >= MAX_NUM_LAYER_IDS )
         {
-          msg( ERROR, "Warning! Parsed LayerId %d is not within allowed range [0,%d]. Ignoring this value.\n", layerIdParsed, MAX_NUM_LAYER_IDS-1 );
+          msg( VTM_ERROR, "Warning! Parsed LayerId %d is not within allowed range [0,%d]. Ignoring this value.\n", layerIdParsed, MAX_NUM_LAYER_IDS-1 );
         }
         else
         {
@@ -215,13 +215,13 @@ bool DecAppCfg::parseCfg( int argc, char* argv[] )
       fclose (targetDecLayerIdSetFile);
       if ( m_targetDecLayerIdSet.size() > 0 && !isLayerIdZeroIncluded )
       {
-        msg( ERROR, "TargetDecLayerIdSet must contain LayerId=0, aborting" );
+        msg( VTM_ERROR, "TargetDecLayerIdSet must contain LayerId=0, aborting" );
         return false;
       }
     }
     else
     {
-      msg( ERROR, "File %s could not be opened. Using all LayerIds as default.\n", cfg_TargetDecLayerIdSetFile.c_str() );
+      msg( VTM_ERROR, "File %s could not be opened. Using all LayerIds as default.\n", cfg_TargetDecLayerIdSetFile.c_str() );
     }
   }
   if (m_iMaxTemporalLayer != 500)
diff --git a/source/App/DecoderApp/decmain.cpp b/source/App/DecoderApp/decmain.cpp
index 94264a0..d4a251b 100644
--- a/source/App/DecoderApp/decmain.cpp
+++ b/source/App/DecoderApp/decmain.cpp
@@ -90,7 +90,7 @@ int main(int argc, char* argv[])
 #endif // !_DEBUG
     if( 0 != pcDecApp->decode() )
     {
-      printf( "\n\n***ERROR*** A decoding mismatch occured: signalled md5sum does not match\n" );
+      printf( "\n\n***VTM_ERROR*** A decoding mismatch occured: signalled md5sum does not match\n" );
       returnCode = EXIT_FAILURE;
     }
 #ifndef _DEBUG
diff --git a/source/App/EncoderApp/EncAppCfg.cpp b/source/App/EncoderApp/EncAppCfg.cpp
index ed0823e..5dc4eea 100644
--- a/source/App/EncoderApp/EncAppCfg.cpp
+++ b/source/App/EncoderApp/EncAppCfg.cpp
@@ -761,7 +761,7 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
   ("SummaryOutFilename",                              m_summaryOutFilename,                          string(), "Filename to use for producing summary output file. If empty, do not produce a file.")
   ("SummaryPicFilenameBase",                          m_summaryPicFilenameBase,                      string(), "Base filename to use for producing summary picture output files. The actual filenames used will have I.txt, P.txt and B.txt appended. If empty, do not produce a file.")
   ("SummaryVerboseness",                              m_summaryVerboseness,                                0u, "Specifies the level of the verboseness of the text output")
-  ("Verbosity,v",                                     m_verbosity,                               (int)VERBOSE, "Specifies the level of the verboseness")
+  ("Verbosity,v",                                     m_verbosity,                               (int)VTM_VERBOSE, "Specifies the level of the verboseness")
 
 #if JVET_O0756_CONFIG_HDRMETRICS || JVET_O0756_CALCULATE_HDRMETRICS
   ( "WhitePointDeltaE1",                              m_whitePointDeltaE[0],                            100.0, "1st reference white point value")
@@ -1656,7 +1656,7 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
 
   for (list<const char*>::const_iterator it = argv_unhandled.begin(); it != argv_unhandled.end(); it++)
   {
-    msg( ERROR, "Unhandled argument ignored: `%s'\n", *it);
+    msg( VTM_ERROR, "Unhandled argument ignored: `%s'\n", *it);
   }
 
   if (argc == 1 || do_help)
@@ -1829,17 +1829,17 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
   if (m_costMode != COST_LOSSLESS_CODING && m_mixedLossyLossless)
   {
     m_mixedLossyLossless = 0;
-    msg(WARNING, "*************************************************************************\n");
-    msg(WARNING, "* Mixed lossy lossles coding cannot enable in lossy costMode *\n");
-    msg(WARNING, "* Forcely disabled  m_mixedLossyLossless *\n");
-    msg(WARNING, "*************************************************************************\n");
+    msg(VTM_WARNING, "*************************************************************************\n");
+    msg(VTM_WARNING, "* Mixed lossy lossles coding cannot enable in lossy costMode *\n");
+    msg(VTM_WARNING, "* Forcely disabled  m_mixedLossyLossless *\n");
+    msg(VTM_WARNING, "*************************************************************************\n");
   }
   if (!m_mixedLossyLossless && cfgSliceLosslessArray.values.size() > 0)
   {
-    msg(WARNING, "*************************************************************************\n");
-    msg(WARNING, "* Mixed lossy lossles coding is not enabled *\n");
-    msg(WARNING, "* ignoring the value of SliceLosslessArray *\n");
-    msg(WARNING, "*************************************************************************\n");
+    msg(VTM_WARNING, "*************************************************************************\n");
+    msg(VTM_WARNING, "* Mixed lossy lossles coding is not enabled *\n");
+    msg(VTM_WARNING, "* ignoring the value of SliceLosslessArray *\n");
+    msg(VTM_WARNING, "*************************************************************************\n");
   }
 
   if (m_costMode == COST_LOSSLESS_CODING && m_mixedLossyLossless)
@@ -2061,11 +2061,11 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
       // conformance
       if ((m_confWinLeft == 0) && (m_confWinRight == 0) && (m_confWinTop == 0) && (m_confWinBottom == 0))
       {
-        msg( ERROR, "Warning: Conformance window enabled, but all conformance window parameters set to zero\n");
+        msg( VTM_ERROR, "Warning: Conformance window enabled, but all conformance window parameters set to zero\n");
       }
       if ((m_sourcePadding[1] != 0) || (m_sourcePadding[0]!=0))
       {
-        msg( ERROR, "Warning: Conformance window enabled, padding parameters will be ignored\n");
+        msg( VTM_ERROR, "Warning: Conformance window enabled, padding parameters will be ignored\n");
       }
       m_sourcePadding[1] = m_sourcePadding[0] = 0;
       break;
@@ -2273,12 +2273,12 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
   {
     if (!m_horCollocatedChromaFlag)
     {
-      msg(WARNING, "\nWARNING: HorCollocatedChroma is forced to 1 for chroma formats other than 4:2:0\n");
+      msg(VTM_WARNING, "\nWARNING: HorCollocatedChroma is forced to 1 for chroma formats other than 4:2:0\n");
       m_horCollocatedChromaFlag = true;
     }
     if (!m_verCollocatedChromaFlag)
     {
-      msg(WARNING, "\nWARNING: VerCollocatedChroma is forced to 1 for chroma formats other than 4:2:0\n");
+      msg(VTM_WARNING, "\nWARNING: VerCollocatedChroma is forced to 1 for chroma formats other than 4:2:0\n");
       m_verCollocatedChromaFlag = true;
     }
   }
@@ -2507,16 +2507,16 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
   {
     std::string sChannelsList;
     g_trace_ctx->getChannelsList( sChannelsList );
-    msg( INFO, "\n Using tracing channels:\n\n%s\n", sChannelsList.c_str() );
+    msg( VTM_INFO, "\n Using tracing channels:\n\n%s\n", sChannelsList.c_str() );
   }
 #endif
 
 #if ENABLE_QPA
   if (m_bUsePerceptQPA && !m_bUseAdaptiveQP && m_dualTree && (m_cbQpOffsetDualTree != 0 || m_crQpOffsetDualTree != 0 || m_cbCrQpOffsetDualTree != 0))
   {
-    msg( WARNING, "*************************************************************************\n" );
-    msg( WARNING, "* WARNING: chroma QPA on, ignoring nonzero dual-tree chroma QP offsets! *\n" );
-    msg( WARNING, "*************************************************************************\n" );
+    msg( VTM_WARNING, "*************************************************************************\n" );
+    msg( VTM_WARNING, "* VTM_WARNING: chroma QPA on, ignoring nonzero dual-tree chroma QP offsets! *\n" );
+    msg( VTM_WARNING, "*************************************************************************\n" );
   }
 
 #if ENABLE_QPA_SUB_CTU
@@ -2539,9 +2539,9 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
   if( ( ( int ) m_fQP < 38 ) && ( m_iGOPSize > 4 ) && m_bUsePerceptQPA && !m_bUseAdaptiveQP && ( m_iSourceHeight <= 1280 ) && ( m_iSourceWidth <= 2048 ) )
  #endif
   {
-    msg( WARNING, "*************************************************************************\n" );
-    msg( WARNING, "* WARNING: QPA on with large CTU for <=HD sequences, limiting CTU size! *\n" );
-    msg( WARNING, "*************************************************************************\n" );
+    msg( VTM_WARNING, "*************************************************************************\n" );
+    msg( VTM_WARNING, "* VTM_WARNING: QPA on with large CTU for <=HD sequences, limiting CTU size! *\n" );
+    msg( VTM_WARNING, "*************************************************************************\n" );
 
     m_uiCTUSize = m_uiMaxCUWidth;
     if( ( 1u << m_log2MaxTbSize         ) > m_uiCTUSize ) m_log2MaxTbSize--;
@@ -2646,26 +2646,26 @@ int EncAppCfg::xAutoDetermineProfile()
 
 bool EncAppCfg::xCheckParameter()
 {
-  msg( NOTICE, "\n" );
+  msg( VTM_NOTICE, "\n" );
   if (m_decodedPictureHashSEIType==HASHTYPE_NONE)
   {
-    msg( DETAILS, "******************************************************************\n");
-    msg( DETAILS, "** WARNING: --SEIDecodedPictureHash is now disabled by default. **\n");
-    msg( DETAILS, "**          Automatic verification of decoded pictures by a     **\n");
-    msg( DETAILS, "**          decoder requires this option to be enabled.         **\n");
-    msg( DETAILS, "******************************************************************\n");
+    msg( VTM_DETAILS, "******************************************************************\n");
+    msg( VTM_DETAILS, "** VTM_WARNING: --SEIDecodedPictureHash is now disabled by default. **\n");
+    msg( VTM_DETAILS, "**          Automatic verification of decoded pictures by a     **\n");
+    msg( VTM_DETAILS, "**          decoder requires this option to be enabled.         **\n");
+    msg( VTM_DETAILS, "******************************************************************\n");
   }
   if( m_profile==Profile::NONE )
   {
-    msg( DETAILS, "***************************************************************************\n");
-    msg( DETAILS, "** WARNING: For conforming bitstreams a valid Profile value must be set! **\n");
-    msg( DETAILS, "***************************************************************************\n");
+    msg( VTM_DETAILS, "***************************************************************************\n");
+    msg( VTM_DETAILS, "** VTM_WARNING: For conforming bitstreams a valid Profile value must be set! **\n");
+    msg( VTM_DETAILS, "***************************************************************************\n");
   }
   if( m_level==Level::NONE )
   {
-    msg( DETAILS, "***************************************************************************\n");
-    msg( DETAILS, "** WARNING: For conforming bitstreams a valid Level value must be set!   **\n");
-    msg( DETAILS, "***************************************************************************\n");
+    msg( VTM_DETAILS, "***************************************************************************\n");
+    msg( VTM_DETAILS, "** VTM_WARNING: For conforming bitstreams a valid Level value must be set!   **\n");
+    msg( VTM_DETAILS, "***************************************************************************\n");
   }
 
   bool check_failed = false; /* abort if there is a fatal configuration problem */
@@ -2691,9 +2691,9 @@ bool EncAppCfg::xCheckParameter()
   xConfirmPara( m_bUsePerceptQPA && m_lumaLevelToDeltaQPMapping.mode >= 2, "QPA and SharpDeltaQP mode 2 cannot be used together" );
   if( m_bUsePerceptQPA && m_lumaLevelToDeltaQPMapping.mode == LUMALVL_TO_DQP_AVG_METHOD )
   {
-    msg( WARNING, "*********************************************************************************\n" );
-    msg( WARNING, "** WARNING: Applying custom luma-based QPA with activity-based perceptual QPA! **\n" );
-    msg( WARNING, "*********************************************************************************\n" );
+    msg( VTM_WARNING, "*********************************************************************************\n" );
+    msg( VTM_WARNING, "** VTM_WARNING: Applying custom luma-based QPA with activity-based perceptual QPA! **\n" );
+    msg( VTM_WARNING, "*********************************************************************************\n" );
 
     m_lumaLevelToDeltaQPMapping.mode = LUMALVL_TO_DQP_NUM_MODES; // special QPA mode
   }
@@ -2730,10 +2730,10 @@ bool EncAppCfg::xCheckParameter()
 
   if( (m_internalBitDepth[CHANNEL_TYPE_LUMA] < m_inputBitDepth[CHANNEL_TYPE_LUMA]) || (m_internalBitDepth[CHANNEL_TYPE_CHROMA] < m_inputBitDepth[CHANNEL_TYPE_CHROMA]) )
   {
-      msg(WARNING, "*****************************************************************************\n");
-      msg(WARNING, "** WARNING: InternalBitDepth is set to the lower value than InputBitDepth! **\n");
-      msg(WARNING, "**          min_qp_prime_ts_minus4 will be clipped to 0 at the low end!    **\n");
-      msg(WARNING, "*****************************************************************************\n");
+      msg(VTM_WARNING, "*****************************************************************************\n");
+      msg(VTM_WARNING, "** VTM_WARNING: InternalBitDepth is set to the lower value than InputBitDepth! **\n");
+      msg(VTM_WARNING, "**          min_qp_prime_ts_minus4 will be clipped to 0 at the low end!    **\n");
+      msg(VTM_WARNING, "*****************************************************************************\n");
   }
 
 #if !RExt__HIGH_BIT_DEPTH_SUPPORT
@@ -2775,16 +2775,16 @@ bool EncAppCfg::xCheckParameter()
   {
     if (!m_frameFieldInfoSEIEnabled)
     {
-      msg( WARNING, "*************************************************************************************\n");
-      msg( WARNING, "** WARNING: Frame field information SEI should be enabled for field coding!        **\n");
-      msg( WARNING, "*************************************************************************************\n");
+      msg( VTM_WARNING, "*************************************************************************************\n");
+      msg( VTM_WARNING, "** VTM_WARNING: Frame field information SEI should be enabled for field coding!        **\n");
+      msg( VTM_WARNING, "*************************************************************************************\n");
     }
   }
   if ( m_pictureTimingSEIEnabled && (!m_bufferingPeriodSEIEnabled))
   {
-    msg( WARNING, "****************************************************************************\n");
-    msg( WARNING, "** WARNING: Picture Timing SEI requires Buffering Period SEI. Disabling.  **\n");
-    msg( WARNING, "****************************************************************************\n");
+    msg( VTM_WARNING, "****************************************************************************\n");
+    msg( VTM_WARNING, "** VTM_WARNING: Picture Timing SEI requires Buffering Period SEI. Disabling.  **\n");
+    msg( VTM_WARNING, "****************************************************************************\n");
     m_pictureTimingSEIEnabled = false;
   }
 
@@ -2825,7 +2825,7 @@ bool EncAppCfg::xCheckParameter()
 #endif
   if (m_lumaLevelToDeltaQPMapping.mode && m_lmcsEnabled)
   {
-    msg(WARNING, "For HDR-PQ, LMCS should be used mutual-exclusively with Luma-level-based Delta QP. If use LMCS, turn lumaDQP off.\n");
+    msg(VTM_WARNING, "For HDR-PQ, LMCS should be used mutual-exclusively with Luma-level-based Delta QP. If use LMCS, turn lumaDQP off.\n");
     m_lumaLevelToDeltaQPMapping.mode = LUMALVL_TO_DQP_DISABLED;
   }
   if (!m_lmcsEnabled)
@@ -2868,9 +2868,9 @@ bool EncAppCfg::xCheckParameter()
   xConfirmPara( m_crQpOffsetDualTree >  12,   "Max. Chroma Cr QP Offset for dual tree is  12" );
   if (m_dualTree && (m_chromaFormatIDC == CHROMA_400))
   {
-    msg( WARNING, "****************************************************************************\n");
-    msg( WARNING, "** WARNING: --DualITree has been disabled because the chromaFormat is 400 **\n");
-    msg( WARNING, "****************************************************************************\n");
+    msg( VTM_WARNING, "****************************************************************************\n");
+    msg( VTM_WARNING, "** VTM_WARNING: --DualITree has been disabled because the chromaFormat is 400 **\n");
+    msg( VTM_WARNING, "****************************************************************************\n");
     m_dualTree = false;
   }
   if (m_alf)
@@ -2899,16 +2899,16 @@ bool EncAppCfg::xCheckParameter()
   }
   if (m_ccalf && (m_chromaFormatIDC == CHROMA_400))
   {
-    msg( WARNING, "****************************************************************************\n");
-    msg( WARNING, "** WARNING: --CCALF has been disabled because the chromaFormat is 400     **\n");
-    msg( WARNING, "****************************************************************************\n");
+    msg( VTM_WARNING, "****************************************************************************\n");
+    msg( VTM_WARNING, "** VTM_WARNING: --CCALF has been disabled because the chromaFormat is 400     **\n");
+    msg( VTM_WARNING, "****************************************************************************\n");
     m_ccalf = false;
   }
   if (m_JointCbCrMode && (m_chromaFormatIDC == CHROMA_400))
   {
-    msg( WARNING, "****************************************************************************\n");
-    msg( WARNING, "** WARNING: --JointCbCr has been disabled because the chromaFormat is 400 **\n");
-    msg( WARNING, "****************************************************************************\n");
+    msg( VTM_WARNING, "****************************************************************************\n");
+    msg( VTM_WARNING, "** VTM_WARNING: --JointCbCr has been disabled because the chromaFormat is 400 **\n");
+    msg( VTM_WARNING, "****************************************************************************\n");
     m_JointCbCrMode = false;
   }
   if (m_JointCbCrMode)
@@ -2990,7 +2990,7 @@ bool EncAppCfg::xCheckParameter()
   if ( m_Affine == 0 )
   {
     m_maxNumAffineMergeCand = m_sbTmvpEnableFlag ? 1 : 0;
-    if (m_PROF) msg(WARNING, "PROF is forcefully disabled when Affine is off \n");
+    if (m_PROF) msg(VTM_WARNING, "PROF is forcefully disabled when Affine is off \n");
     m_PROF = false;
   }
 
@@ -3133,7 +3133,7 @@ bool EncAppCfg::xCheckParameter()
     int curPOC = ((checkGOP - 1) / m_iGOPSize)*m_iGOPSize * multipleFactor + m_RPLList0[curGOP].m_POC;
     if (m_RPLList0[curGOP].m_POC < 0 || m_RPLList1[curGOP].m_POC < 0)
     {
-      msg(WARNING, "\nError: found fewer Reference Picture Sets than GOPSize\n");
+      msg(VTM_WARNING, "\nError: found fewer Reference Picture Sets than GOPSize\n");
       errorGOP = true;
     }
     else
@@ -3169,7 +3169,7 @@ bool EncAppCfg::xCheckParameter()
           }
           if (!found)
           {
-            msg(WARNING, "\nError: ref pic %d is not available for GOP frame %d\n", m_RPLList0[curGOP].m_deltaRefPics[i], curGOP + 1);
+            msg(VTM_WARNING, "\nError: ref pic %d is not available for GOP frame %d\n", m_RPLList0[curGOP].m_deltaRefPics[i], curGOP + 1);
             errorGOP = true;
           }
         }
@@ -3737,7 +3737,7 @@ bool EncAppCfg::xCheckParameter()
     {
       if ( m_RCInitialQP == 0 )
       {
-        msg( WARNING, "\nInitial QP for rate control is not specified. Reset not to use force intra QP!" );
+        msg( VTM_WARNING, "\nInitial QP for rate control is not specified. Reset not to use force intra QP!" );
         m_RCForceIntraQP = false;
       }
     }
@@ -3920,7 +3920,7 @@ const char *profileToString(const Profile::Name profile)
   }
 
   //if we get here, we didn't find this profile in the list - so there is an error
-  EXIT( "ERROR: Unknown profile \"" << profile << "\" in profileToString" );
+  EXIT( "VTM_ERROR: Unknown profile \"" << profile << "\" in profileToString" );
   return "";
 }
 
@@ -4092,157 +4092,157 @@ void EncAppCfg::xPrintParameter()
   msg( DETAILS, "Max Num IBC Merge Candidates           : %d\n", m_maxNumIBCMergeCand );
   msg( DETAILS, "\n");
 
-  msg( VERBOSE, "TOOL CFG: ");
-  msg( VERBOSE, "IBD:%d ", ((m_internalBitDepth[CHANNEL_TYPE_LUMA] > m_MSBExtendedBitDepth[CHANNEL_TYPE_LUMA]) || (m_internalBitDepth[CHANNEL_TYPE_CHROMA] > m_MSBExtendedBitDepth[CHANNEL_TYPE_CHROMA])));
-  msg( VERBOSE, "HAD:%d ", m_bUseHADME                          );
-  msg( VERBOSE, "RDQ:%d ", m_useRDOQ                            );
-  msg( VERBOSE, "RDQTS:%d ", m_useRDOQTS                        );
-  msg( VERBOSE, "RDpenalty:%d ", m_rdPenalty                    );
+  msg( VTM_VERBOSE, "TOOL CFG: ");
+  msg( VTM_VERBOSE, "IBD:%d ", ((m_internalBitDepth[CHANNEL_TYPE_LUMA] > m_MSBExtendedBitDepth[CHANNEL_TYPE_LUMA]) || (m_internalBitDepth[CHANNEL_TYPE_CHROMA] > m_MSBExtendedBitDepth[CHANNEL_TYPE_CHROMA])));
+  msg( VTM_VERBOSE, "HAD:%d ", m_bUseHADME                          );
+  msg( VTM_VERBOSE, "RDQ:%d ", m_useRDOQ                            );
+  msg( VTM_VERBOSE, "RDQTS:%d ", m_useRDOQTS                        );
+  msg( VTM_VERBOSE, "RDpenalty:%d ", m_rdPenalty                    );
 #if SHARP_LUMA_DELTA_QP
-  msg( VERBOSE, "LQP:%d ", m_lumaLevelToDeltaQPMapping.mode     );
+  msg( VTM_VERBOSE, "LQP:%d ", m_lumaLevelToDeltaQPMapping.mode     );
 #endif
-  msg( VERBOSE, "SQP:%d ", m_uiDeltaQpRD                        );
-  msg( VERBOSE, "ASR:%d ", m_bUseASR                            );
-  msg( VERBOSE, "MinSearchWindow:%d ", m_minSearchWindow        );
-  msg( VERBOSE, "RestrictMESampling:%d ", m_bRestrictMESampling );
-  msg( VERBOSE, "FEN:%d ", int(m_fastInterSearchMode)           );
-  msg( VERBOSE, "ECU:%d ", m_bUseEarlyCU                        );
-  msg( VERBOSE, "FDM:%d ", m_useFastDecisionForMerge            );
-  msg( VERBOSE, "ESD:%d ", m_useEarlySkipDetection              );
-  msg( VERBOSE, "TransformSkip:%d ",     m_useTransformSkip     );
-  msg( VERBOSE, "TransformSkipFast:%d ", m_useTransformSkipFast );
-  msg( VERBOSE, "TransformSkipLog2MaxSize:%d ", m_log2MaxTransformSkipBlockSize);
-  msg(VERBOSE, "ChromaTS:%d ", m_useChromaTS);
-  msg( VERBOSE, "BDPCM:%d ", m_useBDPCM                         );
-  msg( VERBOSE, "Tiles: %dx%d ", m_numTileCols, m_numTileRows );
-  msg( VERBOSE, "Slices: %d ", m_numSlicesInPic);
-  msg( VERBOSE, "MCTS:%d ", m_MCTSEncConstraint );
-  msg( VERBOSE, "SAO:%d ", (m_bUseSAO)?(1):(0));
-  msg( VERBOSE, "ALF:%d ", m_alf ? 1 : 0 );
-  msg( VERBOSE, "CCALF:%d ", m_ccalf ? 1 : 0 );
-
-  msg( VERBOSE, "WPP:%d ", (int)m_useWeightedPred);
-  msg( VERBOSE, "WPB:%d ", (int)m_useWeightedBiPred);
-  msg( VERBOSE, "PME:%d ", m_log2ParallelMergeLevel);
+  msg( VTM_VERBOSE, "SQP:%d ", m_uiDeltaQpRD                        );
+  msg( VTM_VERBOSE, "ASR:%d ", m_bUseASR                            );
+  msg( VTM_VERBOSE, "MinSearchWindow:%d ", m_minSearchWindow        );
+  msg( VTM_VERBOSE, "RestrictMESampling:%d ", m_bRestrictMESampling );
+  msg( VTM_VERBOSE, "FEN:%d ", int(m_fastInterSearchMode)           );
+  msg( VTM_VERBOSE, "ECU:%d ", m_bUseEarlyCU                        );
+  msg( VTM_VERBOSE, "FDM:%d ", m_useFastDecisionForMerge            );
+  msg( VTM_VERBOSE, "ESD:%d ", m_useEarlySkipDetection              );
+  msg( VTM_VERBOSE, "TransformSkip:%d ",     m_useTransformSkip     );
+  msg( VTM_VERBOSE, "TransformSkipFast:%d ", m_useTransformSkipFast );
+  msg( VTM_VERBOSE, "TransformSkipLog2MaxSize:%d ", m_log2MaxTransformSkipBlockSize);
+  msg(VTM_VERBOSE, "ChromaTS:%d ", m_useChromaTS);
+  msg( VTM_VERBOSE, "BDPCM:%d ", m_useBDPCM                         );
+  msg( VTM_VERBOSE, "Tiles: %dx%d ", m_numTileCols, m_numTileRows );
+  msg( VTM_VERBOSE, "Slices: %d ", m_numSlicesInPic);
+  msg( VTM_VERBOSE, "MCTS:%d ", m_MCTSEncConstraint );
+  msg( VTM_VERBOSE, "SAO:%d ", (m_bUseSAO)?(1):(0));
+  msg( VTM_VERBOSE, "ALF:%d ", m_alf ? 1 : 0 );
+  msg( VTM_VERBOSE, "CCALF:%d ", m_ccalf ? 1 : 0 );
+
+  msg( VTM_VERBOSE, "WPP:%d ", (int)m_useWeightedPred);
+  msg( VTM_VERBOSE, "WPB:%d ", (int)m_useWeightedBiPred);
+  msg( VTM_VERBOSE, "PME:%d ", m_log2ParallelMergeLevel);
   const int iWaveFrontSubstreams = m_entropyCodingSyncEnabledFlag ? (m_sourceHeight + m_uiMaxCUHeight - 1) / m_uiMaxCUHeight : 1;
-  msg( VERBOSE, " WaveFrontSynchro:%d WaveFrontSubstreams:%d", m_entropyCodingSyncEnabledFlag?1:0, iWaveFrontSubstreams);
-  msg( VERBOSE, " ScalingList:%d ", m_useScalingListId );
-  msg( VERBOSE, "TMVPMode:%d ", m_TMVPModeId );
-  msg( VERBOSE, " DQ:%d ", m_depQuantEnabledFlag);
-  msg( VERBOSE, " SignBitHidingFlag:%d ", m_signDataHidingEnabledFlag);
-  msg( VERBOSE, "RecalQP:%d ", m_recalculateQPAccordingToLambda ? 1 : 0 );
-
-  {
-    msg( VERBOSE, "\nTOOL CFG: " );
-    msg( VERBOSE, "LFNST:%d ", m_LFNST );
-    msg( VERBOSE, "MMVD:%d ", m_MMVD);
-    msg( VERBOSE, "Affine:%d ", m_Affine );
+  msg( VTM_VERBOSE, " WaveFrontSynchro:%d WaveFrontSubstreams:%d", m_entropyCodingSyncEnabledFlag?1:0, iWaveFrontSubstreams);
+  msg( VTM_VERBOSE, " ScalingList:%d ", m_useScalingListId );
+  msg( VTM_VERBOSE, "TMVPMode:%d ", m_TMVPModeId );
+  msg( VTM_VERBOSE, " DQ:%d ", m_depQuantEnabledFlag);
+  msg( VTM_VERBOSE, " SignBitHidingFlag:%d ", m_signDataHidingEnabledFlag);
+  msg( VTM_VERBOSE, "RecalQP:%d ", m_recalculateQPAccordingToLambda ? 1 : 0 );
+
+  {
+    msg( VTM_VERBOSE, "\nTOOL CFG: " );
+    msg( VTM_VERBOSE, "LFNST:%d ", m_LFNST );
+    msg( VTM_VERBOSE, "MMVD:%d ", m_MMVD);
+    msg( VTM_VERBOSE, "Affine:%d ", m_Affine );
     if ( m_Affine )
     {
-      msg( VERBOSE, "AffineType:%d ", m_AffineType );
+      msg( VTM_VERBOSE, "AffineType:%d ", m_AffineType );
     }
-    msg(VERBOSE, "PROF:%d ", m_PROF);
-    msg(VERBOSE, "SbTMVP:%d ", m_sbTmvpEnableFlag);
-    msg( VERBOSE, "DualITree:%d ", m_dualTree );
-    msg( VERBOSE, "IMV:%d ", m_ImvMode );
-    msg( VERBOSE, "BIO:%d ", m_BIO );
-    msg( VERBOSE, "LMChroma:%d ", m_LMChroma );
-    msg( VERBOSE, "HorCollocatedChroma:%d ", m_horCollocatedChromaFlag );
-    msg( VERBOSE, "VerCollocatedChroma:%d ", m_verCollocatedChromaFlag );
-    msg( VERBOSE, "MTS: %1d(intra) %1d(inter) ", m_MTS & 1, ( m_MTS >> 1 ) & 1 );
-    msg( VERBOSE, "SBT:%d ", m_SBT );
-    msg( VERBOSE, "ISP:%d ", m_ISP );
-    msg( VERBOSE, "SMVD:%d ", m_SMVD );
-    msg( VERBOSE, "CompositeLTReference:%d ", m_compositeRefEnabled);
-    msg( VERBOSE, "Bcw:%d ", m_bcw );
-    msg( VERBOSE, "BcwFast:%d ", m_BcwFast );
+    msg(VTM_VERBOSE, "PROF:%d ", m_PROF);
+    msg(VTM_VERBOSE, "SbTMVP:%d ", m_sbTmvpEnableFlag);
+    msg( VTM_VERBOSE, "DualITree:%d ", m_dualTree );
+    msg( VTM_VERBOSE, "IMV:%d ", m_ImvMode );
+    msg( VTM_VERBOSE, "BIO:%d ", m_BIO );
+    msg( VTM_VERBOSE, "LMChroma:%d ", m_LMChroma );
+    msg( VTM_VERBOSE, "HorCollocatedChroma:%d ", m_horCollocatedChromaFlag );
+    msg( VTM_VERBOSE, "VerCollocatedChroma:%d ", m_verCollocatedChromaFlag );
+    msg( VTM_VERBOSE, "MTS: %1d(intra) %1d(inter) ", m_MTS & 1, ( m_MTS >> 1 ) & 1 );
+    msg( VTM_VERBOSE, "SBT:%d ", m_SBT );
+    msg( VTM_VERBOSE, "ISP:%d ", m_ISP );
+    msg( VTM_VERBOSE, "SMVD:%d ", m_SMVD );
+    msg( VTM_VERBOSE, "CompositeLTReference:%d ", m_compositeRefEnabled);
+    msg( VTM_VERBOSE, "Bcw:%d ", m_bcw );
+    msg( VTM_VERBOSE, "BcwFast:%d ", m_BcwFast );
 #if LUMA_ADAPTIVE_DEBLOCKING_FILTER_QP_OFFSET
-    msg( VERBOSE, "LADF:%d ", m_LadfEnabed );
+    msg( VTM_VERBOSE, "LADF:%d ", m_LadfEnabed );
 #endif
-    msg(VERBOSE, "CIIP:%d ", m_ciip);
-    msg( VERBOSE, "Geo:%d ", m_Geo );
+    msg(VTM_VERBOSE, "CIIP:%d ", m_ciip);
+    msg( VTM_VERBOSE, "Geo:%d ", m_Geo );
     m_allowDisFracMMVD = m_MMVD ? m_allowDisFracMMVD : false;
     if ( m_MMVD )
-      msg(VERBOSE, "AllowDisFracMMVD:%d ", m_allowDisFracMMVD);
-    msg( VERBOSE, "AffineAmvr:%d ", m_AffineAmvr );
+      msg(VTM_VERBOSE, "AllowDisFracMMVD:%d ", m_allowDisFracMMVD);
+    msg( VTM_VERBOSE, "AffineAmvr:%d ", m_AffineAmvr );
     m_AffineAmvrEncOpt = m_AffineAmvr ? m_AffineAmvrEncOpt : false;
-    msg( VERBOSE, "AffineAmvrEncOpt:%d ", m_AffineAmvrEncOpt );
-    msg(VERBOSE, "DMVR:%d ", m_DMVR);
-    msg(VERBOSE, "MmvdDisNum:%d ", m_MmvdDisNum);
-    msg(VERBOSE, "JointCbCr:%d ", m_JointCbCrMode);
+    msg( VTM_VERBOSE, "AffineAmvrEncOpt:%d ", m_AffineAmvrEncOpt );
+    msg(VTM_VERBOSE, "DMVR:%d ", m_DMVR);
+    msg(VTM_VERBOSE, "MmvdDisNum:%d ", m_MmvdDisNum);
+    msg(VTM_VERBOSE, "JointCbCr:%d ", m_JointCbCrMode);
   }
   m_useColorTrans = (m_chromaFormatIDC == CHROMA_444) ? m_useColorTrans : 0u;
-  msg(VERBOSE, "ACT:%d ", m_useColorTrans);
-    msg(VERBOSE, "PLT:%d ", m_PLTMode);
-    msg(VERBOSE, "IBC:%d ", m_IBCMode);
-  msg( VERBOSE, "HashME:%d ", m_HashME );
-  msg( VERBOSE, "WrapAround:%d ", m_wrapAround);
+  msg(VTM_VERBOSE, "ACT:%d ", m_useColorTrans);
+    msg(VTM_VERBOSE, "PLT:%d ", m_PLTMode);
+    msg(VTM_VERBOSE, "IBC:%d ", m_IBCMode);
+  msg( VTM_VERBOSE, "HashME:%d ", m_HashME );
+  msg( VTM_VERBOSE, "WrapAround:%d ", m_wrapAround);
   if( m_wrapAround )
   {
-    msg( VERBOSE, "WrapAroundOffset:%d ", m_wrapAroundOffset );
+    msg( VTM_VERBOSE, "WrapAroundOffset:%d ", m_wrapAroundOffset );
   }
   // ADD_NEW_TOOL (add some output indicating the usage of tools)
-  msg( VERBOSE, "VirtualBoundariesEnabledFlag:%d ", m_virtualBoundariesEnabledFlag );
-  msg( VERBOSE, "VirtualBoundariesPresentInSPSFlag:%d ", m_virtualBoundariesPresentFlag );
+  msg( VTM_VERBOSE, "VirtualBoundariesEnabledFlag:%d ", m_virtualBoundariesEnabledFlag );
+  msg( VTM_VERBOSE, "VirtualBoundariesPresentInSPSFlag:%d ", m_virtualBoundariesPresentFlag );
   if( m_virtualBoundariesPresentFlag )
   {
-    msg(VERBOSE, "vertical virtual boundaries:[");
+    msg(VTM_VERBOSE, "vertical virtual boundaries:[");
     for (unsigned i = 0; i < m_numVerVirtualBoundaries; i++)
     {
-      msg(VERBOSE, " %d", m_virtualBoundariesPosX[i]);
+      msg(VTM_VERBOSE, " %d", m_virtualBoundariesPosX[i]);
     }
-    msg(VERBOSE, " ] horizontal virtual boundaries:[");
+    msg(VTM_VERBOSE, " ] horizontal virtual boundaries:[");
     for (unsigned i = 0; i < m_numHorVirtualBoundaries; i++)
     {
-      msg(VERBOSE, " %d", m_virtualBoundariesPosY[i]);
+      msg(VTM_VERBOSE, " %d", m_virtualBoundariesPosY[i]);
     }
-    msg(VERBOSE, " ] ");
+    msg(VTM_VERBOSE, " ] ");
   }
-    msg(VERBOSE, "Reshape:%d ", m_lmcsEnabled);
+    msg(VTM_VERBOSE, "Reshape:%d ", m_lmcsEnabled);
     if (m_lmcsEnabled)
     {
-      msg(VERBOSE, "(Signal:%s ", m_reshapeSignalType == 0 ? "SDR" : (m_reshapeSignalType == 2 ? "HDR-HLG" : "HDR-PQ"));
-      msg(VERBOSE, "Opt:%d", m_adpOption);
-      if (m_adpOption > 0) { msg(VERBOSE, " CW:%d", m_initialCW); }
-      msg(VERBOSE, " CSoffset:%d", m_CSoffset);
-      msg(VERBOSE, ") ");
+      msg(VTM_VERBOSE, "(Signal:%s ", m_reshapeSignalType == 0 ? "SDR" : (m_reshapeSignalType == 2 ? "HDR-HLG" : "HDR-PQ"));
+      msg(VTM_VERBOSE, "Opt:%d", m_adpOption);
+      if (m_adpOption > 0) { msg(VTM_VERBOSE, " CW:%d", m_initialCW); }
+      msg(VTM_VERBOSE, " CSoffset:%d", m_CSoffset);
+      msg(VTM_VERBOSE, ") ");
     }
-    msg(VERBOSE, "MRL:%d ", m_MRL);
-    msg(VERBOSE, "MIP:%d ", m_MIP);
-    msg(VERBOSE, "EncDbOpt:%d ", m_encDbOpt);
-  msg( VERBOSE, "\nFAST TOOL CFG: " );
-  msg( VERBOSE, "LCTUFast:%d ", m_useFastLCTU );
-  msg( VERBOSE, "FastMrg:%d ", m_useFastMrg );
-  msg( VERBOSE, "PBIntraFast:%d ", m_usePbIntraFast );
-  if( m_ImvMode ) msg( VERBOSE, "IMV4PelFast:%d ", m_Imv4PelFast );
-  if( m_MTS ) msg( VERBOSE, "MTSMaxCand: %1d(intra) %1d(inter) ", m_MTSIntraMaxCand, m_MTSInterMaxCand );
-  if( m_ISP ) msg( VERBOSE, "ISPFast:%d ", m_useFastISP );
-  if( m_LFNST ) msg( VERBOSE, "FastLFNST:%d ", m_useFastLFNST );
-  msg( VERBOSE, "AMaxBT:%d ", m_useAMaxBT );
-  msg( VERBOSE, "E0023FastEnc:%d ", m_e0023FastEnc );
-  msg( VERBOSE, "ContentBasedFastQtbt:%d ", m_contentBasedFastQtbt );
-  msg( VERBOSE, "UseNonLinearAlfLuma:%d ", m_useNonLinearAlfLuma );
-  msg( VERBOSE, "UseNonLinearAlfChroma:%d ", m_useNonLinearAlfChroma );
-  msg( VERBOSE, "MaxNumAlfAlternativesChroma:%d ", m_maxNumAlfAlternativesChroma );
-  if( m_MIP ) msg(VERBOSE, "FastMIP:%d ", m_useFastMIP);
-  msg( VERBOSE, "FastLocalDualTree:%d ", m_fastLocalDualTreeMode );
+    msg(VTM_VERBOSE, "MRL:%d ", m_MRL);
+    msg(VTM_VERBOSE, "MIP:%d ", m_MIP);
+    msg(VTM_VERBOSE, "EncDbOpt:%d ", m_encDbOpt);
+  msg( VTM_VERBOSE, "\nFAST TOOL CFG: " );
+  msg( VTM_VERBOSE, "LCTUFast:%d ", m_useFastLCTU );
+  msg( VTM_VERBOSE, "FastMrg:%d ", m_useFastMrg );
+  msg( VTM_VERBOSE, "PBIntraFast:%d ", m_usePbIntraFast );
+  if( m_ImvMode ) msg( VTM_VERBOSE, "IMV4PelFast:%d ", m_Imv4PelFast );
+  if( m_MTS ) msg( VTM_VERBOSE, "MTSMaxCand: %1d(intra) %1d(inter) ", m_MTSIntraMaxCand, m_MTSInterMaxCand );
+  if( m_ISP ) msg( VTM_VERBOSE, "ISPFast:%d ", m_useFastISP );
+  if( m_LFNST ) msg( VTM_VERBOSE, "FastLFNST:%d ", m_useFastLFNST );
+  msg( VTM_VERBOSE, "AMaxBT:%d ", m_useAMaxBT );
+  msg( VTM_VERBOSE, "E0023FastEnc:%d ", m_e0023FastEnc );
+  msg( VTM_VERBOSE, "ContentBasedFastQtbt:%d ", m_contentBasedFastQtbt );
+  msg( VTM_VERBOSE, "UseNonLinearAlfLuma:%d ", m_useNonLinearAlfLuma );
+  msg( VTM_VERBOSE, "UseNonLinearAlfChroma:%d ", m_useNonLinearAlfChroma );
+  msg( VTM_VERBOSE, "MaxNumAlfAlternativesChroma:%d ", m_maxNumAlfAlternativesChroma );
+  if( m_MIP ) msg(VTM_VERBOSE, "FastMIP:%d ", m_useFastMIP);
+  msg( VTM_VERBOSE, "FastLocalDualTree:%d ", m_fastLocalDualTreeMode );
 
   if (m_resChangeInClvsEnabled)
   {
-    msg( VERBOSE, "RPR:(%1.2lfx, %1.2lfx)|%d ", m_scalingRatioHor, m_scalingRatioVer, m_switchPocPeriod );
+    msg( VTM_VERBOSE, "RPR:(%1.2lfx, %1.2lfx)|%d ", m_scalingRatioHor, m_scalingRatioVer, m_switchPocPeriod );
   }
   else
   {
-    msg( VERBOSE, "RPR:%d ", 0 );
+    msg( VTM_VERBOSE, "RPR:%d ", 0 );
   }
-  msg(VERBOSE, "TemporalFilter:%d ", m_gopBasedTemporalFilterEnabled);
+  msg(VTM_VERBOSE, "TemporalFilter:%d ", m_gopBasedTemporalFilterEnabled);
 #if EXTENSION_360_VIDEO
   m_ext360.outputConfigurationSummary();
 #endif
 
-  msg( VERBOSE, "\n\n");
+  msg( VTM_VERBOSE, "\n\n");
 
-  msg( NOTICE, "\n");
+  msg( VTM_NOTICE, "\n");
 
   fflush( stdout );
 }
@@ -4289,7 +4289,7 @@ bool confirmPara(bool bflag, const char* message)
     return false;
   }
 
-  msg( ERROR, "Error: %s\n",message);
+  msg( VTM_ERROR, "Error: %s\n",message);
   return true;
 }
 
diff --git a/source/App/SEIRemovalApp/seiremovalmain.cpp b/source/App/SEIRemovalApp/seiremovalmain.cpp
index 309bb72..f797e2f 100644
--- a/source/App/SEIRemovalApp/seiremovalmain.cpp
+++ b/source/App/SEIRemovalApp/seiremovalmain.cpp
@@ -90,7 +90,7 @@ int main(int argc, char* argv[])
 #endif // !_DEBUG
     if( 0 != pcDecApp->decode() )
     {
-      printf( "\n\n***ERROR*** A decoding mismatch occured: signalled md5sum does not match\n" );
+      printf( "\n\n***VTM_ERROR*** A decoding mismatch occured: signalled md5sum does not match\n" );
       returnCode = EXIT_FAILURE;
     }
 #ifndef _DEBUG
diff --git a/source/App/StreamMergeApp/StreamMergeApp.cpp b/source/App/StreamMergeApp/StreamMergeApp.cpp
index 2f813ef..bb092e3 100644
--- a/source/App/StreamMergeApp/StreamMergeApp.cpp
+++ b/source/App/StreamMergeApp/StreamMergeApp.cpp
@@ -229,7 +229,7 @@ bool StreamMergeApp::isNewPicture(std::ifstream *bitstreamFile, InputByteStream
     byteStreamNALUnit(*bytestream, nalu.getBitstream().getFifo(), stats);
     if (nalu.getBitstream().getFifo().empty())
     {
-      msg(ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+      msg(VTM_ERROR, "Warning: Attempt to decode an empty NAL unit\n");
     }
     else
     {
@@ -325,7 +325,7 @@ bool StreamMergeApp::isNewAccessUnit(bool newPicture, std::ifstream *bitstreamFi
     byteStreamNALUnit(*bytestream, nalu.getBitstream().getFifo(), stats);
     if (nalu.getBitstream().getFifo().empty())
     {
-      msg(ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+      msg(VTM_ERROR, "Warning: Attempt to decode an empty NAL unit\n");
     }
     else
     {
@@ -414,7 +414,7 @@ bool StreamMergeApp::preInjectNalu(MergeLayer &layer, InputNALUnit &inNalu, Outp
     layer.psManager.storeVPS(vps, hlsReader.getBitstream()->getFifo());
     hlsWriter.codeVPS(vps);
     outNalu.m_nalUnitType = NAL_UNIT_VPS;
-    msg(INFO, " layer %i, nalu type VPS%i injected\n", layer.id, vps->getVPSId());
+    msg(VTM_INFO, " layer %i, nalu type VPS%i injected\n", layer.id, vps->getVPSId());
     return true;
   }
   default:
@@ -433,7 +433,7 @@ void StreamMergeApp::decodeAndRewriteNalu(MergeLayer &layer, InputNALUnit &inNal
   hlsReader.setBitstream(&inNalu.getBitstream());
   hlsWriter.setBitstream(&outNalu.m_Bitstream);
 
-  msg(INFO, " layer %i, nalu type ", layer.id);
+  msg(VTM_INFO, " layer %i, nalu type ", layer.id);
   switch (inNalu.m_nalUnitType)
   {
   case NAL_UNIT_SPS:
@@ -454,7 +454,7 @@ void StreamMergeApp::decodeAndRewriteNalu(MergeLayer &layer, InputNALUnit &inNal
     layer.oldIDsPsManager.storeSPS(oldSps, hlsReader.getBitstream()->getFifo());
     layer.psManager.storeSPS(newSps, hlsReader.getBitstream()->getFifo());
     hlsWriter.codeSPS(newSps);
-    msg(INFO, "SPS%i", newSps->getSPSId());
+    msg(VTM_INFO, "SPS%i", newSps->getSPSId());
     break;
   }
   case NAL_UNIT_PPS:
@@ -475,7 +475,7 @@ void StreamMergeApp::decodeAndRewriteNalu(MergeLayer &layer, InputNALUnit &inNal
     layer.oldIDsPsManager.storePPS(oldPps, hlsReader.getBitstream()->getFifo());
     layer.psManager.storePPS(newPps, hlsReader.getBitstream()->getFifo());
     hlsWriter.codePPS(newPps);
-    msg(INFO, "PPS%i", newPps->getPPSId());
+    msg(VTM_INFO, "PPS%i", newPps->getPPSId());
     break;
   }
   case NAL_UNIT_PREFIX_APS:
@@ -488,7 +488,7 @@ void StreamMergeApp::decodeAndRewriteNalu(MergeLayer &layer, InputNALUnit &inNal
     aps->setAPSId(idIncrement);
     layer.psManager.storeAPS(aps, hlsReader.getBitstream()->getFifo());
     hlsWriter.codeAPS(aps);
-    msg(INFO, "APS%s%i", inNalu.m_nalUnitType == NAL_UNIT_PREFIX_APS ? "p" : "s", aps->getAPSId());
+    msg(VTM_INFO, "APS%s%i", inNalu.m_nalUnitType == NAL_UNIT_PREFIX_APS ? "p" : "s", aps->getAPSId());
     break;
   }
   case NAL_UNIT_PH:
@@ -501,24 +501,24 @@ void StreamMergeApp::decodeAndRewriteNalu(MergeLayer &layer, InputNALUnit &inNal
     slice.setPOC(ph.getPocLsb());
     ph.setPPSId(layer.ppsIdMapping.at(ph.getPPSId()));
     hlsWriter.codePictureHeader(&ph, true, &slice);
-    msg(INFO, "PH");
+    msg(VTM_INFO, "PH");
     break;
   }
   default:
   {
     if (inNalu.isVcl())
     {
-      msg(INFO, "VCL");
+      msg(VTM_INFO, "VCL");
     }
     else if (inNalu.isSei())
     {
-      msg(INFO, "SEI");
+      msg(VTM_INFO, "SEI");
     }
     else
     {
-      msg(INFO, "NNN");   // Any other NAL unit that is not handled above
+      msg(VTM_INFO, "NNN");   // Any other NAL unit that is not handled above
     }
-    msg(INFO, " with index %i", inNalu.m_nalUnitType);
+    msg(VTM_INFO, " with index %i", inNalu.m_nalUnitType);
     // Copy payload from input nalu to output nalu. Code copied from SubpicMergeApp::copyInputNaluToOutputNalu().
     vector<uint8_t> &inFifo  = inNalu.getBitstream().getFifo();
     vector<uint8_t> &outFifo = outNalu.m_Bitstream.getFIFO();
@@ -526,7 +526,7 @@ void StreamMergeApp::decodeAndRewriteNalu(MergeLayer &layer, InputNALUnit &inNal
     break;
   }
   }
-  msg(INFO, "\n");
+  msg(VTM_INFO, "\n");
 }
 
 uint32_t StreamMergeApp::mergeStreams()
@@ -593,7 +593,7 @@ uint32_t StreamMergeApp::mergeStreams()
 
         if (inNalu.getBitstream().getFifo().empty())
         {
-          msg(ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+          msg(VTM_ERROR, "Warning: Attempt to decode an empty NAL unit\n");
           continue;
         }
 
diff --git a/source/App/StreamMergeApp/StreamMergeMain.cpp b/source/App/StreamMergeApp/StreamMergeMain.cpp
index ad7c047..fd9c065 100644
--- a/source/App/StreamMergeApp/StreamMergeMain.cpp
+++ b/source/App/StreamMergeApp/StreamMergeMain.cpp
@@ -78,7 +78,7 @@ int main(int argc, char* argv[])
   // call decoding function
   if (0 != pStrMergeApp->mergeStreams())
   {
-    printf("\n\n***ERROR*** A merge error happened\n");
+    printf("\n\n***VTM_ERROR*** A merge error happened\n");
     returnCode = EXIT_FAILURE;
   }
 
diff --git a/source/App/SubpicMergeApp/SubpicMergeApp.cpp b/source/App/SubpicMergeApp/SubpicMergeApp.cpp
index c590344..89f057c 100644
--- a/source/App/SubpicMergeApp/SubpicMergeApp.cpp
+++ b/source/App/SubpicMergeApp/SubpicMergeApp.cpp
@@ -160,7 +160,7 @@ bool SubpicMergeApp::isNewPicture(std::ifstream *bitstreamFile, InputByteStream
     byteStreamNALUnit(*bytestream, nalu.getBitstream().getFifo(), stats);
     if (nalu.getBitstream().getFifo().empty())
     {
-      msg( ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+      msg( VTM_ERROR, "Warning: Attempt to decode an empty NAL unit\n");
     }
     else
     {
@@ -245,7 +245,7 @@ bool SubpicMergeApp::isNewPicture(std::ifstream *bitstreamFile, InputByteStream
 bool SubpicMergeApp::parseDCI(HLSyntaxReader &hlsReader, DCI &dci)
 {
   hlsReader.parseDCI(&dci);
-  msg( INFO, "  DCI");
+  msg( VTM_INFO, "  DCI");
   return true;
 }
 
@@ -258,7 +258,7 @@ int SubpicMergeApp::parseVPS(HLSyntaxReader &hlsReader, ParameterSetManager &psM
   hlsReader.parseVPS(vps);
   int vpsId = vps->getVPSId();
   psManager.storeVPS(vps, hlsReader.getBitstream()->getFifo());
-  msg( INFO, "  VPS%i", vpsId);
+  msg( VTM_INFO, "  VPS%i", vpsId);
   return vpsId;
 }
 
@@ -271,7 +271,7 @@ int SubpicMergeApp::parseSPS(HLSyntaxReader &hlsReader, ParameterSetManager &psM
   hlsReader.parseSPS(sps);
   int spsId = sps->getSPSId();
   psManager.storeSPS(sps, hlsReader.getBitstream()->getFifo());
-  msg( INFO, "  SPS%i", spsId);
+  msg( VTM_INFO, "  SPS%i", spsId);
   return spsId;
 }
 
@@ -284,7 +284,7 @@ int SubpicMergeApp::parsePPS(HLSyntaxReader &hlsReader, ParameterSetManager &psM
   hlsReader.parsePPS(pps);
   int ppsId = pps->getPPSId();
   psManager.storePPS(pps, hlsReader.getBitstream()->getFifo());
-  msg( INFO, "  PPS%i", ppsId);
+  msg( VTM_INFO, "  PPS%i", ppsId);
   return ppsId;
 }
 
@@ -298,7 +298,7 @@ void SubpicMergeApp::parseAPS(HLSyntaxReader &hlsReader, ParameterSetManager &ps
   apsId = aps->getAPSId();
   apsType = (int)aps->getAPSType();
   psManager.storeAPS(aps, hlsReader.getBitstream()->getFifo());
-  msg( INFO, "  APS%i", apsId);
+  msg( VTM_INFO, "  APS%i", apsId);
 }
 
 /**
@@ -329,7 +329,7 @@ void SubpicMergeApp::parsePictureHeader(HLSyntaxReader &hlsReader, PicHeader &pi
 {
   hlsReader.parsePictureHeader(&picHeader, &psManager, true);
   picHeader.setValid();
-  msg( INFO, "  PH");
+  msg( VTM_INFO, "  PH");
 }
 
 /**
@@ -353,7 +353,7 @@ void SubpicMergeApp::parseSliceHeader(HLSyntaxReader &hlsReader, InputNALUnit &n
     sliceData.write(inBs.readByte(), 8);
   }
 
-  msg( INFO, "  VCL%i", slice.getPOC());
+  msg( VTM_INFO, "  VCL%i", slice.getPOC());
 }
 
 /**
@@ -409,11 +409,11 @@ void SubpicMergeApp::decodeNalu(Subpicture &subpic, InputNALUnit &nalu, SEI *&de
     }
     else if (nalu.isSei())
     {
-      msg( INFO, "  prefix SEI");
+      msg( VTM_INFO, "  prefix SEI");
     }
     else
     {
-      msg( INFO, "  ignored NALU");  // Any other NAL unit that is not handled above
+      msg( VTM_INFO, "  ignored NALU");  // Any other NAL unit that is not handled above
     }
     break;
   }
@@ -460,7 +460,7 @@ void SubpicMergeApp::parseSubpic(Subpicture &subpic, bool &morePictures)
     {
       subpic.nalus.pop_back();  // Remove empty nalu
       subpic.stats.pop_back();
-      msg( ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+      msg( VTM_ERROR, "Warning: Attempt to decode an empty NAL unit\n");
       continue;
     }
 
@@ -1159,7 +1159,7 @@ void SubpicMergeApp::mergeStreams(bool mixedNaluFlag)
   ParameterSetManager psManager;  // Parameter sets for merged stream
   int picNum = 0;
 
-  msg( INFO, "Output picture size is %ix%i\n", m_picWidth, m_picHeight);
+  msg( VTM_INFO, "Output picture size is %ix%i\n", m_picWidth, m_picHeight);
 
   for (auto &subpic : *m_subpics)
   {
@@ -1171,15 +1171,15 @@ void SubpicMergeApp::mergeStreams(bool mixedNaluFlag)
   bool morePictures = true;
   while (morePictures)
   {
-    msg( INFO, "Picture %i\n", picNum);
+    msg( VTM_INFO, "Picture %i\n", picNum);
     int subPicNum = 0;
 
     for (auto &subpic : *m_subpics)
     {
-      msg( INFO, " Subpicture %i\n", subPicNum);
+      msg( VTM_INFO, " Subpicture %i\n", subPicNum);
       parseSubpic(subpic, morePictures);
       subPicNum++;
-      msg( INFO, "\n");
+      msg( VTM_INFO, "\n");
     }
 
     validateSubpics();
@@ -1258,7 +1258,7 @@ void SubpicMergeApp::mergeYuvFiles(int bitdepth, int chromaFormat)
         m_outputStream.write(reinterpret_cast<char*>(destPic[cIdx]), cIdx == 0 ? numBytesPerPicY : numBytesPerPicUV);
       }
 
-      msg( INFO, "Merged YUV picture %i\n", picNum);
+      msg( VTM_INFO, "Merged YUV picture %i\n", picNum);
     }
 
     picNum++;
diff --git a/source/Lib/CommonLib/ChromaFormat.h b/source/Lib/CommonLib/ChromaFormat.h
index 141351f..caa2656 100644
--- a/source/Lib/CommonLib/ChromaFormat.h
+++ b/source/Lib/CommonLib/ChromaFormat.h
@@ -76,7 +76,7 @@ static inline uint32_t getTotalSamples(const uint32_t width, const uint32_t heig
     case CHROMA_422: return  samplesPerChannel * 2;       break;
     case CHROMA_444: return  samplesPerChannel * 3;       break;
     default:
-      EXIT( "ERROR: Unrecognised chroma format in getTotalSamples() " );
+      EXIT( "VTM_ERROR: Unrecognised chroma format in getTotalSamples() " );
       break;
   }
 
@@ -95,7 +95,7 @@ static inline uint64_t getTotalFracBits(const uint32_t width, const uint32_t hei
   case CHROMA_422: bitsPerSampleTimes2 =   2 * (bitDepths[CHANNEL_TYPE_LUMA]   +   bitDepths[CHANNEL_TYPE_CHROMA]);        break;
   case CHROMA_444: bitsPerSampleTimes2 =   2 * (bitDepths[CHANNEL_TYPE_LUMA]   + 2*bitDepths[CHANNEL_TYPE_CHROMA]);        break;
   default:
-      EXIT( "ERROR: Unrecognised chroma format in getTotalFracBits() " );
+      EXIT( "VTM_ERROR: Unrecognised chroma format in getTotalFracBits() " );
     break;
   }
   return uint64_t( width * height * bitsPerSampleTimes2 ) << ( SCALE_BITS - 1 );
diff --git a/source/Lib/CommonLib/CommonDef.h b/source/Lib/CommonLib/CommonDef.h
index dfbf098..2635b8d 100644
--- a/source/Lib/CommonLib/CommonDef.h
+++ b/source/Lib/CommonLib/CommonDef.h
@@ -503,7 +503,7 @@ template <typename T> inline T ClipPel (const T a, const ClpRng& clpRng)
 
 template <typename T> inline void Check3( T minVal, T maxVal, T a)
 {
-  CHECK( ( a > maxVal ) || ( a < minVal ), "ERROR: Range check " << minVal << " >= " << a << " <= " << maxVal << " failed" );
+  CHECK( ( a > maxVal ) || ( a < minVal ), "VTM_ERROR: Range check " << minVal << " >= " << a << " <= " << maxVal << " failed" );
 }  ///< general min/max clip
 
 extern MsgLevel g_verbosity;
@@ -515,7 +515,7 @@ inline void msg( MsgLevel level, const char* fmt, ... )
   {
     va_list args;
     va_start( args, fmt );
-    vfprintf( level == ERROR ? stderr : stdout, fmt, args );
+    vfprintf( level == VTM_ERROR ? stderr : stdout, fmt, args );
     va_end( args );
   }
 }
diff --git a/source/Lib/CommonLib/DepQuant.cpp b/source/Lib/CommonLib/DepQuant.cpp
index f3e985d..70d175a 100644
--- a/source/Lib/CommonLib/DepQuant.cpp
+++ b/source/Lib/CommonLib/DepQuant.cpp
@@ -152,10 +152,10 @@ namespace DQIntern
 
   void Rom::xInitScanArrays()
   {
-    if( m_scansInitialized )
-    {
-      return;
-    }
+//    if( m_scansInitialized )
+//    {
+//      return;
+//    }
     ::memset( m_scanId2NbInfoSbbArray, 0, sizeof(m_scanId2NbInfoSbbArray) );
     ::memset( m_scanId2NbInfoOutArray, 0, sizeof(m_scanId2NbInfoOutArray) );
     ::memset( m_tuParameters,          0, sizeof(m_tuParameters) );
diff --git a/source/Lib/CommonLib/IntraPrediction.cpp b/source/Lib/CommonLib/IntraPrediction.cpp
index 9a16707..55df275 100644
--- a/source/Lib/CommonLib/IntraPrediction.cpp
+++ b/source/Lib/CommonLib/IntraPrediction.cpp
@@ -1814,7 +1814,7 @@ void IntraPrediction::initIntraMip( const PredictionUnit &pu, const CompArea &ar
   CHECK( area.width > MIP_MAX_WIDTH || area.height > MIP_MAX_HEIGHT, "Error: block size not supported for MIP" );
 
   // prepare input (boundary) data for prediction
-  CHECK( m_ipaParam.refFilterFlag, "ERROR: unfiltered refs expected for MIP" );
+  CHECK( m_ipaParam.refFilterFlag, "VTM_ERROR: unfiltered refs expected for MIP" );
   Pel       *ptrSrc     = getPredictorPtr(area.compID);
   const int  srcStride  = m_refBufferStride[area.compID];
   const int  srcHStride = 2;
diff --git a/source/Lib/CommonLib/MCTS.cpp b/source/Lib/CommonLib/MCTS.cpp
index 1690bd4..60e137b 100644
--- a/source/Lib/CommonLib/MCTS.cpp
+++ b/source/Lib/CommonLib/MCTS.cpp
@@ -181,7 +181,7 @@ static bool checkMVRange( const Mv& mv, const Area& tileArea, int predXLeft, int
   {
     if( msgFlag )
     {
-      msg( WARNING, "%s: pu motion vector across tile boundaries MV(%d,%d) RangeLR(%d,%d) PredLR(%d,%d)\n", (isLuma ? "LUMA": "CHROMA"), mv.getHor(), mv.getVer(), rangeXLeft, rangeXRight, predXLeft, predXRight );
+      msg( VTM_WARNING, "%s: pu motion vector across tile boundaries MV(%d,%d) RangeLR(%d,%d) PredLR(%d,%d)\n", (isLuma ? "LUMA": "CHROMA"), mv.getHor(), mv.getVer(), rangeXLeft, rangeXRight, predXLeft, predXRight );
     }
     return false;
   }
@@ -189,7 +189,7 @@ static bool checkMVRange( const Mv& mv, const Area& tileArea, int predXLeft, int
   {
     if( msgFlag )
     {
-      msg( WARNING, "%s: pu motion vector across tile boundaries MV(%d,%d) RangeTB(%d,%d) PredTB(%d,%d)\n", (isLuma ? "LUMA" : "CHROMA"), mv.getHor(), mv.getVer(), rangeYTop, rangeYBottom, predYTop, predYBottom );
+      msg( VTM_WARNING, "%s: pu motion vector across tile boundaries MV(%d,%d) RangeTB(%d,%d) PredTB(%d,%d)\n", (isLuma ? "LUMA" : "CHROMA"), mv.getHor(), mv.getVer(), rangeYTop, rangeYBottom, predYTop, predYBottom );
     }
     return false;
   }
diff --git a/source/Lib/CommonLib/ParameterSetManager.cpp b/source/Lib/CommonLib/ParameterSetManager.cpp
index 49975ba..7531194 100644
--- a/source/Lib/CommonLib/ParameterSetManager.cpp
+++ b/source/Lib/CommonLib/ParameterSetManager.cpp
@@ -92,7 +92,7 @@ bool ParameterSetManager::activatePPS(int ppsId, bool isIRAP)
         }
         else
         {
-          msg( WARNING, "Warning: tried to activate a PPS that refers to a non-existing VPS." );
+          msg( VTM_WARNING, "Warning: tried to activate a PPS that refers to a non-existing VPS." );
         }
 
         m_spsMap.clearActive();
@@ -104,13 +104,13 @@ bool ParameterSetManager::activatePPS(int ppsId, bool isIRAP)
       }
       else
       {
-        msg( WARNING, "Warning: tried to activate a PPS that refers to a non-existing SPS.");
+        msg( VTM_WARNING, "Warning: tried to activate a PPS that refers to a non-existing SPS.");
       }
     }
   }
   else
   {
-    msg( WARNING, "Warning: tried to activate a non-existing PPS.");
+    msg( VTM_WARNING, "Warning: tried to activate a non-existing PPS.");
   }
 
   // Failed to activate if reach here.
@@ -128,7 +128,7 @@ bool ParameterSetManager::activateAPS(int apsId, int apsType)
   }
   else
   {
-    msg(WARNING, "Warning: tried to activate a non-existing APS.");
+    msg(VTM_WARNING, "Warning: tried to activate a non-existing APS.");
   }
   return false;
 }
diff --git a/source/Lib/CommonLib/PicYuvMD5.cpp b/source/Lib/CommonLib/PicYuvMD5.cpp
index a15f81a..2be1337 100644
--- a/source/Lib/CommonLib/PicYuvMD5.cpp
+++ b/source/Lib/CommonLib/PicYuvMD5.cpp
@@ -291,7 +291,7 @@ int calcAndPrintHashStatus(const CPelUnitBuf& pic, const SEIDecodedPictureHash*
     ok = "(OK)";
     if (recon_digest != pictureHashSEI->m_pictureHash)
     {
-      ok = "(***ERROR***)";
+      ok = "(***VTM_ERROR***)";
       mismatch = true;
     }
   }
diff --git a/source/Lib/CommonLib/Picture.cpp b/source/Lib/CommonLib/Picture.cpp
index 892477e..94c7849 100644
--- a/source/Lib/CommonLib/Picture.cpp
+++ b/source/Lib/CommonLib/Picture.cpp
@@ -73,6 +73,10 @@ Picture::Picture()
   layerId = NOT_VALID;
   numSlices = 1;
   unscaledPic = nullptr;
+#if PCC_ME_EXT
+  m_blockToPatch        = nullptr;
+  m_occupancyMap        = nullptr;
+#endif
 }
 
 void Picture::create( const ChromaFormat &_chromaFormat, const Size &size, const unsigned _maxCUSize, const unsigned _margin, const bool _decoder, const int _layerId, const bool gopBasedTemporalFilterEnabled )
@@ -97,6 +101,12 @@ void Picture::create( const ChromaFormat &_chromaFormat, const Size &size, const
   m_ctuArea = UnitArea( _chromaFormat, Area( Position{ 0, 0 }, Size( _maxCUSize, _maxCUSize ) ) );
 #endif
   m_hashMap.clearAll();
+#if PATCH_BASED_MVP || PCC_ME_EXT
+  {
+	  m_blockToPatch = new int64_t[size.width / 16 * size.height / 16];
+	  m_occupancyMap = new int[size.width * size.height];
+  }
+#endif
 }
 
 void Picture::destroy()
@@ -130,6 +140,13 @@ void Picture::destroy()
     delete[] m_spliceIdx;
     m_spliceIdx = NULL;
   }
+#if PATCH_BASED_MVP || PCC_ME_EXT
+  delete m_blockToPatch;
+  m_blockToPatch = nullptr;
+
+  delete m_occupancyMap;
+  m_occupancyMap = nullptr;
+#endif
 }
 
 void Picture::createTempBuffers( const unsigned _maxCUSize )
diff --git a/source/Lib/CommonLib/Picture.h b/source/Lib/CommonLib/Picture.h
index 2f98582..2a0c44d 100644
--- a/source/Lib/CommonLib/Picture.h
+++ b/source/Lib/CommonLib/Picture.h
@@ -147,12 +147,20 @@ struct Picture : public UnitArea
                                 const PelUnitBuf& afterScaling, const Window& scalingWindowAfter,
                                 const ChromaFormat chromaFormatIDC, const BitDepths& bitDepths, const bool useLumaFilter, const bool downsampling,
                                 const bool horCollocatedChromaFlag, const bool verCollocatedChromaFlag );
+#if PATCH_BASED_MVP || PCC_ME_EXT
+  int64_t*      getBlockToPatch() const { return m_blockToPatch; }
+  int*          getOccupancyMap() const { return m_occupancyMap; }
+#endif
 
 private:
   Window        m_conformanceWindow;
   Window        m_scalingWindow;
   int           m_decodingOrderNumber;
   NalUnitType   m_pictureType;
+#if PATCH_BASED_MVP || PCC_ME_EXT
+  int64_t*              m_blockToPatch;
+  int*                  m_occupancyMap;
+#endif
 
 public:
   bool m_isSubPicBorderSaved;
diff --git a/source/Lib/CommonLib/RdCost.cpp b/source/Lib/CommonLib/RdCost.cpp
index 4c8c565..1c5fc8e 100644
--- a/source/Lib/CommonLib/RdCost.cpp
+++ b/source/Lib/CommonLib/RdCost.cpp
@@ -3029,7 +3029,7 @@ void RdCost::updateReshapeLumaLevelToWeightTable(SliceReshapeInfo &sliceReshape,
     }
     else
     {
-      THROW("updateReshapeLumaLevelToWeightTable ERROR!!");
+      THROW("updateReshapeLumaLevelToWeightTable VTM_ERROR!!");
     }
   }
   else
diff --git a/source/Lib/CommonLib/RdCost.h b/source/Lib/CommonLib/RdCost.h
index 5737cdd..998b5fe 100644
--- a/source/Lib/CommonLib/RdCost.h
+++ b/source/Lib/CommonLib/RdCost.h
@@ -152,6 +152,9 @@ public:
 #endif
 
   void          setDistortionWeight   ( const ComponentID compID, const double distortionWeight ) { m_distortionWeight[compID] = distortionWeight; }
+#if PCC_ME_EXT
+  double  getDistortionWeight(const ComponentID compID) { return m_distortionWeight[compID]; }
+#endif
   void          setLambda             ( double dLambda, const BitDepths &bitDepths );
 
 #if WCG_EXT
diff --git a/source/Lib/CommonLib/Rom.cpp b/source/Lib/CommonLib/Rom.cpp
index 9c11a8a..45bc4f6 100644
--- a/source/Lib/CommonLib/Rom.cpp
+++ b/source/Lib/CommonLib/Rom.cpp
@@ -56,7 +56,7 @@ bool g_mctsDecCheckEnabled = false;
 //! \ingroup CommonLib
 //! \{
 
-MsgLevel g_verbosity = VERBOSE;
+MsgLevel g_verbosity = VTM_VERBOSE;
 
 const char* nalUnitTypeToString(NalUnitType type)
 {
@@ -191,7 +191,7 @@ public:
 
       default:
 
-        THROW("ERROR: Unknown scan type \"" << m_scanType << "\"in ScanGenerator::GetNextIndex");
+        THROW("VTM_ERROR: Unknown scan type \"" << m_scanType << "\"in ScanGenerator::GetNextIndex");
         break;
     }
 
@@ -780,4 +780,13 @@ int16_t   g_weightOffset       [GEO_NUM_PARTITION_MODE][GEO_NUM_CU_SIZE][GEO_NUM
 int8_t    g_angle2mask[GEO_NUM_ANGLES] = { 0, -1, 1, 2, 3, 4, -1, -1, 5, -1, -1, 4, 3, 2, 1, -1, 0, -1, 1, 2, 3, 4, -1, -1, 5, -1, -1, 4, 3, 2, 1, -1 };
 int8_t    g_Dis[GEO_NUM_ANGLES] = { 8, 8, 8, 8, 4, 4, 2, 1, 0, -1, -2, -4, -4, -8, -8, -8, -8, -8, -8, -8, -4, -4, -2, -1, 0, 1, 2, 4, 4, 8, 8, 8 };
 int8_t    g_angle2mirror[GEO_NUM_ANGLES] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2 };
+
+#if PCC_ME_EXT
+int64_t g_vtmnumPatches[PCC_ME_EXT_MAX_NUM_FRAMES];
+int64_t g_vtmprojectionIndex[PCC_ME_EXT_MAX_NUM_FRAMES][PCC_ME_EXT_MAX_NUM_PATCHES];
+int64_t g_vtmpatch2DInfo[PCC_ME_EXT_MAX_NUM_FRAMES][PCC_ME_EXT_MAX_NUM_PATCHES][4];  // u0, v0, sizeU0, sizeV0
+int64_t g_vtmpatch3DInfo[PCC_ME_EXT_MAX_NUM_FRAMES][PCC_ME_EXT_MAX_NUM_PATCHES][3];  // d1, u1, v1
+
+bool g_vtmpatchesChange[PCC_ME_EXT_MAX_NUM_PATCHES];
+#endif
 //! \}
diff --git a/source/Lib/CommonLib/Rom.h b/source/Lib/CommonLib/Rom.h
index 6611edd..bd1430f 100644
--- a/source/Lib/CommonLib/Rom.h
+++ b/source/Lib/CommonLib/Rom.h
@@ -232,5 +232,13 @@ extern int16_t   g_weightOffset       [GEO_NUM_PARTITION_MODE][GEO_NUM_CU_SIZE][
 extern int8_t    g_angle2mask         [GEO_NUM_ANGLES];
 extern int8_t    g_Dis[GEO_NUM_ANGLES];
 extern int8_t    g_angle2mirror[GEO_NUM_ANGLES];
+
+#if PATCH_BASED_MVP || PCC_ME_EXT
+extern int64_t g_vtmnumPatches[PCC_ME_EXT_MAX_NUM_FRAMES];
+extern int64_t g_vtmprojectionIndex[PCC_ME_EXT_MAX_NUM_FRAMES][PCC_ME_EXT_MAX_NUM_PATCHES];
+extern int64_t g_vtmpatch2DInfo[PCC_ME_EXT_MAX_NUM_FRAMES][PCC_ME_EXT_MAX_NUM_PATCHES][4];  // u0, v0, sizeU0, sizeV0
+extern int64_t g_vtmpatch3DInfo[PCC_ME_EXT_MAX_NUM_FRAMES][PCC_ME_EXT_MAX_NUM_PATCHES][3];  // d1, u1, v1
+extern bool g_vtmpatchesChange[PCC_ME_EXT_MAX_NUM_PATCHES];
+#endif
 #endif  //__TCOMROM__
 
diff --git a/source/Lib/CommonLib/Slice.cpp b/source/Lib/CommonLib/Slice.cpp
index 5e7da25..8fada11 100644
--- a/source/Lib/CommonLib/Slice.cpp
+++ b/source/Lib/CommonLib/Slice.cpp
@@ -1858,7 +1858,7 @@ int Slice::checkThatAllRefPicsAreAvailable(PicList& rcListPic, const ReferencePi
     {
       if (printErrors)
       {
-        msg(ERROR, "Error: Current picture: %d Long-term reference picture with POC = %3d seems to have been removed or not correctly decoded.\n", this->getPOC(), notPresentPoc);
+        msg(VTM_ERROR, "Error: Current picture: %d Long-term reference picture with POC = %3d seems to have been removed or not correctly decoded.\n", this->getPOC(), notPresentPoc);
       }
       return notPresentPoc;
     }
@@ -1891,7 +1891,7 @@ int Slice::checkThatAllRefPicsAreAvailable(PicList& rcListPic, const ReferencePi
     {
       if (printErrors)
       {
-        msg(ERROR, "Error: Current picture: %d Short-term reference picture with POC = %3d seems to have been removed or not correctly decoded.\n", this->getPOC(), notPresentPoc);
+        msg(VTM_ERROR, "Error: Current picture: %d Short-term reference picture with POC = %3d seems to have been removed or not correctly decoded.\n", this->getPOC(), notPresentPoc);
       }
       return notPresentPoc;
     }
@@ -1970,7 +1970,7 @@ int Slice::checkThatAllRefPicsAreAvailable(PicList& rcListPic, const ReferencePi
     {
       if (printErrors)
       {
-        msg(ERROR, "Error: Current picture: %d Long-term reference picture with POC = %3d seems to have been removed or not correctly decoded.\n", this->getPOC(), notPresentPoc);
+        msg(VTM_ERROR, "Error: Current picture: %d Long-term reference picture with POC = %3d seems to have been removed or not correctly decoded.\n", this->getPOC(), notPresentPoc);
       }
       *refPicIndex = ii;
       return notPresentPoc;
@@ -2004,7 +2004,7 @@ int Slice::checkThatAllRefPicsAreAvailable(PicList& rcListPic, const ReferencePi
     {
       if (printErrors)
       {
-        msg(ERROR, "Error: Current picture: %d Short-term reference picture with POC = %3d seems to have been removed or not correctly decoded.\n", this->getPOC(), notPresentPoc);
+        msg(VTM_ERROR, "Error: Current picture: %d Short-term reference picture with POC = %3d seems to have been removed or not correctly decoded.\n", this->getPOC(), notPresentPoc);
       }
       *refPicIndex = ii;
       return notPresentPoc;
@@ -2067,17 +2067,17 @@ void Slice::checkConformanceForDRAP( uint32_t temporalId )
     if (!(getNalUnitType() == NalUnitType::NAL_UNIT_CODED_SLICE_TRAIL ||
           getNalUnitType() == NalUnitType::NAL_UNIT_CODED_SLICE_STSA))
     {
-      msg( WARNING, "Warning, non-conforming bitstream. The DRAP picture should be a trailing picture.\n");
+      msg( VTM_WARNING, "Warning, non-conforming bitstream. The DRAP picture should be a trailing picture.\n");
     }
     if ( temporalId != 0)
     {
-      msg( WARNING, "Warning, non-conforming bitstream. The DRAP picture shall have a temporal sublayer identifier equal to 0.\n");
+      msg( VTM_WARNING, "Warning, non-conforming bitstream. The DRAP picture shall have a temporal sublayer identifier equal to 0.\n");
     }
     for (int i = 0; i < getNumRefIdx(REF_PIC_LIST_0); i++)
     {
       if (getRefPic(REF_PIC_LIST_0,i)->getPOC() != getAssociatedIRAPPOC())
       {
-        msg( WARNING, "Warning, non-conforming bitstream. The DRAP picture shall not include any pictures in the active "
+        msg( VTM_WARNING, "Warning, non-conforming bitstream. The DRAP picture shall not include any pictures in the active "
                       "entries of its reference picture lists except the preceding IRAP picture in decoding order.\n");
       }
     }
@@ -2085,7 +2085,7 @@ void Slice::checkConformanceForDRAP( uint32_t temporalId )
     {
       if (getRefPic(REF_PIC_LIST_1,i)->getPOC() != getAssociatedIRAPPOC())
       {
-        msg( WARNING, "Warning, non-conforming bitstream. The DRAP picture shall not include any pictures in the active "
+        msg( VTM_WARNING, "Warning, non-conforming bitstream. The DRAP picture shall not include any pictures in the active "
                       "entries of its reference picture lists except the preceding IRAP picture in decoding order.\n");
       }
     }
@@ -2097,7 +2097,7 @@ void Slice::checkConformanceForDRAP( uint32_t temporalId )
     {
       if (getRefPic(REF_PIC_LIST_0,i)->getPOC() < getLatestDRAPPOC() && getRefPic(REF_PIC_LIST_0,i)->getPOC() != getAssociatedIRAPPOC())
       {
-        msg( WARNING, "Warning, non-conforming bitstream. Any picture that follows the DRAP picture in both decoding order "
+        msg( VTM_WARNING, "Warning, non-conforming bitstream. Any picture that follows the DRAP picture in both decoding order "
                     "and output order shall not include, in the active entries of its reference picture lists, any picture "
                     "that precedes the DRAP picture in decoding order or output order, with the exception of the preceding "
                     "IRAP picture in decoding order. Problem is POC %d in RPL0.\n", getRefPic(REF_PIC_LIST_0,i)->getPOC());
@@ -2107,7 +2107,7 @@ void Slice::checkConformanceForDRAP( uint32_t temporalId )
     {
       if (getRefPic(REF_PIC_LIST_1,i)->getPOC() < getLatestDRAPPOC() && getRefPic(REF_PIC_LIST_1,i)->getPOC() != getAssociatedIRAPPOC())
       {
-        msg( WARNING, "Warning, non-conforming bitstream. Any picture that follows the DRAP picture in both decoding order "
+        msg( VTM_WARNING, "Warning, non-conforming bitstream. Any picture that follows the DRAP picture in both decoding order "
                     "and output order shall not include, in the active entries of its reference picture lists, any picture "
                     "that precedes the DRAP picture in decoding order or output order, with the exception of the preceding "
                     "IRAP picture in decoding order. Problem is POC %d in RPL1", getRefPic(REF_PIC_LIST_1,i)->getPOC());
@@ -4069,7 +4069,7 @@ bool ScalingList::xParseScalingList(const std::string &fileName)
 
   if (fileName.empty())
   {
-    msg( ERROR, "Error: no scaling list file specified. Help on scaling lists being output\n");
+    msg( VTM_ERROR, "Error: no scaling list file specified. Help on scaling lists being output\n");
     outputScalingListHelp(std::cout);
     std::cout << "\n\nExample scaling list file using default values:\n\n";
     outputScalingLists(std::cout);
@@ -4077,7 +4077,7 @@ bool ScalingList::xParseScalingList(const std::string &fileName)
   }
   else if ((fp = fopen(fileName.c_str(),"r")) == (FILE*)NULL)
   {
-    msg( ERROR, "Error: cannot open scaling list file %s for reading\n", fileName.c_str());
+    msg( VTM_ERROR, "Error: cannot open scaling list file %s for reading\n", fileName.c_str());
     return true;
   }
 
@@ -4111,7 +4111,7 @@ bool ScalingList::xParseScalingList(const std::string &fileName)
           }
           if (!bFound)
           {
-            msg( ERROR, "Error: cannot find Matrix %s from scaling list file %s\n", MatrixType[sizeIdc][listIdc], fileName.c_str());
+            msg( VTM_ERROR, "Error: cannot find Matrix %s from scaling list file %s\n", MatrixType[sizeIdc][listIdc], fileName.c_str());
             return true;
 
           }
@@ -4121,12 +4121,12 @@ bool ScalingList::xParseScalingList(const std::string &fileName)
           int data;
           if (fscanf(fp, "%d,", &data)!=1)
           {
-            msg( ERROR, "Error: cannot read value #%d for Matrix %s from scaling list file %s at file position %ld\n", i, MatrixType[sizeIdc][listIdc], fileName.c_str(), ftell(fp));
+            msg( VTM_ERROR, "Error: cannot read value #%d for Matrix %s from scaling list file %s at file position %ld\n", i, MatrixType[sizeIdc][listIdc], fileName.c_str(), ftell(fp));
             return true;
           }
           if (data<0 || data>255)
           {
-            msg( ERROR, "Error: QMatrix entry #%d of value %d for Matrix %s from scaling list file %s at file position %ld is out of range (0 to 255)\n", i, data, MatrixType[sizeIdc][listIdc], fileName.c_str(), ftell(fp));
+            msg( VTM_ERROR, "Error: QMatrix entry #%d of value %d for Matrix %s from scaling list file %s at file position %ld is out of range (0 to 255)\n", i, data, MatrixType[sizeIdc][listIdc], fileName.c_str(), ftell(fp));
             return true;
           }
           src[i] = data;
@@ -4152,19 +4152,19 @@ bool ScalingList::xParseScalingList(const std::string &fileName)
             }
             if (!bFound)
             {
-              msg( ERROR, "Error: cannot find DC Matrix %s from scaling list file %s\n", MatrixType_DC[sizeIdc][listIdc], fileName.c_str());
+              msg( VTM_ERROR, "Error: cannot find DC Matrix %s from scaling list file %s\n", MatrixType_DC[sizeIdc][listIdc], fileName.c_str());
               return true;
             }
           }
           int data;
           if (fscanf(fp, "%d,", &data)!=1)
           {
-            msg( ERROR, "Error: cannot read DC %s from scaling list file %s at file position %ld\n", MatrixType_DC[sizeIdc][listIdc], fileName.c_str(), ftell(fp));
+            msg( VTM_ERROR, "Error: cannot read DC %s from scaling list file %s at file position %ld\n", MatrixType_DC[sizeIdc][listIdc], fileName.c_str(), ftell(fp));
             return true;
           }
           if (data<0 || data>255)
           {
-            msg( ERROR, "Error: DC value %d for Matrix %s from scaling list file %s at file position %ld is out of range (0 to 255)\n", data, MatrixType[sizeIdc][listIdc], fileName.c_str(), ftell(fp));
+            msg( VTM_ERROR, "Error: DC value %d for Matrix %s from scaling list file %s at file position %ld is out of range (0 to 255)\n", data, MatrixType[sizeIdc][listIdc], fileName.c_str(), ftell(fp));
             return true;
           }
           //overwrite DC value when size of matrix is larger than 16x16
diff --git a/source/Lib/CommonLib/TypeDef.h b/source/Lib/CommonLib/TypeDef.h
index 7154f52..b0539a7 100644
--- a/source/Lib/CommonLib/TypeDef.h
+++ b/source/Lib/CommonLib/TypeDef.h
@@ -54,6 +54,13 @@
 #define JVET_V0131_CORRECT_TR_HBD                          1 // correcting the 4x4 BDST7/DCT8 transform matrices for high bit-depth coding
 // clang-format off
 
+#define PCC_ME_EXT                                        1
+
+#if PCC_ME_EXT
+#define PCC_ME_EXT_MAX_NUM_FRAMES                         600
+#define PCC_ME_EXT_MAX_NUM_PATCHES                        1000
+#define PCC_ME_NUM_LAYERS_ACTIVE                          2
+#endif
 #define JVET_V0078                                        1 // JVET-V0078: QP control for very smooth blocks
 
 //########### place macros to be removed in next cycle below this line ###############
@@ -257,7 +264,7 @@ typedef std::pair<int, int>  TrCost;
 // ====================================================================================================================
 
 #if ((RExt__HIGH_PRECISION_FORWARD_TRANSFORM != 0) && (RExt__HIGH_BIT_DEPTH_SUPPORT == 0))
-#error ERROR: cannot enable RExt__HIGH_PRECISION_FORWARD_TRANSFORM without RExt__HIGH_BIT_DEPTH_SUPPORT
+#error VTM_ERROR: cannot enable RExt__HIGH_PRECISION_FORWARD_TRANSFORM without RExt__HIGH_BIT_DEPTH_SUPPORT
 #endif
 
 // ====================================================================================================================
@@ -1042,13 +1049,13 @@ public:
 
 enum MsgLevel
 {
-  SILENT  = 0,
-  ERROR   = 1,
-  WARNING = 2,
-  INFO    = 3,
-  NOTICE  = 4,
-  VERBOSE = 5,
-  DETAILS = 6
+  VTM_SILENT  = 0,
+  VTM_ERROR   = 1,
+  VTM_WARNING = 2,
+  VTM_INFO    = 3,
+  VTM_NOTICE  = 4,
+  VTM_VERBOSE = 5,
+  VTM_DETAILS = 6
 };
 enum RESHAPE_SIGNAL_TYPE
 {
diff --git a/source/Lib/CommonLib/dtrace.cpp b/source/Lib/CommonLib/dtrace.cpp
index c9b983c..46b70a6 100644
--- a/source/Lib/CommonLib/dtrace.cpp
+++ b/source/Lib/CommonLib/dtrace.cpp
@@ -323,7 +323,7 @@ std::string CDTrace::getErrMessage()
     }
     else
     {
-      str = " - DTrace ERROR: Undefined error";
+      str = " - DTrace VTM_ERROR: Undefined error";
     }
   }
 
diff --git a/source/Lib/CommonLib/dtrace_next.h b/source/Lib/CommonLib/dtrace_next.h
index 8281ae7..193b551 100644
--- a/source/Lib/CommonLib/dtrace_next.h
+++ b/source/Lib/CommonLib/dtrace_next.h
@@ -253,14 +253,14 @@ inline CDTrace* tracing_init( std::string& sTracingFile, std::string& sTracingRu
 
   if( !sTracingFile.empty() || !sTracingRule.empty() )
   {
-    msg( VERBOSE, "\n" );
-    msg( VERBOSE, "Tracing is enabled: %s : %s\n", sTracingFile.c_str(), sTracingRule.c_str() );
+    msg( VTM_VERBOSE, "\n" );
+    msg( VTM_VERBOSE, "Tracing is enabled: %s : %s\n", sTracingFile.c_str(), sTracingRule.c_str() );
   }
 
   CDTrace *pDtrace = new CDTrace( sTracingFile, sTracingRule, channels );
   if( pDtrace->getLastError() )
   {
-    msg( WARNING, "%s\n", pDtrace->getErrMessage().c_str() );
+    msg( VTM_WARNING, "%s\n", pDtrace->getErrMessage().c_str() );
     //return NULL;
   }
 
diff --git a/source/Lib/DecoderLib/DecLib.cpp b/source/Lib/DecoderLib/DecLib.cpp
index b3b4205..a7742ce 100644
--- a/source/Lib/DecoderLib/DecLib.cpp
+++ b/source/Lib/DecoderLib/DecLib.cpp
@@ -99,7 +99,7 @@ bool tryDecodePicture( Picture* pcEncPic, const int expectedPoc, const std::stri
       pcDecLib->setAPSMapEnc( apsMap );
 
       bFirstCall = false;
-      msg( INFO, "start to decode %s \n", bitstreamFileName.c_str() );
+      msg( VTM_INFO, "start to decode %s \n", bitstreamFileName.c_str() );
     }
 
     bool goOn = true;
@@ -128,7 +128,7 @@ bool tryDecodePicture( Picture* pcEncPic, const int expectedPoc, const std::stri
          *  - two back-to-back start_code_prefixes
          *  - start_code_prefix immediately followed by EOF
          */
-        msg( ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+        msg( VTM_ERROR, "Warning: Attempt to decode an empty NAL unit\n");
       }
       else
       {
@@ -251,7 +251,7 @@ bool tryDecodePicture( Picture* pcEncPic, const int expectedPoc, const std::stri
             pcDecLib->executeLoopFilters();
           }
 
-          pcDecLib->finishPicture( poc, pcListPic, DETAILS );
+          pcDecLib->finishPicture( poc, pcListPic, VTM_DETAILS );
 
           // write output
           if( ! pcListPic->empty())
@@ -471,10 +471,10 @@ DecLib::DecLib()
   for (int i = 0; i < MAX_VPS_LAYERS; i++)
   {
     m_associatedIRAPType[i] = NAL_UNIT_INVALID;
-    std::fill_n(m_prevGDRSubpicPOC[i], MAX_NUM_SUB_PICS, -MAX_INT);
-    std::fill_n(m_prevIRAPSubpicPOC[i], MAX_NUM_SUB_PICS, -MAX_INT);
-    memset(m_prevIRAPSubpicDecOrderNo[i], 0, sizeof(int)*MAX_NUM_SUB_PICS);
-    std::fill_n(m_prevIRAPSubpicType[i], MAX_NUM_SUB_PICS, NAL_UNIT_INVALID);
+//    std::fill_n(m_prevGDRSubpicPOC[i], MAX_NUM_SUB_PICS, -MAX_INT);
+//    std::fill_n(m_prevIRAPSubpicPOC[i], MAX_NUM_SUB_PICS, -MAX_INT);
+//    memset(m_prevIRAPSubpicDecOrderNo[i], 0, sizeof(int)*MAX_NUM_SUB_PICS);
+//    std::fill_n(m_prevIRAPSubpicType[i], MAX_NUM_SUB_PICS, NAL_UNIT_INVALID);
   }
 }
 
@@ -796,7 +796,7 @@ void DecLib::finishPicture(int &poc, PicList *&rpcListPic, MsgLevel msgl, bool a
     const SEIDecodedPictureHash *hash = ( pictureHashes.size() > 0 ) ? (SEIDecodedPictureHash*) *(pictureHashes.begin()) : NULL;
     if (pictureHashes.size() > 1)
     {
-      msg( WARNING, "Warning: Got multiple decoded picture hash SEI messages. Using first.");
+      msg( VTM_WARNING, "Warning: Got multiple decoded picture hash SEI messages. Using first.");
     }
     m_numberOfChecksumErrorsDetected += calcAndPrintHashStatus(((const Picture*) m_pcPic)->getRecoBuf(), hash, pcSlice->getSPS()->getBitDepths(), msgl);
 
@@ -936,7 +936,7 @@ void DecLib::xUpdateRasInit(Slice* slice)
 
 void DecLib::xCreateLostPicture( int iLostPoc, const int layerId )
 {
-  msg( INFO, "\ninserting lost poc : %d\n",iLostPoc);
+  msg( VTM_INFO, "\ninserting lost poc : %d\n",iLostPoc);
   Picture *cFillPic = xGetNewPicBuffer( *( m_parameterSetManager.getFirstSPS() ), *( m_parameterSetManager.getFirstPPS() ), 0, layerId );
 
   CHECK( !cFillPic->slices.size(), "No slices in picture" );
@@ -959,7 +959,7 @@ void DecLib::xCreateLostPicture( int iLostPoc, const int layerId )
     Picture *rpcPic = *(iterPic++);
     if(abs(rpcPic->getPOC() -iLostPoc)==closestPoc&&rpcPic->getPOC()!=m_apcSlicePilot->getPOC())
     {
-      msg( INFO, "copying picture %d to %d (%d)\n",rpcPic->getPOC() ,iLostPoc,m_apcSlicePilot->getPOC());
+      msg( VTM_INFO, "copying picture %d to %d (%d)\n",rpcPic->getPOC() ,iLostPoc,m_apcSlicePilot->getPOC());
       cFillPic->getRecoBuf().copyFrom( rpcPic->getRecoBuf() );
       break;
     }
@@ -980,7 +980,7 @@ void DecLib::xCreateLostPicture( int iLostPoc, const int layerId )
 
 void  DecLib::xCreateUnavailablePicture( const PPS *pps, const int iUnavailablePoc, const bool longTermFlag, const int temporalId, const int layerId, const bool interLayerRefPicFlag )
 {
-  msg(INFO, "Note: Inserting unavailable POC : %d\n", iUnavailablePoc);
+  msg(VTM_INFO, "Note: Inserting unavailable POC : %d\n", iUnavailablePoc);
   Picture* cFillPic = xGetNewPicBuffer( *( m_parameterSetManager.getFirstSPS() ), *( m_parameterSetManager.getFirstPPS() ), 0, layerId );
 
   cFillPic->cs = new CodingStructure( g_globalUnitCache.cuCache, g_globalUnitCache.puCache, g_globalUnitCache.tuCache );
@@ -1053,7 +1053,7 @@ void DecLib::checkLayerIdIncludedInCvss()
       bool layerIdFind;
       if ( m_firstAccessUnitPicInfo.size() == 0 )
       {
-        msg( NOTICE, "Note: checkIncludedInFirstAu(), m_firstAccessUnitPicInfo.size() is 0.\n");
+        msg( VTM_NOTICE, "Note: checkIncludedInFirstAu(), m_firstAccessUnitPicInfo.size() is 0.\n");
         continue;
       }
       for (auto picFirst = m_firstAccessUnitPicInfo.begin(); picFirst != m_firstAccessUnitPicInfo.end(); picFirst++)
@@ -2058,7 +2058,7 @@ void DecLib::xCheckParameterSetConstraints(const int layerId)
   else
   {
     CHECK(sps->getProfileTierLevel()->getProfileIdc() != Profile::NONE, "Unknown profile");
-    msg(WARNING, "Warning: Profile set to none or unknown value\n");
+    msg(VTM_WARNING, "Warning: Profile set to none or unknown value\n");
   }
   const LevelTierFeatures *levelTierFeatures = ptlFeatures.getLevelTierFeatures();
   if (levelTierFeatures != nullptr)
@@ -2071,7 +2071,7 @@ void DecLib::xCheckParameterSetConstraints(const int layerId)
   {
     CHECK(sps->getProfileTierLevel()->getLevelIdc() == Level::LEVEL15_5, "Cannot use level 15.5 with given profile");
     CHECK(sps->getProfileTierLevel()->getLevelIdc() != Level::NONE, "Unknown level");
-    msg(WARNING, "Warning: Level set to none, invalid or unknown value\n");
+    msg(VTM_WARNING, "Warning: Level set to none, invalid or unknown value\n");
   }
 }
 
@@ -2081,7 +2081,7 @@ void DecLib::xParsePrefixSEIsForUnknownVCLNal()
   while (!m_prefixSEINALUs.empty())
   {
     // do nothing?
-    msg( NOTICE, "Discarding Prefix SEI associated with unknown VCL NAL unit.\n");
+    msg( VTM_NOTICE, "Discarding Prefix SEI associated with unknown VCL NAL unit.\n");
     delete m_prefixSEINALUs.front();
   }
   // TODO: discard following suffix SEIs as well?
@@ -2118,7 +2118,7 @@ void DecLib::xCheckPrefixSEIMessages( SEIMessages& prefixSEIs )
     SEIFrameFieldInfo *ff = (SEIFrameFieldInfo*) frameFieldSEIs.front();
     if( pt->m_ptDisplayElementalPeriodsMinus1 != ff->m_displayElementalPeriodsMinus1 )
     {
-      msg( WARNING, "Warning: ffi_display_elemental_periods_minus1 is different in picture timing and frame field information SEI messages!");
+      msg( VTM_WARNING, "Warning: ffi_display_elemental_periods_minus1 is different in picture timing and frame field information SEI messages!");
     }
   }
 }
@@ -2418,7 +2418,7 @@ bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDispl
   //we should only get a different poc for a new picture (with CTU address==0)
   if (m_apcSlicePilot->getPOC() != m_prevPOC && !m_firstSliceInSequence[nalu.m_nuhLayerId] && (m_apcSlicePilot->getFirstCtuRsAddrInSlice() != 0))
   {
-    msg( WARNING, "Warning, the first slice of a picture might have been lost!\n");
+    msg( VTM_WARNING, "Warning, the first slice of a picture might have been lost!\n");
   }
   m_prevLayerID = nalu.m_nuhLayerId;
 
@@ -2582,10 +2582,10 @@ bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDispl
   pcSlice->getPic()->sliceSubpicIdx.push_back(pps->getSubPicIdxFromSubPicId(pcSlice->getSliceSubPicId()));
   pcSlice->checkCRA(pcSlice->getRPL0(), pcSlice->getRPL1(), m_pocCRA[nalu.m_nuhLayerId], m_cListPic);
   pcSlice->constructRefPicList(m_cListPic);
-  pcSlice->setPrevGDRSubpicPOC(m_prevGDRSubpicPOC[nalu.m_nuhLayerId][currSubPicIdx]);
-  pcSlice->setPrevIRAPSubpicPOC(m_prevIRAPSubpicPOC[nalu.m_nuhLayerId][currSubPicIdx]);
-  pcSlice->setPrevIRAPSubpicType(m_prevIRAPSubpicType[nalu.m_nuhLayerId][currSubPicIdx]);
-  pcSlice->checkSubpicTypeConstraints(m_cListPic, pcSlice->getRPL0(), pcSlice->getRPL1(), m_prevIRAPSubpicDecOrderNo[nalu.m_nuhLayerId][currSubPicIdx]);
+//  pcSlice->setPrevGDRSubpicPOC(m_prevGDRSubpicPOC[nalu.m_nuhLayerId][currSubPicIdx]);
+//  pcSlice->setPrevIRAPSubpicPOC(m_prevIRAPSubpicPOC[nalu.m_nuhLayerId][currSubPicIdx]);
+//  pcSlice->setPrevIRAPSubpicType(m_prevIRAPSubpicType[nalu.m_nuhLayerId][currSubPicIdx]);
+//  pcSlice->checkSubpicTypeConstraints(m_cListPic, pcSlice->getRPL0(), pcSlice->getRPL1(), m_prevIRAPSubpicDecOrderNo[nalu.m_nuhLayerId][currSubPicIdx]);
   pcSlice->checkRPL(pcSlice->getRPL0(), pcSlice->getRPL1(), m_associatedIRAPDecodingOrderNumber[nalu.m_nuhLayerId], m_cListPic);
   pcSlice->checkSTSA(m_cListPic);
   if (m_pcPic->cs->vps && !m_pcPic->cs->vps->getIndependentLayerFlag(m_pcPic->cs->vps->getGeneralLayerIdx(nalu.m_nuhLayerId)) && m_pcPic->cs->pps->getNumSubPics() > 1)
@@ -2718,7 +2718,7 @@ bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDispl
     SEIMessages drapSEIs = getSeisByType(m_pcPic->SEIs, SEI::DEPENDENT_RAP_INDICATION );
     if (!drapSEIs.empty())
     {
-      msg( NOTICE, "Dependent RAP indication SEI decoded\n");
+      msg( VTM_NOTICE, "Dependent RAP indication SEI decoded\n");
       pcSlice->setDRAP(true);
       pcSlice->setLatestDRAPPOC(pcSlice->getPOC());
     }
@@ -2911,16 +2911,16 @@ void DecLib::updatePrevIRAPAndGDRSubpic()
     if (pcSlice->getCtuAddrInSlice(0) == m_pcPic->cs->pps->getSubPic(subpicIdx).getFirstCTUInSubPic())
     {
       const NalUnitType subpicType = pcSlice->getNalUnitType();
-      if (subpicType == NAL_UNIT_CODED_SLICE_IDR_W_RADL || subpicType == NAL_UNIT_CODED_SLICE_IDR_N_LP || subpicType == NAL_UNIT_CODED_SLICE_CRA)
-      {
-        m_prevIRAPSubpicPOC[m_pcPic->layerId][subpicIdx] = m_pcPic->getPOC();
-        m_prevIRAPSubpicType[m_pcPic->layerId][subpicIdx] = subpicType;
-        m_prevIRAPSubpicDecOrderNo[m_pcPic->layerId][subpicIdx] = m_pcPic->getDecodingOrderNumber();
-      }
-      else if (subpicType == NAL_UNIT_CODED_SLICE_GDR)
-      {
-        m_prevGDRSubpicPOC[m_pcPic->layerId][subpicIdx] = m_pcPic->getPOC();
-      }
+//      if (subpicType == NAL_UNIT_CODED_SLICE_IDR_W_RADL || subpicType == NAL_UNIT_CODED_SLICE_IDR_N_LP || subpicType == NAL_UNIT_CODED_SLICE_CRA)
+//      {
+//        m_prevIRAPSubpicPOC[m_pcPic->layerId][subpicIdx] = m_pcPic->getPOC();
+//        m_prevIRAPSubpicType[m_pcPic->layerId][subpicIdx] = subpicType;
+//        m_prevIRAPSubpicDecOrderNo[m_pcPic->layerId][subpicIdx] = m_pcPic->getDecodingOrderNumber();
+//      }
+//      else if (subpicType == NAL_UNIT_CODED_SLICE_GDR)
+//      {
+//        m_prevGDRSubpicPOC[m_pcPic->layerId][subpicIdx] = m_pcPic->getPOC();
+//      }
     }
   }
 }
@@ -3106,7 +3106,7 @@ bool DecLib::decode(InputNALUnit& nalu, int& iSkipFrame, int& iPOCLastDisplay, i
       {
         if ( m_prevSliceSkipped )
         {
-          msg( NOTICE, "Note: received suffix SEI but current picture is skipped.\n");
+          msg( VTM_NOTICE, "Note: received suffix SEI but current picture is skipped.\n");
           return false;
         }
         m_pictureSeiNalus.push_back(new InputNALUnit(nalu));
@@ -3121,7 +3121,7 @@ bool DecLib::decode(InputNALUnit& nalu, int& iSkipFrame, int& iPOCLastDisplay, i
       }
       else
       {
-        msg( NOTICE, "Note: received suffix SEI but no picture currently active.\n");
+        msg( VTM_NOTICE, "Note: received suffix SEI but no picture currently active.\n");
       }
       return false;
 
@@ -3141,10 +3141,10 @@ bool DecLib::decode(InputNALUnit& nalu, int& iSkipFrame, int& iPOCLastDisplay, i
       m_pocCRA[nalu.m_nuhLayerId] = -MAX_INT;
       m_prevGDRInSameLayerPOC[nalu.m_nuhLayerId] = -MAX_INT;
       m_prevGDRInSameLayerRecoveryPOC[nalu.m_nuhLayerId] = -MAX_INT;
-      std::fill_n(m_prevGDRSubpicPOC[nalu.m_nuhLayerId], MAX_NUM_SUB_PICS, -MAX_INT);
-      std::fill_n(m_prevIRAPSubpicPOC[nalu.m_nuhLayerId], MAX_NUM_SUB_PICS, -MAX_INT);
-      memset(m_prevIRAPSubpicDecOrderNo[nalu.m_nuhLayerId], 0, sizeof(int)*MAX_NUM_SUB_PICS);
-      std::fill_n(m_prevIRAPSubpicType[nalu.m_nuhLayerId], MAX_NUM_SUB_PICS, NAL_UNIT_INVALID);
+      // std::fill_n(m_prevGDRSubpicPOC[nalu.m_nuhLayerId], MAX_NUM_SUB_PICS, -MAX_INT);
+      // std::fill_n(m_prevIRAPSubpicPOC[nalu.m_nuhLayerId], MAX_NUM_SUB_PICS, -MAX_INT);
+      // memset(m_prevIRAPSubpicDecOrderNo[nalu.m_nuhLayerId], 0, sizeof(int)*MAX_NUM_SUB_PICS);
+      // std::fill_n(m_prevIRAPSubpicType[nalu.m_nuhLayerId], MAX_NUM_SUB_PICS, NAL_UNIT_INVALID);
       m_pocRandomAccess = MAX_INT;
       m_prevLayerID = MAX_INT;
       m_prevPOC = -MAX_INT;
@@ -3170,12 +3170,12 @@ bool DecLib::decode(InputNALUnit& nalu, int& iSkipFrame, int& iPOCLastDisplay, i
       FDReader fdReader;
       uint32_t fdSize;
       fdReader.parseFillerData(&(nalu.getBitstream()), fdSize);
-      msg( NOTICE, "Note: found NAL_UNIT_FD with %u bytes payload.\n", fdSize);
+      msg( VTM_NOTICE, "Note: found NAL_UNIT_FD with %u bytes payload.\n", fdSize);
       return false;
     }
 
     case NAL_UNIT_RESERVED_IRAP_VCL_11:
-      msg( NOTICE, "Note: found reserved VCL NAL unit.\n");
+      msg( VTM_NOTICE, "Note: found reserved VCL NAL unit.\n");
       xParsePrefixSEIsForUnknownVCLNal();
       return false;
     case NAL_UNIT_RESERVED_VCL_4:
@@ -3183,13 +3183,13 @@ bool DecLib::decode(InputNALUnit& nalu, int& iSkipFrame, int& iPOCLastDisplay, i
     case NAL_UNIT_RESERVED_VCL_6:
     case NAL_UNIT_RESERVED_NVCL_26:
     case NAL_UNIT_RESERVED_NVCL_27:
-      msg( NOTICE, "Note: found reserved NAL unit.\n");
+      msg( VTM_NOTICE, "Note: found reserved NAL unit.\n");
       return false;
     case NAL_UNIT_UNSPECIFIED_28:
     case NAL_UNIT_UNSPECIFIED_29:
     case NAL_UNIT_UNSPECIFIED_30:
     case NAL_UNIT_UNSPECIFIED_31:
-      msg( NOTICE, "Note: found unspecified NAL unit.\n");
+      msg( VTM_NOTICE, "Note: found unspecified NAL unit.\n");
       return false;
     default:
       THROW( "Invalid NAL unit type" );
@@ -3242,7 +3242,7 @@ bool DecLib::isRandomAccessSkipPicture( int& iSkipFrame, int& iPOCLastDisplay, b
     {
       if(!m_warningMessageSkipPicture)
       {
-        msg( WARNING, "Warning: This is not a valid random access point and the data is discarded until the first CRA or GDR picture\n");
+        msg( VTM_WARNING, "Warning: This is not a valid random access point and the data is discarded until the first CRA or GDR picture\n");
         m_warningMessageSkipPicture = true;
       }
       iSkipFrame--;
@@ -3377,7 +3377,7 @@ bool DecLib::isNewPicture(std::ifstream *bitstreamFile, class InputByteStream *b
     byteStreamNALUnit(*bytestream, nalu.getBitstream().getFifo(), stats);
     if (nalu.getBitstream().getFifo().empty())
     {
-      msg( ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+      msg( VTM_ERROR, "Warning: Attempt to decode an empty NAL unit\n");
     }
     else
     {
@@ -3486,7 +3486,7 @@ bool DecLib::isNewAccessUnit( bool newPicture, std::ifstream *bitstreamFile, cla
     byteStreamNALUnit(*bytestream, nalu.getBitstream().getFifo(), stats);
     if (nalu.getBitstream().getFifo().empty())
     {
-      msg( ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+      msg( VTM_ERROR, "Warning: Attempt to decode an empty NAL unit\n");
     }
     else
     {
diff --git a/source/Lib/DecoderLib/DecLib.h b/source/Lib/DecoderLib/DecLib.h
index d95f4a7..afb9d8e 100644
--- a/source/Lib/DecoderLib/DecLib.h
+++ b/source/Lib/DecoderLib/DecLib.h
@@ -80,10 +80,10 @@ private:
   int                     m_decodingOrderCounter;
   int                     m_puCounter;
   bool                    m_seiInclusionFlag;
-  int                     m_prevGDRSubpicPOC[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
-  int                     m_prevIRAPSubpicPOC[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
-  NalUnitType             m_prevIRAPSubpicType[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
-  int                     m_prevIRAPSubpicDecOrderNo[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
+//  int                     m_prevGDRSubpicPOC[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
+//  int                     m_prevIRAPSubpicPOC[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
+//  NalUnitType             m_prevIRAPSubpicType[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
+//  int                     m_prevIRAPSubpicDecOrderNo[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
   int                     m_pocRandomAccess;   ///< POC number of the random access point (the first IDR or CRA picture)
   int                     m_lastRasPoc;
   bool                    m_prevEOS[MAX_VPS_LAYERS];
@@ -227,7 +227,7 @@ public:
   void  deletePicBuffer();
 
   void  executeLoopFilters();
-  void finishPicture(int &poc, PicList *&rpcListPic, MsgLevel msgl = INFO, bool associatedWithNewClvs = false);
+  void finishPicture(int &poc, PicList *&rpcListPic, MsgLevel msgl = VTM_INFO, bool associatedWithNewClvs = false);
   void  finishPictureLight(int& poc, PicList*& rpcListPic );
   void  checkNoOutputPriorPics (PicList* rpcListPic);
   void  checkNalUnitConstraints( uint32_t naluType );
diff --git a/source/Lib/DecoderLib/NALread.cpp b/source/Lib/DecoderLib/NALread.cpp
index ccda006..5620941 100644
--- a/source/Lib/DecoderLib/NALread.cpp
+++ b/source/Lib/DecoderLib/NALread.cpp
@@ -99,7 +99,7 @@ static void convertPayloadToRBSP(vector<uint8_t>& nalUnitBuf, InputBitstream *bi
 
     if (n > 0)
     {
-      msg( NOTICE, "\nDetected %d instances of cabac_zero_word\n", n/2);
+      msg( VTM_NOTICE, "\nDetected %d instances of cabac_zero_word\n", n/2);
     }
   }
 
diff --git a/source/Lib/DecoderLib/SEIread.cpp b/source/Lib/DecoderLib/SEIread.cpp
index 25fc7cb..50e2ba8 100644
--- a/source/Lib/DecoderLib/SEIread.cpp
+++ b/source/Lib/DecoderLib/SEIread.cpp
@@ -190,7 +190,7 @@ void SEIReader::xReadSEImessage(SEIMessages& seis, const NalUnitType nalUnitType
       bp = hrd.getBufferingPeriodSEI();
       if (!bp)
       {
-        msg( WARNING, "Warning: Found Decoding unit information SEI message, but no active buffering period is available. Ignoring.");
+        msg( VTM_WARNING, "Warning: Found Decoding unit information SEI message, but no active buffering period is available. Ignoring.");
       }
       else
       {
@@ -208,7 +208,7 @@ void SEIReader::xReadSEImessage(SEIMessages& seis, const NalUnitType nalUnitType
         bp = hrd.getBufferingPeriodSEI();
         if (!bp)
         {
-          msg( WARNING, "Warning: Found Picture timing SEI message, but no active buffering period is available. Ignoring.");
+          msg( VTM_WARNING, "Warning: Found Picture timing SEI message, but no active buffering period is available. Ignoring.");
         }
         else
         {
@@ -306,7 +306,7 @@ void SEIReader::xReadSEImessage(SEIMessages& seis, const NalUnitType nalUnitType
         uint32_t seiByte;
         sei_read_code (NULL, 8, seiByte, "unknown prefix SEI payload byte");
       }
-      msg( WARNING, "Unknown prefix SEI message (payloadType = %d) was found!\n", payloadType);
+      msg( VTM_WARNING, "Unknown prefix SEI message (payloadType = %d) was found!\n", payloadType);
       if (pDecodedMessageOutputStream)
       {
         (*pDecodedMessageOutputStream) << "Unknown prefix SEI message (payloadType = " << payloadType << ") was found!\n";
@@ -336,7 +336,7 @@ void SEIReader::xReadSEImessage(SEIMessages& seis, const NalUnitType nalUnitType
           uint32_t seiByte;
           sei_read_code( NULL, 8, seiByte, "unknown suffix SEI payload byte");
         }
-        msg( WARNING, "Unknown suffix SEI message (payloadType = %d) was found!\n", payloadType);
+        msg( VTM_WARNING, "Unknown suffix SEI message (payloadType = %d) was found!\n", payloadType);
         if (pDecodedMessageOutputStream)
         {
           (*pDecodedMessageOutputStream) << "Unknown suffix SEI message (payloadType = " << payloadType << ") was found!\n";
@@ -1690,7 +1690,7 @@ void SeiCfgFileDump::xDumpSEIEquirectangularProjection     (SEIEquirectangularPr
     }
     else
     {
-      msg( ERROR, "File %s could not be opened.\n", decoded360MessageFileName.c_str() );
+      msg( VTM_ERROR, "File %s could not be opened.\n", decoded360MessageFileName.c_str() );
     }
   }
 }
@@ -1773,7 +1773,7 @@ void SeiCfgFileDump::xDumpSEIGeneralizedCubemapProjection  (SEIGeneralizedCubema
       }
       else
       {
-        msg( ERROR, "File %s could not be opened.\n", decoded360MessageFileName.c_str() );
+        msg( VTM_ERROR, "File %s could not be opened.\n", decoded360MessageFileName.c_str() );
       }
     }
   }
diff --git a/source/Lib/DecoderLib/VLCReader.cpp b/source/Lib/DecoderLib/VLCReader.cpp
index 12275fb..529a718 100644
--- a/source/Lib/DecoderLib/VLCReader.cpp
+++ b/source/Lib/DecoderLib/VLCReader.cpp
@@ -4062,8 +4062,8 @@ void HLSyntaxReader::parseSliceHeader (Slice* pcSlice, PicHeader* picHeader, Par
     {
       if (pps->getWpInfoInPhFlag())
       {
-        CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_0) > picHeader->getNumL0Weights(), "ERROR: Number of active reference picture L0 is greater than the number of weighted prediction signalled in Picture Header");
-        CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_1) > picHeader->getNumL1Weights(), "ERROR: Number of active reference picture L1 is greater than the number of weighted prediction signalled in Picture Header");
+        CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_0) > picHeader->getNumL0Weights(), "VTM_ERROR: Number of active reference picture L0 is greater than the number of weighted prediction signalled in Picture Header");
+        CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_1) > picHeader->getNumL1Weights(), "VTM_ERROR: Number of active reference picture L1 is greater than the number of weighted prediction signalled in Picture Header");
         pcSlice->setWpScaling(picHeader->getWpScalingAll());
       }
       else
@@ -4664,7 +4664,7 @@ void HLSyntaxReader::parseRemainingBytes( bool noTrailingBytesExpected )
       uint32_t trailingNullByte=m_pcBitstream->readByte();
       if (trailingNullByte!=0)
       {
-        msg( ERROR, "Trailing byte should be 0, but has value %02x\n", trailingNullByte);
+        msg( VTM_ERROR, "Trailing byte should be 0, but has value %02x\n", trailingNullByte);
         THROW("Invalid trailing '0' byte");
       }
     }
diff --git a/source/Lib/EncoderLib/Analyze.h b/source/Lib/EncoderLib/Analyze.h
index 1518c26..7bea849 100644
--- a/source/Lib/EncoderLib/Analyze.h
+++ b/source/Lib/EncoderLib/Analyze.h
@@ -206,9 +206,9 @@ public:
 #endif
   {
 #if !WCG_WPSNR
-    MsgLevel e_msg_level = cDelim == 'a' ? INFO: DETAILS;
+    MsgLevel e_msg_level = cDelim == 'a' ? VTM_INFO: VTM_DETAILS;
 #else
-    MsgLevel e_msg_level = (cDelim == 'a') || (cDelim == 'w') ? INFO : DETAILS;
+    MsgLevel e_msg_level = (cDelim == 'a') || (cDelim == 'w') ? VTM_INFO : VTM_DETAILS;
 #endif
     double dFps     =   m_dFrmRate; //--CFG_KDY
     double dScale   = dFps / 1000 / (double)m_uiNumPic;
@@ -630,7 +630,7 @@ public:
         }
         break;
       default:
-        msg( ERROR, "Unknown format during print out\n");
+        msg( VTM_ERROR, "Unknown format during print out\n");
         exit(1);
         break;
     }
@@ -683,7 +683,7 @@ public:
         }
 
       default:
-          msg( ERROR, "Unknown format during print out\n");
+          msg( VTM_ERROR, "Unknown format during print out\n");
           exit(1);
           break;
     }
diff --git a/source/Lib/EncoderLib/EncCfg.h b/source/Lib/EncoderLib/EncCfg.h
index 657288a..706317f 100644
--- a/source/Lib/EncoderLib/EncCfg.h
+++ b/source/Lib/EncoderLib/EncCfg.h
@@ -157,6 +157,12 @@ std::istringstream &operator>>(std::istringstream &in, GOPEntry &entry);     //i
 class EncCfg
 {
 protected:
+#if PCC_ME_EXT
+	std::string m_blockToPatchFileName;
+	std::string m_occupancyFileName;
+	bool        m_usePCCExt;
+	//std::string m_patchInfoFileName;
+#endif
   //==== File I/O ========
   int       m_iFrameRate;
   int       m_FrameSkip;
@@ -799,6 +805,16 @@ public:
 
   virtual ~EncCfg()
   {}
+#if PCC_ME_EXT
+  void setBlockToPatchFileName(std::string blockToPatchFileName) { m_blockToPatchFileName = blockToPatchFileName; }
+  std::string getBlockToPatchFileName() { return m_blockToPatchFileName; }
+
+  void setOccupancyMapFileName(std::string occupancyMapFileName) { m_occupancyFileName = occupancyMapFileName; }
+  std::string getOccupancyMapFileName() { return m_occupancyFileName; }
+
+  void setUsePCCExt(bool value) { m_usePCCExt = value; }
+  bool getUsePCCExt()         const { return m_usePCCExt; }
+#endif
   std::map<uint32_t, SEIAnnotatedRegions::AnnotatedRegionObject> m_arObjects;
   void setProfile(Profile::Name profile) { m_profile = profile; }
   void setLevel(Level::Tier tier, Level::Name level) { m_levelTier = tier; m_level = level; }
diff --git a/source/Lib/EncoderLib/EncGOP.cpp b/source/Lib/EncoderLib/EncGOP.cpp
index 2323c8d..40327f1 100644
--- a/source/Lib/EncoderLib/EncGOP.cpp
+++ b/source/Lib/EncoderLib/EncGOP.cpp
@@ -1272,7 +1272,7 @@ validateMinCrRequirements(const ProfileLevelTierFeatures &plt, std::size_t numBy
 
       if (numBytesInVclNalUnits > threshold)
       {
-        msg( WARNING, "WARNING: Encoded stream does not meet MinCr requirements numBytesInVclNalUnits (%.0f) must be <= %.0f. Try increasing Qp, tier or level\n",
+        msg( VTM_WARNING, "VTM_WARNING: Encoded stream does not meet MinCr requirements numBytesInVclNalUnits (%.0f) must be <= %.0f. Try increasing Qp, tier or level\n",
                       (double) numBytesInVclNalUnits, threshold );
       }
     }
@@ -1320,11 +1320,11 @@ cabac_zero_word_padding(const Slice *const pcSlice,
           zeroBytesPadding[i*3+2]=3;  // 00 00 03
         }
         nalUnitData.write(reinterpret_cast<const char*>(&(zeroBytesPadding[0])), numberOfAdditionalCabacZeroBytes);
-        msg( NOTICE, "Adding %d bytes of padding\n", uint32_t( numberOfAdditionalCabacZeroWords * 3 ) );
+        msg( VTM_NOTICE, "Adding %d bytes of padding\n", uint32_t( numberOfAdditionalCabacZeroWords * 3 ) );
       }
       else
       {
-        msg( NOTICE, "Standard would normally require adding %d bytes of padding\n", uint32_t( numberOfAdditionalCabacZeroWords * 3 ) );
+        msg( VTM_NOTICE, "Standard would normally require adding %d bytes of padding\n", uint32_t( numberOfAdditionalCabacZeroWords * 3 ) );
       }
       return numberOfAdditionalCabacZeroWords;
     }
@@ -1484,11 +1484,11 @@ printHash(const HashType hashType, const std::string &digestStr)
   {
     if (digestStr.empty())
     {
-      msg( NOTICE, " [%s:%s]", decodedPictureHashModeName, "?");
+      msg( VTM_NOTICE, " [%s:%s]", decodedPictureHashModeName, "?");
     }
     else
     {
-      msg( NOTICE, " [%s:%s]", decodedPictureHashModeName, digestStr.c_str());
+      msg( VTM_NOTICE, " [%s:%s]", decodedPictureHashModeName, digestStr.c_str());
     }
   }
 }
@@ -2979,6 +2979,57 @@ void EncGOP::compressGOP( int iPOCLast, int iNumPicRcvd, PicList& rcListPic,
         }
 
         m_pcSliceEncoder->precompressSlice( pcPic );
+#if PCC_ME_EXT
+		    if (pcSlice->getPOC() % PCC_ME_NUM_LAYERS_ACTIVE == 0 && m_pcCfg->getUsePCCExt())
+		    {
+			    //printf("\nPCC ME ACTIVE\n");
+          int blockToPatchWidth = picWidth / 16;
+          int blockToPatchHeight = picHeight / 16;
+
+			    int currPOC = pcSlice->getPOC() / PCC_ME_NUM_LAYERS_ACTIVE;
+			    int64_t offset = (int64_t)currPOC * blockToPatchWidth * blockToPatchHeight;
+
+          std::string blockToPatchFileName = m_pcCfg->getBlockToPatchFileName();
+			    FILE* blockToPatchFile = NULL;
+			    blockToPatchFile = fopen(blockToPatchFileName.c_str(), "rb");
+#ifdef _MSC_VER
+          _fseeki64(blockToPatchFile, offset * sizeof(int64_t), SEEK_SET);
+#else
+			    fseek(blockToPatchFile, offset * sizeof(int64_t), SEEK_SET);
+#endif
+			    int64_t* blockToPatch = pcPic->getBlockToPatch();
+			    size_t readSize = fread(blockToPatch, sizeof(int64_t), blockToPatchWidth * blockToPatchHeight, blockToPatchFile);
+			    if (readSize != blockToPatchWidth * blockToPatchHeight)
+			    {
+				    printf("error: Resolution does not match");
+			    }
+			    fclose(blockToPatchFile);
+
+			    offset = (int64_t)currPOC * picWidth * picHeight;
+          std::string occupancyMapFileName = m_pcCfg->getOccupancyMapFileName();
+			    FILE* occupancyMapFile = NULL;
+			    occupancyMapFile = fopen(occupancyMapFileName.c_str(), "rb");
+#ifdef _MSC_VER
+          _fseeki64(occupancyMapFile, offset * sizeof(int), SEEK_SET);
+#else
+			    fseek(occupancyMapFile, offset * sizeof(int), SEEK_SET);
+#endif
+			    int* occupancyMap = pcPic->getOccupancyMap();
+			    readSize = fread(occupancyMap, sizeof(int), picWidth * picHeight, occupancyMapFile);
+			    if (readSize != picWidth * picHeight)
+			    {
+				    printf("error: Resolution does not match");
+			    }
+			    fclose(occupancyMapFile);
+		    }
+        if (m_pcCfg->getUsePCCExt())
+		    {
+			    for (int i = 0; i < PCC_ME_EXT_MAX_NUM_PATCHES; i++)
+			    {
+				    g_vtmpatchesChange[i] = true;
+			    }
+		    }
+#endif
         m_pcSliceEncoder->compressSlice   ( pcPic, false, false );
 
         if(sliceIdx < pcPic->cs->pps->getNumSlicesInPic() - 1)
@@ -3777,7 +3828,7 @@ void EncGOP::compressGOP( int iPOCLast, int iNumPicRcvd, PicList& rcListPic,
         if (m_pcRateCtrl->getCpbSaturationEnabled())
         {
           m_pcRateCtrl->updateCpbState(actualTotalBits);
-          msg( NOTICE, " [CPB %6d bits]", m_pcRateCtrl->getCpbState() );
+          msg( VTM_NOTICE, " [CPB %6d bits]", m_pcRateCtrl->getCpbState() );
         }
   #endif
       }
@@ -3804,7 +3855,7 @@ void EncGOP::compressGOP( int iPOCLast, int iNumPicRcvd, PicList& rcListPic,
 
       m_AUWriterIf->outputAU( accessUnit );
 
-      msg( NOTICE, "\n" );
+      msg( VTM_NOTICE, "\n" );
       fflush( stdout );
     }
 
@@ -3870,8 +3921,8 @@ void EncGOP::printOutSummary( uint32_t uiNumAllPicCoded, bool isField, const boo
   const ChromaFormat chFmt = m_pcCfg->getChromaFormatIdc();
 
   //-- all
-  msg( INFO, "\n" );
-  msg( DETAILS,"\nSUMMARY --------------------------------------------------------\n" );
+  msg( VTM_INFO, "\n" );
+  msg( VTM_DETAILS,"\nSUMMARY --------------------------------------------------------\n" );
 #if JVET_O0756_CALCULATE_HDRMETRICS
   const bool calculateHdrMetrics = m_pcEncLib->getCalcluateHdrMetrics();
 #endif
@@ -3889,22 +3940,22 @@ void EncGOP::printOutSummary( uint32_t uiNumAllPicCoded, bool isField, const boo
 #endif
                           );
 #endif
-  msg( DETAILS, "\n\nI Slices--------------------------------------------------------\n" );
+  msg( VTM_DETAILS, "\n\nI Slices--------------------------------------------------------\n" );
   m_gcAnalyzeI.printOut( 'i', chFmt, printMSEBasedSNR, printSequenceMSE, printMSSSIM,
     printHexPsnr, printRprPSNR, bitDepths );
 
-  msg( DETAILS, "\n\nP Slices--------------------------------------------------------\n" );
+  msg( VTM_DETAILS, "\n\nP Slices--------------------------------------------------------\n" );
   m_gcAnalyzeP.printOut( 'p', chFmt, printMSEBasedSNR, printSequenceMSE, printMSSSIM,
     printHexPsnr, printRprPSNR, bitDepths );
 
-  msg( DETAILS, "\n\nB Slices--------------------------------------------------------\n" );
+  msg( VTM_DETAILS, "\n\nB Slices--------------------------------------------------------\n" );
   m_gcAnalyzeB.printOut( 'b', chFmt, printMSEBasedSNR, printSequenceMSE, printMSSSIM,
     printHexPsnr, printRprPSNR, bitDepths );
 
 #if WCG_WPSNR
   if (useLumaWPSNR)
   {
-    msg(DETAILS, "\nWPSNR SUMMARY --------------------------------------------------------\n");
+    msg(VTM_DETAILS, "\nWPSNR SUMMARY --------------------------------------------------------\n");
     m_gcAnalyzeWPSNR.printOut( 'w', chFmt, printMSEBasedSNR, printSequenceMSE, printMSSSIM,
       printHexPsnr, printRprPSNR, bitDepths, useLumaWPSNR );
   }
@@ -3934,7 +3985,7 @@ void EncGOP::printOutSummary( uint32_t uiNumAllPicCoded, bool isField, const boo
     m_gcAnalyzeAll_in.setBits(m_gcAnalyzeAll.getBits());
     // prior to the above statement, the interlace analyser does not contain the correct total number of bits.
 
-    msg( INFO,"\n\nSUMMARY INTERLACED ---------------------------------------------\n" );
+    msg( VTM_INFO,"\n\nSUMMARY INTERLACED ---------------------------------------------\n" );
 #if ENABLE_QPA
     m_gcAnalyzeAll_in.printOut( 'a', chFmt, printMSEBasedSNR, printSequenceMSE, printMSSSIM,
       printHexPsnr, printRprPSNR, bitDepths, useWPSNR );
@@ -3954,7 +4005,7 @@ void EncGOP::printOutSummary( uint32_t uiNumAllPicCoded, bool isField, const boo
     }
   }
 
-  msg( DETAILS,"\nRVM: %.3lf\n", xCalculateRVM() );
+  msg( VTM_DETAILS,"\nRVM: %.3lf\n", xCalculateRVM() );
 }
 
 #if W0038_DB_OPT
@@ -4530,7 +4581,7 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
     uint32_t numRBSPBytes_nal = uint32_t((*it)->m_nalUnitData.str().size());
     if (m_pcCfg->getSummaryVerboseness() > 0)
     {
-      msg( NOTICE, "*** %6s numBytesInNALunit: %u\n", nalUnitTypeToString((*it)->m_nalUnitType), numRBSPBytes_nal);
+      msg( VTM_NOTICE, "*** %6s numBytesInNALunit: %u\n", nalUnitTypeToString((*it)->m_nalUnitType), numRBSPBytes_nal);
     }
     if( ( *it )->m_nalUnitType != NAL_UNIT_PREFIX_SEI && ( *it )->m_nalUnitType != NAL_UNIT_SUFFIX_SEI )
     {
@@ -4619,9 +4670,9 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
     c = 'D';
   }
 
-  if( g_verbosity >= NOTICE )
+  if( g_verbosity >= VTM_NOTICE )
   {
-    msg( NOTICE, "POC %4d LId: %2d TId: %1d ( %s, %c-SLICE, QP %d ) %10d bits",
+    msg( VTM_NOTICE, "POC %4d LId: %2d TId: %1d ( %s, %c-SLICE, QP %d ) %10d bits",
          pcSlice->getPOC(),
          pcSlice->getPic()->layerId,
          pcSlice->getTLayer(),
@@ -4630,10 +4681,10 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
          pcSlice->getSliceQp(),
          uibits );
 
-    msg( NOTICE, " [Y %6.4lf dB    U %6.4lf dB    V %6.4lf dB]", dPSNR[COMPONENT_Y], dPSNR[COMPONENT_Cb], dPSNR[COMPONENT_Cr] );
+    msg( VTM_NOTICE, " [Y %6.4lf dB    U %6.4lf dB    V %6.4lf dB]", dPSNR[COMPONENT_Y], dPSNR[COMPONENT_Cb], dPSNR[COMPONENT_Cr] );
 
 #if EXTENSION_360_VIDEO
-    m_ext360.printPerPOCInfo(NOTICE);
+    m_ext360.printPerPOCInfo(VTM_NOTICE);
 #endif
 
     if (m_pcEncLib->getPrintHexPsnr())
@@ -4645,25 +4696,25 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
              reinterpret_cast<uint8_t *>(&dPSNR[i]) + sizeof(dPSNR[i]),
              reinterpret_cast<uint8_t *>(&xPsnr[i]));
       }
-      msg(NOTICE, " [xY %16" PRIx64 " xU %16" PRIx64 " xV %16" PRIx64 "]", xPsnr[COMPONENT_Y], xPsnr[COMPONENT_Cb], xPsnr[COMPONENT_Cr]);
+      msg(VTM_NOTICE, " [xY %16" PRIx64 " xU %16" PRIx64 " xV %16" PRIx64 "]", xPsnr[COMPONENT_Y], xPsnr[COMPONENT_Cb], xPsnr[COMPONENT_Cr]);
 
 #if EXTENSION_360_VIDEO
-      m_ext360.printPerPOCInfo(NOTICE, true);
+      m_ext360.printPerPOCInfo(VTM_NOTICE, true);
 #endif
     }
     if (printMSSSIM)
     {
-      msg( NOTICE, " [MS-SSIM Y %1.6lf    U %1.6lf    V %1.6lf]", msssim[COMPONENT_Y], msssim[COMPONENT_Cb], msssim[COMPONENT_Cr] );
+      msg( VTM_NOTICE, " [MS-SSIM Y %1.6lf    U %1.6lf    V %1.6lf]", msssim[COMPONENT_Y], msssim[COMPONENT_Cb], msssim[COMPONENT_Cr] );
     }
 
     if( printFrameMSE )
     {
-      msg( NOTICE, " [Y MSE %6.4lf  U MSE %6.4lf  V MSE %6.4lf]", MSEyuvframe[COMPONENT_Y], MSEyuvframe[COMPONENT_Cb], MSEyuvframe[COMPONENT_Cr] );
+      msg( VTM_NOTICE, " [Y MSE %6.4lf  U MSE %6.4lf  V MSE %6.4lf]", MSEyuvframe[COMPONENT_Y], MSEyuvframe[COMPONENT_Cb], MSEyuvframe[COMPONENT_Cr] );
     }
 #if WCG_WPSNR
     if (useLumaWPSNR)
     {
-      msg(NOTICE, " [WY %6.4lf dB    WU %6.4lf dB    WV %6.4lf dB]", dPSNRWeighted[COMPONENT_Y], dPSNRWeighted[COMPONENT_Cb], dPSNRWeighted[COMPONENT_Cr]);
+      msg(VTM_NOTICE, " [WY %6.4lf dB    WU %6.4lf dB    WV %6.4lf dB]", dPSNRWeighted[COMPONENT_Y], dPSNRWeighted[COMPONENT_Cb], dPSNRWeighted[COMPONENT_Cr]);
 
       if (m_pcEncLib->getPrintHexPsnr())
       {
@@ -4674,7 +4725,7 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
                reinterpret_cast<uint8_t *>(&dPSNRWeighted[i]) + sizeof(dPSNRWeighted[i]),
                reinterpret_cast<uint8_t *>(&xPsnrWeighted[i]));
         }
-        msg(NOTICE, " [xWY %16" PRIx64 " xWU %16" PRIx64 " xWV %16" PRIx64 "]", xPsnrWeighted[COMPONENT_Y], xPsnrWeighted[COMPONENT_Cb], xPsnrWeighted[COMPONENT_Cr]);
+        msg(VTM_NOTICE, " [xWY %16" PRIx64 " xWU %16" PRIx64 " xWV %16" PRIx64 "]", xPsnrWeighted[COMPONENT_Y], xPsnrWeighted[COMPONENT_Cb], xPsnrWeighted[COMPONENT_Cr]);
       }
     }
 #endif
@@ -4683,7 +4734,7 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
     {
       for (int i=0; i<1; i++)
       {
-        msg(NOTICE, " [DeltaE%d %6.4lf dB]", (int)m_pcCfg->getWhitePointDeltaE(i), deltaE[i]);
+        msg(VTM_NOTICE, " [DeltaE%d %6.4lf dB]", (int)m_pcCfg->getWhitePointDeltaE(i), deltaE[i]);
         if (m_pcEncLib->getPrintHexPsnr())
         {
           int64_t xdeltaE[MAX_NUM_COMPONENT];
@@ -4693,12 +4744,12 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
                  reinterpret_cast<uint8_t *>(&deltaE[i]) + sizeof(deltaE[i]),
                  reinterpret_cast<uint8_t *>(&xdeltaE[i]));
           }
-          msg(NOTICE, " [xDeltaE%d %16" PRIx64 "]", (int)m_pcCfg->getWhitePointDeltaE(i), xdeltaE[0]);
+          msg(VTM_NOTICE, " [xDeltaE%d %16" PRIx64 "]", (int)m_pcCfg->getWhitePointDeltaE(i), xdeltaE[0]);
         }
       }
       for (int i=0; i<1; i++)
       {
-        msg(NOTICE, " [PSNRL%d %6.4lf dB]", (int)m_pcCfg->getWhitePointDeltaE(i), psnrL[i]);
+        msg(VTM_NOTICE, " [PSNRL%d %6.4lf dB]", (int)m_pcCfg->getWhitePointDeltaE(i), psnrL[i]);
 
         if (m_pcEncLib->getPrintHexPsnr())
         {
@@ -4710,18 +4761,18 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
                  reinterpret_cast<uint8_t *>(&xpsnrL[i]));
           }
 
-          msg(NOTICE, " [xPSNRL%d %16" PRIx64 "]", (int) m_pcCfg->getWhitePointDeltaE(i), xpsnrL[0]);
+          msg(VTM_NOTICE, " [xPSNRL%d %16" PRIx64 "]", (int) m_pcCfg->getWhitePointDeltaE(i), xpsnrL[0]);
         }
       }
     }
 #endif
-    msg( NOTICE, " [ET %5.0f ]", dEncTime );
+    msg( VTM_NOTICE, " [ET %5.0f ]", dEncTime );
 
     // msg( SOME, " [WP %d]", pcSlice->getUseWeightedPrediction());
 
     for( int iRefList = 0; iRefList < 2; iRefList++ )
     {
-      msg( NOTICE, " [L%d", iRefList );
+      msg( VTM_NOTICE, " [L%d", iRefList );
       for( int iRefIndex = 0; iRefIndex < pcSlice->getNumRefIdx( RefPicList( iRefList ) ); iRefIndex++ )
       {
         const std::pair<int, int>& scaleRatio = pcSlice->getScalingRatio( RefPicList( iRefList ), iRefIndex );
@@ -4730,38 +4781,38 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
         {
           if( scaleRatio.first != 1 << SCALE_RATIO_BITS || scaleRatio.second != 1 << SCALE_RATIO_BITS )
           {
-            msg( NOTICE, " %dc(%1.2lfx, %1.2lfx)", pcSlice->getRefPOC( RefPicList( iRefList ), iRefIndex ), double( scaleRatio.first ) / ( 1 << SCALE_RATIO_BITS ), double( scaleRatio.second ) / ( 1 << SCALE_RATIO_BITS ) );
+            msg( VTM_NOTICE, " %dc(%1.2lfx, %1.2lfx)", pcSlice->getRefPOC( RefPicList( iRefList ), iRefIndex ), double( scaleRatio.first ) / ( 1 << SCALE_RATIO_BITS ), double( scaleRatio.second ) / ( 1 << SCALE_RATIO_BITS ) );
           }
           else
           {
-            msg( NOTICE, " %dc", pcSlice->getRefPOC( RefPicList( iRefList ), iRefIndex ) );
+            msg( VTM_NOTICE, " %dc", pcSlice->getRefPOC( RefPicList( iRefList ), iRefIndex ) );
           }
         }
         else
         {
           if( scaleRatio.first != 1 << SCALE_RATIO_BITS || scaleRatio.second != 1 << SCALE_RATIO_BITS )
           {
-            msg( NOTICE, " %d(%1.2lfx, %1.2lfx)", pcSlice->getRefPOC( RefPicList( iRefList ), iRefIndex ), double( scaleRatio.first ) / ( 1 << SCALE_RATIO_BITS ), double( scaleRatio.second ) / ( 1 << SCALE_RATIO_BITS ) );
+            msg( VTM_NOTICE, " %d(%1.2lfx, %1.2lfx)", pcSlice->getRefPOC( RefPicList( iRefList ), iRefIndex ), double( scaleRatio.first ) / ( 1 << SCALE_RATIO_BITS ), double( scaleRatio.second ) / ( 1 << SCALE_RATIO_BITS ) );
           }
           else
           {
-            msg( NOTICE, " %d", pcSlice->getRefPOC( RefPicList( iRefList ), iRefIndex ) );
+            msg( VTM_NOTICE, " %d", pcSlice->getRefPOC( RefPicList( iRefList ), iRefIndex ) );
           }
         }
 
         if( pcSlice->getRefPOC( RefPicList( iRefList ), iRefIndex ) == pcSlice->getPOC() )
         {
-          msg( NOTICE, ".%d", pcSlice->getRefPic( RefPicList( iRefList ), iRefIndex )->layerId );
+          msg( VTM_NOTICE, ".%d", pcSlice->getRefPic( RefPicList( iRefList ), iRefIndex )->layerId );
         }
       }
-      msg( NOTICE, "]" );
+      msg( VTM_NOTICE, "]" );
     }
     if (m_pcEncLib->isResChangeInClvsEnabled())
     {
-      msg( NOTICE, "\nPSNR2: [Y %6.4lf dB    U %6.4lf dB    V %6.4lf dB]", upscaledPSNR[COMPONENT_Y], upscaledPSNR[COMPONENT_Cb], upscaledPSNR[COMPONENT_Cr] );
+      msg( VTM_NOTICE, "\nPSNR2: [Y %6.4lf dB    U %6.4lf dB    V %6.4lf dB]", upscaledPSNR[COMPONENT_Y], upscaledPSNR[COMPONENT_Cb], upscaledPSNR[COMPONENT_Cr] );
     }
   }
-  else if( g_verbosity >= INFO )
+  else if( g_verbosity >= VTM_INFO )
   {
     std::cout << "\r\t" << pcSlice->getPOC();
     std::cout.flush();
@@ -5124,14 +5175,14 @@ void EncGOP::xCalculateInterlacedAddPSNR( Picture* pcPicOrgFirstField, Picture*
 
   *PSNR_Y = dPSNR[COMPONENT_Y];
 
-  msg( INFO, "\n                                      Interlaced frame %d: [Y %6.4lf dB    U %6.4lf dB    V %6.4lf dB]", pcPicOrgSecondField->getPOC()/2, dPSNR[COMPONENT_Y], dPSNR[COMPONENT_Cb], dPSNR[COMPONENT_Cr] );
+  msg( VTM_INFO, "\n                                      Interlaced frame %d: [Y %6.4lf dB    U %6.4lf dB    V %6.4lf dB]", pcPicOrgSecondField->getPOC()/2, dPSNR[COMPONENT_Y], dPSNR[COMPONENT_Cb], dPSNR[COMPONENT_Cr] );
   if (printMSSSIM)
   {
     printf(" [MS-SSIM Y %1.6lf    U %1.6lf    V %1.6lf]", msssim[COMPONENT_Y], msssim[COMPONENT_Cb], msssim[COMPONENT_Cr] );
   }
   if (printFrameMSE)
   {
-    msg( DETAILS, " [Y MSE %6.4lf  U MSE %6.4lf  V MSE %6.4lf]", MSEyuvframe[COMPONENT_Y], MSEyuvframe[COMPONENT_Cb], MSEyuvframe[COMPONENT_Cr] );
+    msg( VTM_DETAILS, " [Y MSE %6.4lf  U MSE %6.4lf  V MSE %6.4lf]", MSEyuvframe[COMPONENT_Y], MSEyuvframe[COMPONENT_Cb], MSEyuvframe[COMPONENT_Cr] );
   }
 
   for(uint32_t fieldNum=0; fieldNum<2; fieldNum++)
diff --git a/source/Lib/EncoderLib/InterSearch.cpp b/source/Lib/EncoderLib/InterSearch.cpp
index 931943e..be99f1f 100644
--- a/source/Lib/EncoderLib/InterSearch.cpp
+++ b/source/Lib/EncoderLib/InterSearch.cpp
@@ -5331,6 +5331,107 @@ void InterSearch::xTZSearch( const PredictionUnit& pu,
   // set rcMv (Median predictor) as start point and as best point
   xTZSearchHelp( cStruct, rcMv.getHor(), rcMv.getVer(), 0, 0 );
 
+#if PCC_ME_EXT
+  if (m_pcEncCfg->getUsePCCExt())
+  {
+    int xCoor = pu.Y().x + pu.Y().width / PCC_ME_NUM_LAYERS_ACTIVE;
+    int yCoor = pu.Y().y + pu.Y().height / PCC_ME_NUM_LAYERS_ACTIVE;
+  
+    int picWidth = pu.cs->pps->getPicWidthInLumaSamples();
+    int occupancyResolution = 16;
+    int blockToPatchWidth = picWidth / occupancyResolution;
+  
+    int* occupancyMap = pu.cs->picture->getOccupancyMap();
+    int64_t* blockToPatch = pu.cs->picture->getBlockToPatch();
+  
+    if (pu.cs->slice->getPOC() % 2 == 0 && occupancyMap[yCoor * picWidth + xCoor])
+    {
+      int xBlockIndex = xCoor / occupancyResolution;
+      int yBlockIndex = yCoor / occupancyResolution;
+  
+      int64_t patchIndex = blockToPatch[yBlockIndex * blockToPatchWidth + xBlockIndex] - 1;          // should be minus 1
+      int frameIndex = pu.cs->slice->getPOC() / PCC_ME_NUM_LAYERS_ACTIVE;
+  
+  	  // current 3D coordinate derivation
+      int64_t projectIndex = g_vtmprojectionIndex[frameIndex][patchIndex];
+  
+      int64_t patchD1 = g_vtmpatch3DInfo[frameIndex][patchIndex][0];
+      int64_t patchU1 = g_vtmpatch3DInfo[frameIndex][patchIndex][1];
+      int64_t patchV1 = g_vtmpatch3DInfo[frameIndex][patchIndex][2];
+  
+      int64_t patchU0 = g_vtmpatch2DInfo[frameIndex][patchIndex][0];
+      int64_t patchV0 = g_vtmpatch2DInfo[frameIndex][patchIndex][1];
+  
+      int64_t xCoor3D = patchU1 + (xCoor - patchU0 * occupancyResolution);
+      int64_t yCoor3D = patchV1 + (yCoor - patchV0 * occupancyResolution);
+  
+  
+      // find the suitable patch in the reference frame
+      int refPOC = pu.cs->slice->getRefPOC(eRefPicList, iRefIdxPred);
+      int refFrameIndex = refPOC / 2;
+      int64_t refNumPatches = g_vtmnumPatches[refFrameIndex];
+  
+      int bestPatchIndex = 0;
+      int64_t bestDist = INT64_MAX;
+      for (int refPatchIdx = 0; refPatchIdx < refNumPatches; refPatchIdx++)
+      {
+        int64_t refProjectionIndex = g_vtmprojectionIndex[refFrameIndex][refPatchIdx];
+  	  
+  	    if (refProjectionIndex != projectIndex)
+  	    {
+  	  	  continue;
+  	    }
+  	  
+        int64_t refPatchU1 = g_vtmpatch3DInfo[refFrameIndex][refPatchIdx][1];
+        int64_t refPatchV1 = g_vtmpatch3DInfo[refFrameIndex][refPatchIdx][2];
+
+        int64_t refPatchSizeU0 = g_vtmpatch2DInfo[refFrameIndex][refPatchIdx][2];
+        int64_t refPatchSizeV0 = g_vtmpatch2DInfo[refFrameIndex][refPatchIdx][3];
+	  
+        int64_t refPatch3DEndU1 = refPatchU1 + refPatchSizeU0 * occupancyResolution - 1;
+        int64_t refPatch3DEndV1 = refPatchV1 + refPatchSizeV0 * occupancyResolution - 1;
+
+        bool xCond = (xCoor3D >= refPatchU1 && xCoor3D <= refPatch3DEndU1);
+        bool yCond = (yCoor3D >= refPatchV1 && yCoor3D <= refPatch3DEndV1);
+	  
+        if (xCond && yCond)
+        {
+          int64_t refPatchD1 = g_vtmpatch3DInfo[refFrameIndex][refPatchIdx][0];
+          int64_t patchDist = abs(patchD1 - refPatchD1);
+
+          if (patchDist < bestDist)
+          {
+            bestDist = patchDist;
+            bestPatchIndex = refPatchIdx;
+          }
+        }
+	    }
+
+      int64_t diff3DU = g_vtmpatch3DInfo[frameIndex][patchIndex][1] - g_vtmpatch3DInfo[refFrameIndex][bestPatchIndex][1];
+      int64_t diff3DV = g_vtmpatch3DInfo[frameIndex][patchIndex][2] - g_vtmpatch3DInfo[refFrameIndex][bestPatchIndex][2];
+
+      int64_t diff2DU = (g_vtmpatch2DInfo[refFrameIndex][bestPatchIndex][0] - g_vtmpatch2DInfo[frameIndex][patchIndex][0]) * occupancyResolution;
+      int64_t diff2DV = (g_vtmpatch2DInfo[refFrameIndex][bestPatchIndex][1] - g_vtmpatch2DInfo[frameIndex][patchIndex][1]) * occupancyResolution;
+
+      int diffTotalU = (int)(diff3DU + diff2DU);
+      int diffTotalV = (int)(diff3DV + diff2DV);
+
+      Mv startMV(diffTotalU << MV_FRACTIONAL_BITS_INTERNAL, diffTotalV << MV_FRACTIONAL_BITS_INTERNAL);
+      if (m_pcEncCfg->getMCTSEncConstraint())
+      {
+        MCTSHelper::clipMvToArea(startMV, pu.Y(), pu.cs->picture->mctsInfo.getTileArea(), *pu.cs->sps);
+      }
+      else
+      {
+        clipMv(startMV, pu.cu->lumaPos(), pu.cu->lumaSize(), *pu.cs->sps, *pu.cs->pps);
+      }
+      startMV.changePrecision(MV_PRECISION_INTERNAL, MV_PRECISION_QUARTER);
+      startMV.divideByPowerOf2(2);
+      xTZSearchHelp(cStruct, startMV.getHor(), startMV.getVer(), 0, 0);
+  	}
+  }
+#endif
+
   // test whether zero Mv is better start point than Median predictor
   if ( bTestZeroVector )
   {
diff --git a/source/Lib/EncoderLib/RateCtrl.cpp b/source/Lib/EncoderLib/RateCtrl.cpp
index 0e33acb..4eb0c3d 100644
--- a/source/Lib/EncoderLib/RateCtrl.cpp
+++ b/source/Lib/EncoderLib/RateCtrl.cpp
@@ -516,7 +516,7 @@ void EncRCGOP::create( EncRCSeq* encRCSeq, int numPic )
     }
     else
     {
-      msg( WARNING, "Warning: Current rate control does not support this coding configuration." );
+      msg( VTM_WARNING, "Warning: Current rate control does not support this coding configuration." );
     }
 
     xCalEquaCoeff( encRCSeq, lambdaRatio, equaCoeffA, equaCoeffB, encRCSeq->getGOPSize() );
@@ -1753,7 +1753,7 @@ void RateCtrl::init(int totalFrames, int targetBitrate, int frameRate, int GOPSi
     }
     else
     {
-      msg( WARNING, "\n hierarchical bit allocation is not support for the specified coding structure currently.\n" );
+      msg( VTM_WARNING, "\n hierarchical bit allocation is not support for the specified coding structure currently.\n" );
     }
   }
 
@@ -1944,7 +1944,7 @@ void RateCtrl::initHrdParam(const GeneralHrdParams* generalHrd, const OlsHrdPara
   m_cpbSize = (olsHrd->getCpbSizeValueMinus1(0, 0) + 1) << (4 + generalHrd->getCpbSizeScale());
   m_cpbState = (uint32_t)(m_cpbSize*fInitialCpbFullness);
   m_bufferingRate = (uint32_t)(((olsHrd->getBitRateValueMinus1(0, 0) + 1) << (6 + generalHrd->getBitRateScale())) / iFrameRate);
-  msg(NOTICE, "\nHRD - [Initial CPB state %6d] [CPB Size %6d] [Buffering Rate %6d]\n", m_cpbState, m_cpbSize, m_bufferingRate);
+  msg(VTM_NOTICE, "\nHRD - [Initial CPB state %6d] [CPB Size %6d] [Buffering Rate %6d]\n", m_cpbState, m_cpbSize, m_bufferingRate);
 }
 #endif
 
diff --git a/source/Lib/Utilities/VideoIOYuv.cpp b/source/Lib/Utilities/VideoIOYuv.cpp
index 8148d5e..235d9e2 100644
--- a/source/Lib/Utilities/VideoIOYuv.cpp
+++ b/source/Lib/Utilities/VideoIOYuv.cpp
@@ -141,7 +141,7 @@ void VideoIOYuv::open( const std::string &fileName, bool bWriteMode, const int f
       }
       else
       {
-        EXIT( "ERROR: Cannot read a yuv file of bit depth greater than 16" );
+        EXIT( "VTM_ERROR: Cannot read a yuv file of bit depth greater than 16" );
       }
     }
   }
@@ -1057,7 +1057,7 @@ bool VideoIOYuv::write( uint32_t orgWidth, uint32_t orgHeight, const CPelUnitBuf
 
   if ((width444 == 0) || (height444 == 0))
   {
-    msg( WARNING, "\nWarning: writing %d x %d luma sample output picture!", width444, height444);
+    msg( VTM_WARNING, "\nWarning: writing %d x %d luma sample output picture!", width444, height444);
   }
 
   for(uint32_t comp=0; retval && comp < ::getNumberValidComponents(format); comp++)
@@ -1167,7 +1167,7 @@ bool VideoIOYuv::write( const CPelUnitBuf& picTop, const CPelUnitBuf& picBottom,
 
     if ((width444 == 0) || (height444 == 0))
     {
-      msg( WARNING, "\nWarning: writing %d x %d luma sample output picture!", width444, height444);
+      msg( VTM_WARNING, "\nWarning: writing %d x %d luma sample output picture!", width444, height444);
     }
 
     const uint32_t csx = ::getComponentScaleX(compID, dstChrFormat );
