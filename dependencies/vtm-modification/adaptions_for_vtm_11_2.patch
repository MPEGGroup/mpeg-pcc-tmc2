diff --git a/source/App/BitstreamExtractorApp/BitstreamExtractorApp.cpp b/source/App/BitstreamExtractorApp/BitstreamExtractorApp.cpp
index fdc5a03e..5f4d9085 100644
--- a/source/App/BitstreamExtractorApp/BitstreamExtractorApp.cpp
+++ b/source/App/BitstreamExtractorApp/BitstreamExtractorApp.cpp
@@ -54,44 +54,44 @@ BitstreamExtractorApp::BitstreamExtractorApp()
 
 void BitstreamExtractorApp::xPrintVPSInfo (VPS *vps)
 {
-  msg (VERBOSE, "VPS Info: \n");
-  msg (VERBOSE, "  VPS ID         : %d\n", vps->getVPSId());
-  msg (VERBOSE, "  Max layers     : %d\n", vps->getMaxLayers());
-  msg (VERBOSE, "  Max sub-layers : %d\n", vps->getMaxSubLayers());
-  msg (VERBOSE, "  Number of OLS  : %d\n", vps->getTotalNumOLSs());
+  msg (VTM_VERBOSE, "VPS Info: \n");
+  msg (VTM_VERBOSE, "  VPS ID         : %d\n", vps->getVPSId());
+  msg (VTM_VERBOSE, "  Max layers     : %d\n", vps->getMaxLayers());
+  msg (VTM_VERBOSE, "  Max sub-layers : %d\n", vps->getMaxSubLayers());
+  msg (VTM_VERBOSE, "  Number of OLS  : %d\n", vps->getTotalNumOLSs());
   for (int olsIdx=0; olsIdx < vps->getTotalNumOLSs(); olsIdx++)
   {
     vps->deriveTargetOutputLayerSet(olsIdx);
-    msg (VERBOSE, "    OLS # %d\n", olsIdx);
-    msg (VERBOSE, "      Output layers: ");
+    msg (VTM_VERBOSE, "    OLS # %d\n", olsIdx);
+    msg (VTM_VERBOSE, "      Output layers: ");
     for( int i = 0; i < vps->m_targetOutputLayerIdSet.size(); i++ )
     {
-      msg (VERBOSE, "%d  ", vps->m_targetOutputLayerIdSet[i]);
+      msg (VTM_VERBOSE, "%d  ", vps->m_targetOutputLayerIdSet[i]);
     }
-    msg (VERBOSE, "\n");
+    msg (VTM_VERBOSE, "\n");
 
-    msg (VERBOSE, "      Target layers: ");
+    msg (VTM_VERBOSE, "      Target layers: ");
     for( int i = 0; i < vps->m_targetLayerIdSet.size(); i++ )
     {
-      msg (VERBOSE, "%d  ", vps->m_targetLayerIdSet[i]);
+      msg (VTM_VERBOSE, "%d  ", vps->m_targetLayerIdSet[i]);
     }
-    msg (VERBOSE, "\n");
+    msg (VTM_VERBOSE, "\n");
   }
 }
 
 void BitstreamExtractorApp::xPrintSubPicInfo (PPS *pps)
 {
-  msg (VERBOSE, "Subpic Info: \n");
-  msg (VERBOSE, "  SPS ID         : %d\n", pps->getSPSId());
-  msg (VERBOSE, "  PPS ID         : %d\n", pps->getPPSId());
-  msg (VERBOSE, "  Subpic enabled : %s\n", pps->getNumSubPics() > 1 ? "yes": "no" );
+  msg (VTM_VERBOSE, "Subpic Info: \n");
+  msg (VTM_VERBOSE, "  SPS ID         : %d\n", pps->getSPSId());
+  msg (VTM_VERBOSE, "  PPS ID         : %d\n", pps->getPPSId());
+  msg (VTM_VERBOSE, "  Subpic enabled : %s\n", pps->getNumSubPics() > 1 ? "yes": "no" );
   if ( pps->getNumSubPics() > 1)
   {
-    msg (VERBOSE, "    Number of subpics : %d\n", pps->getNumSubPics() );
+    msg (VTM_VERBOSE, "    Number of subpics : %d\n", pps->getNumSubPics() );
     for (int i=0; i<pps->getNumSubPics(); i++)
     {
       SubPic subP = pps->getSubPic(i);
-      msg ( VERBOSE, "      SubpicIdx #%d : TL=(%d, %d) Size CTU=(%d, %d) Size Pel=(%d, %d) SubpicID=%d\n", i, subP.getSubPicCtuTopLeftX(), subP.getSubPicCtuTopLeftY(),
+      msg ( VTM_VERBOSE, "      SubpicIdx #%d : TL=(%d, %d) Size CTU=(%d, %d) Size Pel=(%d, %d) SubpicID=%d\n", i, subP.getSubPicCtuTopLeftX(), subP.getSubPicCtuTopLeftY(),
             subP.getSubPicWidthInCTUs(), subP.getSubPicHeightInCTUs(), subP.getSubPicWidthInLumaSample(), subP.getSubPicHeightInLumaSample(), subP.getSubPicID());
     }
   }
@@ -130,7 +130,7 @@ bool BitstreamExtractorApp::xCheckSliceSubpicture(Slice &slice, int targetSubPic
   if (sps->getSubPicInfoPresentFlag())
   {
     // subpic ID is explicitly indicated
-    msg(VERBOSE, "found slice subpic id %d\n", slice.getSliceSubPicId());
+    msg(VTM_VERBOSE, "found slice subpic id %d\n", slice.getSliceSubPicId());
     return (targetSubPicId == slice.getSliceSubPicId());
   }
   else
@@ -160,7 +160,7 @@ bool BitstreamExtractorApp::xCheckSliceSubpicture(InputNALUnit &nalu, int target
   if (sps->getSubPicInfoPresentFlag())
   {
     // subpic ID is explicitly indicated
-    msg( VERBOSE, "found slice subpic id %d\n", slice.getSliceSubPicId());
+    msg( VTM_VERBOSE, "found slice subpic id %d\n", slice.getSliceSubPicId());
     return ( targetSubPicId == slice.getSliceSubPicId());
   }
   else
@@ -600,7 +600,7 @@ uint32_t BitstreamExtractorApp::decode()
        *  - two back-to-back start_code_prefixes
        *  - start_code_prefix immediately followed by EOF
        */
-      msg(WARNING, "Warning: Attempt to decode an empty NAL unit" );
+      msg(VTM_WARNING, "Warning: Attempt to decode an empty NAL unit" );
     }
     else
     {
@@ -669,7 +669,7 @@ uint32_t BitstreamExtractorApp::decode()
         m_parameterSetManager.storeSPS( sps, nalu.getBitstream().getFifo() );
         // get SPS back
         sps = m_parameterSetManager.getSPS(spsId);
-        msg (VERBOSE, "SPS Info: SPS ID = %d\n", spsId);
+        msg (VTM_VERBOSE, "SPS Info: SPS ID = %d\n", spsId);
 
         // example: just write the parsed SPS back to the stream
         // *** add modifications here ***
@@ -704,7 +704,7 @@ uint32_t BitstreamExtractorApp::decode()
         m_parameterSetManager.storePPS( pps, nalu.getBitstream().getFifo() );
         // get PPS back
         pps = m_parameterSetManager.getPPS(ppsId);
-        msg (VERBOSE, "PPS Info: PPS ID = %d\n", pps->getPPSId());
+        msg (VTM_VERBOSE, "PPS Info: PPS ID = %d\n", pps->getPPSId());
 
         SPS *sps = m_parameterSetManager.getSPS(pps->getSPSId());
         if ( nullptr == sps)
@@ -769,7 +769,7 @@ uint32_t BitstreamExtractorApp::decode()
         APS* aps = new APS();
         m_hlSynaxReader.setBitstream( &nalu.getBitstream() );
         m_hlSynaxReader.parseAPS( aps );
-        msg (VERBOSE, "APS Info: APS ID = %d Type = %d Layer = %d\n", aps->getAPSId(), aps->getAPSType(), nalu.m_nuhLayerId);
+        msg (VTM_VERBOSE, "APS Info: APS ID = %d Type = %d Layer = %d\n", aps->getAPSId(), aps->getAPSType(), nalu.m_nuhLayerId);
         int apsId = aps->getAPSId();
         int apsType = aps->getAPSType();
         // note: storeAPS may invalidate the aps pointer!
diff --git a/source/App/BitstreamExtractorApp/BitstreamExtractorAppCfg.cpp b/source/App/BitstreamExtractorApp/BitstreamExtractorAppCfg.cpp
index 8da48167..a3e254fd 100644
--- a/source/App/BitstreamExtractorApp/BitstreamExtractorAppCfg.cpp
+++ b/source/App/BitstreamExtractorApp/BitstreamExtractorAppCfg.cpp
@@ -80,7 +80,7 @@ namespace po = df::program_options_lite;
   ("TraceFile",                 tracingFile,                           string( "" ), "Tracing file" )
 #endif
 
-  ("Verbosity,v",               verbosity,                             (int)VERBOSE, "Specifies the level of the verboseness")
+  ("Verbosity,v",               verbosity,                             (int)VTM_VERBOSE, "Specifies the level of the verboseness")
   ("WarnUnknowParameter,w",     warnUnknownParameter,                  false,        "Warn for unknown configuration parameters instead of failing")
   ;
 
@@ -105,7 +105,7 @@ namespace po = df::program_options_lite;
   {
     std::string channelsList;
     g_trace_ctx->getChannelsList( channelsList );
-    msg( INFO, "\nAvailable tracing channels:\n\n%s\n", channelsList.c_str() );
+    msg( VTM_INFO, "\nAvailable tracing channels:\n\n%s\n", channelsList.c_str() );
   }
   DTRACE_UPDATE( g_trace_ctx, std::make_pair( "final", 1 ) );
 #endif
diff --git a/source/App/BitstreamExtractorApp/bitstreamextractormain.cpp b/source/App/BitstreamExtractorApp/bitstreamextractormain.cpp
index 3e7b381a..7ec98def 100644
--- a/source/App/BitstreamExtractorApp/bitstreamextractormain.cpp
+++ b/source/App/BitstreamExtractorApp/bitstreamextractormain.cpp
@@ -84,7 +84,7 @@ int main(int argc, char* argv[])
 #endif // !_DEBUG
     if( 0 != extractorApp->decode() )
     {
-      printf( "\n\n***ERROR*** A decoding mismatch occured: signalled md5sum does not match\n" );
+      printf( "\n\n***VTM_ERROR*** A decoding mismatch occured: signalled md5sum does not match\n" );
       returnCode = EXIT_FAILURE;
     }
 #ifndef _DEBUG
diff --git a/source/App/DecoderApp/DecApp.cpp b/source/App/DecoderApp/DecApp.cpp
index 227f27c9..5352916d 100644
--- a/source/App/DecoderApp/DecApp.cpp
+++ b/source/App/DecoderApp/DecApp.cpp
@@ -186,7 +186,7 @@ uint32_t DecApp::decode()
          *  - two back-to-back start_code_prefixes
          *  - start_code_prefix immediately followed by EOF
          */
-        msg( ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+        msg( VTM_ERROR, "Warning: Attempt to decode an empty NAL unit\n");
       }
       else
       {
@@ -281,7 +281,7 @@ uint32_t DecApp::decode()
       if (!loopFiltered[nalu.m_nuhLayerId] || bitstreamFile)
       {
         m_cDecLib.executeLoopFilters();
-        m_cDecLib.finishPicture(poc, pcListPic, INFO, m_newCLVS[nalu.m_nuhLayerId]);
+        m_cDecLib.finishPicture(poc, pcListPic, VTM_INFO, m_newCLVS[nalu.m_nuhLayerId]);
       }
       loopFiltered[nalu.m_nuhLayerId] = (nalu.m_nalUnitType == NAL_UNIT_EOS);
       if (nalu.m_nalUnitType == NAL_UNIT_EOS)
diff --git a/source/App/DecoderApp/DecAppCfg.cpp b/source/App/DecoderApp/DecAppCfg.cpp
index 036d7f54..2b4471e8 100644
--- a/source/App/DecoderApp/DecAppCfg.cpp
+++ b/source/App/DecoderApp/DecAppCfg.cpp
@@ -129,7 +129,7 @@ bool DecAppCfg::parseCfg( int argc, char* argv[] )
 
   for (list<const char*>::const_iterator it = argv_unhandled.begin(); it != argv_unhandled.end(); it++)
   {
-    msg( ERROR, "Unhandled argument ignored: `%s'\n", *it);
+    msg( VTM_ERROR, "Unhandled argument ignored: `%s'\n", *it);
   }
 
   if (argc == 1 || do_help)
@@ -153,7 +153,7 @@ bool DecAppCfg::parseCfg( int argc, char* argv[] )
   {
     std::string sChannelsList;
     g_trace_ctx->getChannelsList( sChannelsList );
-    msg( INFO, "\nAvailable tracing channels:\n\n%s\n", sChannelsList.c_str() );
+    msg( VTM_INFO, "\nAvailable tracing channels:\n\n%s\n", sChannelsList.c_str() );
   }
 #endif
 
@@ -167,13 +167,13 @@ bool DecAppCfg::parseCfg( int argc, char* argv[] )
   m_outputColourSpaceConvert = stringToInputColourSpaceConvert(outputColourSpaceConvert, false);
   if (m_outputColourSpaceConvert>=NUMBER_INPUT_COLOUR_SPACE_CONVERSIONS)
   {
-    msg( ERROR, "Bad output colour space conversion string\n");
+    msg( VTM_ERROR, "Bad output colour space conversion string\n");
     return false;
   }
 
   if (m_bitstreamFileName.empty())
   {
-    msg( ERROR, "No input file specified, aborting\n");
+    msg( VTM_ERROR, "No input file specified, aborting\n");
     return false;
   }
 
@@ -190,7 +190,7 @@ bool DecAppCfg::parseCfg( int argc, char* argv[] )
         {
           if ( m_targetDecLayerIdSet.size() == 0 )
           {
-            msg( ERROR, "No LayerId could be parsed in file %s. Decoding all LayerIds as default.\n", cfg_TargetDecLayerIdSetFile.c_str() );
+            msg( VTM_ERROR, "No LayerId could be parsed in file %s. Decoding all LayerIds as default.\n", cfg_TargetDecLayerIdSetFile.c_str() );
           }
           break;
         }
@@ -201,7 +201,7 @@ bool DecAppCfg::parseCfg( int argc, char* argv[] )
         }
         if ( layerIdParsed < 0 || layerIdParsed >= MAX_NUM_LAYER_IDS )
         {
-          msg( ERROR, "Warning! Parsed LayerId %d is not within allowed range [0,%d]. Ignoring this value.\n", layerIdParsed, MAX_NUM_LAYER_IDS-1 );
+          msg( VTM_ERROR, "Warning! Parsed LayerId %d is not within allowed range [0,%d]. Ignoring this value.\n", layerIdParsed, MAX_NUM_LAYER_IDS-1 );
         }
         else
         {
@@ -212,13 +212,13 @@ bool DecAppCfg::parseCfg( int argc, char* argv[] )
       fclose (targetDecLayerIdSetFile);
       if ( m_targetDecLayerIdSet.size() > 0 && !isLayerIdZeroIncluded )
       {
-        msg( ERROR, "TargetDecLayerIdSet must contain LayerId=0, aborting" );
+        msg( VTM_ERROR, "TargetDecLayerIdSet must contain LayerId=0, aborting" );
         return false;
       }
     }
     else
     {
-      msg( ERROR, "File %s could not be opened. Using all LayerIds as default.\n", cfg_TargetDecLayerIdSetFile.c_str() );
+      msg( VTM_ERROR, "File %s could not be opened. Using all LayerIds as default.\n", cfg_TargetDecLayerIdSetFile.c_str() );
     }
   }
   if (m_iMaxTemporalLayer != 500)
diff --git a/source/App/DecoderApp/decmain.cpp b/source/App/DecoderApp/decmain.cpp
index 94264a0a..d4a251b0 100644
--- a/source/App/DecoderApp/decmain.cpp
+++ b/source/App/DecoderApp/decmain.cpp
@@ -90,7 +90,7 @@ int main(int argc, char* argv[])
 #endif // !_DEBUG
     if( 0 != pcDecApp->decode() )
     {
-      printf( "\n\n***ERROR*** A decoding mismatch occured: signalled md5sum does not match\n" );
+      printf( "\n\n***VTM_ERROR*** A decoding mismatch occured: signalled md5sum does not match\n" );
       returnCode = EXIT_FAILURE;
     }
 #ifndef _DEBUG
diff --git a/source/App/EncoderApp/EncAppCfg.cpp b/source/App/EncoderApp/EncAppCfg.cpp
index 7094cf7e..18a73d59 100644
--- a/source/App/EncoderApp/EncAppCfg.cpp
+++ b/source/App/EncoderApp/EncAppCfg.cpp
@@ -754,7 +754,7 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
   ("SummaryOutFilename",                              m_summaryOutFilename,                          string(), "Filename to use for producing summary output file. If empty, do not produce a file.")
   ("SummaryPicFilenameBase",                          m_summaryPicFilenameBase,                      string(), "Base filename to use for producing summary picture output files. The actual filenames used will have I.txt, P.txt and B.txt appended. If empty, do not produce a file.")
   ("SummaryVerboseness",                              m_summaryVerboseness,                                0u, "Specifies the level of the verboseness of the text output")
-  ("Verbosity,v",                                     m_verbosity,                               (int)VERBOSE, "Specifies the level of the verboseness")
+  ("Verbosity,v",                                     m_verbosity,                               (int)VTM_VERBOSE, "Specifies the level of the verboseness")
 
 #if JVET_O0756_CONFIG_HDRMETRICS || JVET_O0756_CALCULATE_HDRMETRICS
   ( "WhitePointDeltaE1",                              m_whitePointDeltaE[0],                            100.0, "1st reference white point value")
@@ -1557,7 +1557,7 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
 
   for (list<const char*>::const_iterator it = argv_unhandled.begin(); it != argv_unhandled.end(); it++)
   {
-    msg( ERROR, "Unhandled argument ignored: `%s'\n", *it);
+    msg( VTM_ERROR, "Unhandled argument ignored: `%s'\n", *it);
   }
 
   if (argc == 1 || do_help)
@@ -1730,17 +1730,17 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
   if (m_costMode != COST_LOSSLESS_CODING && m_mixedLossyLossless)
   {
     m_mixedLossyLossless = 0;
-    msg(WARNING, "*************************************************************************\n");
-    msg(WARNING, "* Mixed lossy lossles coding cannot enable in lossy costMode *\n");
-    msg(WARNING, "* Forcely disabled  m_mixedLossyLossless *\n");
-    msg(WARNING, "*************************************************************************\n");
+    msg(VTM_WARNING, "*************************************************************************\n");
+    msg(VTM_WARNING, "* Mixed lossy lossles coding cannot enable in lossy costMode *\n");
+    msg(VTM_WARNING, "* Forcely disabled  m_mixedLossyLossless *\n");
+    msg(VTM_WARNING, "*************************************************************************\n");
   }
   if (!m_mixedLossyLossless && cfgSliceLosslessArray.values.size() > 0)
   {
-    msg(WARNING, "*************************************************************************\n");
-    msg(WARNING, "* Mixed lossy lossles coding is not enabled *\n");
-    msg(WARNING, "* ignoring the value of SliceLosslessArray *\n");
-    msg(WARNING, "*************************************************************************\n");
+    msg(VTM_WARNING, "*************************************************************************\n");
+    msg(VTM_WARNING, "* Mixed lossy lossles coding is not enabled *\n");
+    msg(VTM_WARNING, "* ignoring the value of SliceLosslessArray *\n");
+    msg(VTM_WARNING, "*************************************************************************\n");
   }
 
   if (m_costMode == COST_LOSSLESS_CODING && m_mixedLossyLossless)
@@ -1955,11 +1955,11 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
       // conformance
       if ((m_confWinLeft == 0) && (m_confWinRight == 0) && (m_confWinTop == 0) && (m_confWinBottom == 0))
       {
-        msg( ERROR, "Warning: Conformance window enabled, but all conformance window parameters set to zero\n");
+        msg( VTM_ERROR, "Warning: Conformance window enabled, but all conformance window parameters set to zero\n");
       }
       if ((m_aiPad[1] != 0) || (m_aiPad[0]!=0))
       {
-        msg( ERROR, "Warning: Conformance window enabled, padding parameters will be ignored\n");
+        msg( VTM_ERROR, "Warning: Conformance window enabled, padding parameters will be ignored\n");
       }
       m_aiPad[1] = m_aiPad[0] = 0;
       break;
@@ -2150,12 +2150,12 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
   {
     if (!m_horCollocatedChromaFlag)
     {
-      msg(WARNING, "\nWARNING: HorCollocatedChroma is forced to 1 for chroma formats other than 4:2:0\n");
+      msg(VTM_WARNING, "\nWARNING: HorCollocatedChroma is forced to 1 for chroma formats other than 4:2:0\n");
       m_horCollocatedChromaFlag = true;
     }
     if (!m_verCollocatedChromaFlag)
     {
-      msg(WARNING, "\nWARNING: VerCollocatedChroma is forced to 1 for chroma formats other than 4:2:0\n");
+      msg(VTM_WARNING, "\nWARNING: VerCollocatedChroma is forced to 1 for chroma formats other than 4:2:0\n");
       m_verCollocatedChromaFlag = true;
     }
   }
@@ -2371,16 +2371,16 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
   {
     std::string sChannelsList;
     g_trace_ctx->getChannelsList( sChannelsList );
-    msg( INFO, "\n Using tracing channels:\n\n%s\n", sChannelsList.c_str() );
+    msg( VTM_INFO, "\n Using tracing channels:\n\n%s\n", sChannelsList.c_str() );
   }
 #endif
 
 #if ENABLE_QPA
   if (m_bUsePerceptQPA && !m_bUseAdaptiveQP && m_dualTree && (m_cbQpOffsetDualTree != 0 || m_crQpOffsetDualTree != 0 || m_cbCrQpOffsetDualTree != 0))
   {
-    msg( WARNING, "*************************************************************************\n" );
-    msg( WARNING, "* WARNING: chroma QPA on, ignoring nonzero dual-tree chroma QP offsets! *\n" );
-    msg( WARNING, "*************************************************************************\n" );
+    msg( VTM_WARNING, "*************************************************************************\n" );
+    msg( VTM_WARNING, "* VTM_WARNING: chroma QPA on, ignoring nonzero dual-tree chroma QP offsets! *\n" );
+    msg( VTM_WARNING, "*************************************************************************\n" );
   }
 
 #if ENABLE_QPA_SUB_CTU
@@ -2403,9 +2403,9 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
   if( ( ( int ) m_fQP < 38 ) && ( m_iGOPSize > 4 ) && m_bUsePerceptQPA && !m_bUseAdaptiveQP && ( m_iSourceHeight <= 1280 ) && ( m_iSourceWidth <= 2048 ) )
  #endif
   {
-    msg( WARNING, "*************************************************************************\n" );
-    msg( WARNING, "* WARNING: QPA on with large CTU for <=HD sequences, limiting CTU size! *\n" );
-    msg( WARNING, "*************************************************************************\n" );
+    msg( VTM_WARNING, "*************************************************************************\n" );
+    msg( VTM_WARNING, "* VTM_WARNING: QPA on with large CTU for <=HD sequences, limiting CTU size! *\n" );
+    msg( VTM_WARNING, "*************************************************************************\n" );
 
     m_uiCTUSize = m_uiMaxCUWidth;
     if( ( 1u << m_log2MaxTbSize         ) > m_uiCTUSize ) m_log2MaxTbSize--;
@@ -2514,7 +2514,7 @@ bool EncAppCfg::xCheckParameter()
   if (m_decodedPictureHashSEIType==HASHTYPE_NONE)
   {
     msg( DETAILS, "******************************************************************\n");
-    msg( DETAILS, "** WARNING: --SEIDecodedPictureHash is now disabled by default. **\n");
+    msg( DETAILS, "** VTM_WARNING: --SEIDecodedPictureHash is now disabled by default. **\n");
     msg( DETAILS, "**          Automatic verification of decoded pictures by a     **\n");
     msg( DETAILS, "**          decoder requires this option to be enabled.         **\n");
     msg( DETAILS, "******************************************************************\n");
@@ -2522,13 +2522,13 @@ bool EncAppCfg::xCheckParameter()
   if( m_profile==Profile::NONE )
   {
     msg( DETAILS, "***************************************************************************\n");
-    msg( DETAILS, "** WARNING: For conforming bitstreams a valid Profile value must be set! **\n");
+    msg( DETAILS, "** VTM_WARNING: For conforming bitstreams a valid Profile value must be set! **\n");
     msg( DETAILS, "***************************************************************************\n");
   }
   if( m_level==Level::NONE )
   {
     msg( DETAILS, "***************************************************************************\n");
-    msg( DETAILS, "** WARNING: For conforming bitstreams a valid Level value must be set!   **\n");
+    msg( DETAILS, "** VTM_WARNING: For conforming bitstreams a valid Level value must be set!   **\n");
     msg( DETAILS, "***************************************************************************\n");
   }
 
@@ -2565,9 +2565,9 @@ bool EncAppCfg::xCheckParameter()
   xConfirmPara( m_bUsePerceptQPA && m_lumaLevelToDeltaQPMapping.mode >= 2, "QPA and SharpDeltaQP mode 2 cannot be used together" );
   if( m_bUsePerceptQPA && m_lumaLevelToDeltaQPMapping.mode == LUMALVL_TO_DQP_AVG_METHOD )
   {
-    msg( WARNING, "*********************************************************************************\n" );
-    msg( WARNING, "** WARNING: Applying custom luma-based QPA with activity-based perceptual QPA! **\n" );
-    msg( WARNING, "*********************************************************************************\n" );
+    msg( VTM_WARNING, "*********************************************************************************\n" );
+    msg( VTM_WARNING, "** VTM_WARNING: Applying custom luma-based QPA with activity-based perceptual QPA! **\n" );
+    msg( VTM_WARNING, "*********************************************************************************\n" );
 
     m_lumaLevelToDeltaQPMapping.mode = LUMALVL_TO_DQP_NUM_MODES; // special QPA mode
   }
@@ -2598,10 +2598,10 @@ bool EncAppCfg::xCheckParameter()
 
   if( (m_internalBitDepth[CHANNEL_TYPE_LUMA] < m_inputBitDepth[CHANNEL_TYPE_LUMA]) || (m_internalBitDepth[CHANNEL_TYPE_CHROMA] < m_inputBitDepth[CHANNEL_TYPE_CHROMA]) )
   {
-      msg(WARNING, "*****************************************************************************\n");
-      msg(WARNING, "** WARNING: InternalBitDepth is set to the lower value than InputBitDepth! **\n");
-      msg(WARNING, "**          min_qp_prime_ts_minus4 will be clipped to 0 at the low end!    **\n");
-      msg(WARNING, "*****************************************************************************\n");
+      msg(VTM_WARNING, "*****************************************************************************\n");
+      msg(VTM_WARNING, "** VTM_WARNING: InternalBitDepth is set to the lower value than InputBitDepth! **\n");
+      msg(VTM_WARNING, "**          min_qp_prime_ts_minus4 will be clipped to 0 at the low end!    **\n");
+      msg(VTM_WARNING, "*****************************************************************************\n");
   }
 
 #if !RExt__HIGH_BIT_DEPTH_SUPPORT
@@ -2643,16 +2643,16 @@ bool EncAppCfg::xCheckParameter()
   {
     if (!m_frameFieldInfoSEIEnabled)
     {
-      msg( WARNING, "*************************************************************************************\n");
-      msg( WARNING, "** WARNING: Frame field information SEI should be enabled for field coding!        **\n");
-      msg( WARNING, "*************************************************************************************\n");
+      msg( VTM_WARNING, "*************************************************************************************\n");
+      msg( VTM_WARNING, "** VTM_WARNING: Frame field information SEI should be enabled for field coding!        **\n");
+      msg( VTM_WARNING, "*************************************************************************************\n");
     }
   }
   if ( m_pictureTimingSEIEnabled && (!m_bufferingPeriodSEIEnabled))
   {
-    msg( WARNING, "****************************************************************************\n");
-    msg( WARNING, "** WARNING: Picture Timing SEI requires Buffering Period SEI. Disabling.  **\n");
-    msg( WARNING, "****************************************************************************\n");
+    msg( VTM_WARNING, "****************************************************************************\n");
+    msg( VTM_WARNING, "** VTM_WARNING: Picture Timing SEI requires Buffering Period SEI. Disabling.  **\n");
+    msg( VTM_WARNING, "****************************************************************************\n");
     m_pictureTimingSEIEnabled = false;
   }
 
@@ -2693,7 +2693,7 @@ bool EncAppCfg::xCheckParameter()
 #endif
   if (m_lumaLevelToDeltaQPMapping.mode && m_lmcsEnabled)
   {
-    msg(WARNING, "For HDR-PQ, LMCS should be used mutual-exclusively with Luma-level-based Delta QP. If use LMCS, turn lumaDQP off.\n");
+    msg(VTM_WARNING, "For HDR-PQ, LMCS should be used mutual-exclusively with Luma-level-based Delta QP. If use LMCS, turn lumaDQP off.\n");
     m_lumaLevelToDeltaQPMapping.mode = LUMALVL_TO_DQP_DISABLED;
   }
   if (!m_lmcsEnabled)
@@ -2736,9 +2736,9 @@ bool EncAppCfg::xCheckParameter()
   xConfirmPara( m_crQpOffsetDualTree >  12,   "Max. Chroma Cr QP Offset for dual tree is  12" );
   if (m_dualTree && (m_chromaFormatIDC == CHROMA_400))
   {
-    msg( WARNING, "****************************************************************************\n");
-    msg( WARNING, "** WARNING: --DualITree has been disabled because the chromaFormat is 400 **\n");
-    msg( WARNING, "****************************************************************************\n");
+    msg( VTM_WARNING, "****************************************************************************\n");
+    msg( VTM_WARNING, "** VTM_WARNING: --DualITree has been disabled because the chromaFormat is 400 **\n");
+    msg( VTM_WARNING, "****************************************************************************\n");
     m_dualTree = false;
   }
   if (m_alf)
@@ -2753,16 +2753,16 @@ bool EncAppCfg::xCheckParameter()
   }  
   if (m_ccalf && (m_chromaFormatIDC == CHROMA_400))
   {
-    msg( WARNING, "****************************************************************************\n");
-    msg( WARNING, "** WARNING: --CCALF has been disabled because the chromaFormat is 400     **\n");
-    msg( WARNING, "****************************************************************************\n");
+    msg( VTM_WARNING, "****************************************************************************\n");
+    msg( VTM_WARNING, "** VTM_WARNING: --CCALF has been disabled because the chromaFormat is 400     **\n");
+    msg( VTM_WARNING, "****************************************************************************\n");
     m_ccalf = false;
   }
   if (m_JointCbCrMode && (m_chromaFormatIDC == CHROMA_400))
   {
-    msg( WARNING, "****************************************************************************\n");
-    msg( WARNING, "** WARNING: --JointCbCr has been disabled because the chromaFormat is 400 **\n");
-    msg( WARNING, "****************************************************************************\n");
+    msg( VTM_WARNING, "****************************************************************************\n");
+    msg( VTM_WARNING, "** VTM_WARNING: --JointCbCr has been disabled because the chromaFormat is 400 **\n");
+    msg( VTM_WARNING, "****************************************************************************\n");
     m_JointCbCrMode = false;
   }
   if (m_JointCbCrMode)
@@ -2844,7 +2844,7 @@ bool EncAppCfg::xCheckParameter()
   if ( m_Affine == 0 )
   {
     m_maxNumAffineMergeCand = m_sbTmvpEnableFlag ? 1 : 0;
-    if (m_PROF) msg(WARNING, "PROF is forcefully disabled when Affine is off \n");
+    if (m_PROF) msg(VTM_WARNING, "PROF is forcefully disabled when Affine is off \n");
     m_PROF = false;
   }
 
@@ -2987,7 +2987,7 @@ bool EncAppCfg::xCheckParameter()
     int curPOC = ((checkGOP - 1) / m_iGOPSize)*m_iGOPSize * multipleFactor + m_RPLList0[curGOP].m_POC;
     if (m_RPLList0[curGOP].m_POC < 0 || m_RPLList1[curGOP].m_POC < 0)
     {
-      msg(WARNING, "\nError: found fewer Reference Picture Sets than GOPSize\n");
+      msg(VTM_WARNING, "\nError: found fewer Reference Picture Sets than GOPSize\n");
       errorGOP = true;
     }
     else
@@ -3023,7 +3023,7 @@ bool EncAppCfg::xCheckParameter()
           }
           if (!found)
           {
-            msg(WARNING, "\nError: ref pic %d is not available for GOP frame %d\n", m_RPLList0[curGOP].m_deltaRefPics[i], curGOP + 1);
+            msg(VTM_WARNING, "\nError: ref pic %d is not available for GOP frame %d\n", m_RPLList0[curGOP].m_deltaRefPics[i], curGOP + 1);
             errorGOP = true;
           }
         }
@@ -3591,7 +3591,7 @@ bool EncAppCfg::xCheckParameter()
     {
       if ( m_RCInitialQP == 0 )
       {
-        msg( WARNING, "\nInitial QP for rate control is not specified. Reset not to use force intra QP!" );
+        msg( VTM_WARNING, "\nInitial QP for rate control is not specified. Reset not to use force intra QP!" );
         m_RCForceIntraQP = false;
       }
     }
@@ -3774,7 +3774,7 @@ const char *profileToString(const Profile::Name profile)
   }
 
   //if we get here, we didn't find this profile in the list - so there is an error
-  EXIT( "ERROR: Unknown profile \"" << profile << "\" in profileToString" );
+  EXIT( "VTM_ERROR: Unknown profile \"" << profile << "\" in profileToString" );
   return "";
 }
 
@@ -3915,163 +3915,163 @@ void EncAppCfg::xPrintParameter()
   msg( DETAILS, "Max Num IBC Merge Candidates           : %d\n", m_maxNumIBCMergeCand );
   msg( DETAILS, "\n");
 
-  msg( VERBOSE, "TOOL CFG: ");
-  msg( VERBOSE, "IBD:%d ", ((m_internalBitDepth[CHANNEL_TYPE_LUMA] > m_MSBExtendedBitDepth[CHANNEL_TYPE_LUMA]) || (m_internalBitDepth[CHANNEL_TYPE_CHROMA] > m_MSBExtendedBitDepth[CHANNEL_TYPE_CHROMA])));
-  msg( VERBOSE, "HAD:%d ", m_bUseHADME                          );
-  msg( VERBOSE, "RDQ:%d ", m_useRDOQ                            );
-  msg( VERBOSE, "RDQTS:%d ", m_useRDOQTS                        );
-  msg( VERBOSE, "RDpenalty:%d ", m_rdPenalty                    );
+  msg( VTM_VERBOSE, "TOOL CFG: ");
+  msg( VTM_VERBOSE, "IBD:%d ", ((m_internalBitDepth[CHANNEL_TYPE_LUMA] > m_MSBExtendedBitDepth[CHANNEL_TYPE_LUMA]) || (m_internalBitDepth[CHANNEL_TYPE_CHROMA] > m_MSBExtendedBitDepth[CHANNEL_TYPE_CHROMA])));
+  msg( VTM_VERBOSE, "HAD:%d ", m_bUseHADME                          );
+  msg( VTM_VERBOSE, "RDQ:%d ", m_useRDOQ                            );
+  msg( VTM_VERBOSE, "RDQTS:%d ", m_useRDOQTS                        );
+  msg( VTM_VERBOSE, "RDpenalty:%d ", m_rdPenalty                    );
 #if SHARP_LUMA_DELTA_QP
-  msg( VERBOSE, "LQP:%d ", m_lumaLevelToDeltaQPMapping.mode     );
+  msg( VTM_VERBOSE, "LQP:%d ", m_lumaLevelToDeltaQPMapping.mode     );
 #endif
-  msg( VERBOSE, "SQP:%d ", m_uiDeltaQpRD                        );
-  msg( VERBOSE, "ASR:%d ", m_bUseASR                            );
-  msg( VERBOSE, "MinSearchWindow:%d ", m_minSearchWindow        );
-  msg( VERBOSE, "RestrictMESampling:%d ", m_bRestrictMESampling );
-  msg( VERBOSE, "FEN:%d ", int(m_fastInterSearchMode)           );
-  msg( VERBOSE, "ECU:%d ", m_bUseEarlyCU                        );
-  msg( VERBOSE, "FDM:%d ", m_useFastDecisionForMerge            );
-  msg( VERBOSE, "ESD:%d ", m_useEarlySkipDetection              );
-  msg( VERBOSE, "TransformSkip:%d ",     m_useTransformSkip     );
-  msg( VERBOSE, "TransformSkipFast:%d ", m_useTransformSkipFast );
-  msg( VERBOSE, "TransformSkipLog2MaxSize:%d ", m_log2MaxTransformSkipBlockSize);
-  msg(VERBOSE, "ChromaTS:%d ", m_useChromaTS);
-  msg( VERBOSE, "BDPCM:%d ", m_useBDPCM                         );
-  msg( VERBOSE, "Tiles: %dx%d ", m_numTileCols, m_numTileRows );
-  msg( VERBOSE, "Slices: %d ", m_numSlicesInPic);
-  msg( VERBOSE, "MCTS:%d ", m_MCTSEncConstraint );
-  msg( VERBOSE, "SAO:%d ", (m_bUseSAO)?(1):(0));
-  msg( VERBOSE, "ALF:%d ", m_alf ? 1 : 0 );
-  msg( VERBOSE, "CCALF:%d ", m_ccalf ? 1 : 0 );
-
-  msg( VERBOSE, "WPP:%d ", (int)m_useWeightedPred);
-  msg( VERBOSE, "WPB:%d ", (int)m_useWeightedBiPred);
-  msg( VERBOSE, "PME:%d ", m_log2ParallelMergeLevel);
+  msg( VTM_VERBOSE, "SQP:%d ", m_uiDeltaQpRD                        );
+  msg( VTM_VERBOSE, "ASR:%d ", m_bUseASR                            );
+  msg( VTM_VERBOSE, "MinSearchWindow:%d ", m_minSearchWindow        );
+  msg( VTM_VERBOSE, "RestrictMESampling:%d ", m_bRestrictMESampling );
+  msg( VTM_VERBOSE, "FEN:%d ", int(m_fastInterSearchMode)           );
+  msg( VTM_VERBOSE, "ECU:%d ", m_bUseEarlyCU                        );
+  msg( VTM_VERBOSE, "FDM:%d ", m_useFastDecisionForMerge            );
+  msg( VTM_VERBOSE, "ESD:%d ", m_useEarlySkipDetection              );
+  msg( VTM_VERBOSE, "TransformSkip:%d ",     m_useTransformSkip     );
+  msg( VTM_VERBOSE, "TransformSkipFast:%d ", m_useTransformSkipFast );
+  msg( VTM_VERBOSE, "TransformSkipLog2MaxSize:%d ", m_log2MaxTransformSkipBlockSize);
+  msg(VTM_VERBOSE, "ChromaTS:%d ", m_useChromaTS);
+  msg( VTM_VERBOSE, "BDPCM:%d ", m_useBDPCM                         );
+  msg( VTM_VERBOSE, "Tiles: %dx%d ", m_numTileCols, m_numTileRows );
+  msg( VTM_VERBOSE, "Slices: %d ", m_numSlicesInPic);
+  msg( VTM_VERBOSE, "MCTS:%d ", m_MCTSEncConstraint );
+  msg( VTM_VERBOSE, "SAO:%d ", (m_bUseSAO)?(1):(0));
+  msg( VTM_VERBOSE, "ALF:%d ", m_alf ? 1 : 0 );
+  msg( VTM_VERBOSE, "CCALF:%d ", m_ccalf ? 1 : 0 );
+
+  msg( VTM_VERBOSE, "WPP:%d ", (int)m_useWeightedPred);
+  msg( VTM_VERBOSE, "WPB:%d ", (int)m_useWeightedBiPred);
+  msg( VTM_VERBOSE, "PME:%d ", m_log2ParallelMergeLevel);
   const int iWaveFrontSubstreams = m_entropyCodingSyncEnabledFlag ? (m_iSourceHeight + m_uiMaxCUHeight - 1) / m_uiMaxCUHeight : 1;
-  msg( VERBOSE, " WaveFrontSynchro:%d WaveFrontSubstreams:%d", m_entropyCodingSyncEnabledFlag?1:0, iWaveFrontSubstreams);
-  msg( VERBOSE, " ScalingList:%d ", m_useScalingListId );
-  msg( VERBOSE, "TMVPMode:%d ", m_TMVPModeId );
-  msg( VERBOSE, " DQ:%d ", m_depQuantEnabledFlag);
-  msg( VERBOSE, " SignBitHidingFlag:%d ", m_signDataHidingEnabledFlag);
-  msg( VERBOSE, "RecalQP:%d ", m_recalculateQPAccordingToLambda ? 1 : 0 );
-
-  {
-    msg( VERBOSE, "\nTOOL CFG: " );
-    msg( VERBOSE, "LFNST:%d ", m_LFNST );
-    msg( VERBOSE, "MMVD:%d ", m_MMVD);
-    msg( VERBOSE, "Affine:%d ", m_Affine );
+  msg( VTM_VERBOSE, " WaveFrontSynchro:%d WaveFrontSubstreams:%d", m_entropyCodingSyncEnabledFlag?1:0, iWaveFrontSubstreams);
+  msg( VTM_VERBOSE, " ScalingList:%d ", m_useScalingListId );
+  msg( VTM_VERBOSE, "TMVPMode:%d ", m_TMVPModeId );
+  msg( VTM_VERBOSE, " DQ:%d ", m_depQuantEnabledFlag);
+  msg( VTM_VERBOSE, " SignBitHidingFlag:%d ", m_signDataHidingEnabledFlag);
+  msg( VTM_VERBOSE, "RecalQP:%d ", m_recalculateQPAccordingToLambda ? 1 : 0 );
+
+  {
+    msg( VTM_VERBOSE, "\nTOOL CFG: " );
+    msg( VTM_VERBOSE, "LFNST:%d ", m_LFNST );
+    msg( VTM_VERBOSE, "MMVD:%d ", m_MMVD);
+    msg( VTM_VERBOSE, "Affine:%d ", m_Affine );
     if ( m_Affine )
     {
-      msg( VERBOSE, "AffineType:%d ", m_AffineType );
+      msg( VTM_VERBOSE, "AffineType:%d ", m_AffineType );
     }
-    msg(VERBOSE, "PROF:%d ", m_PROF);
-    msg(VERBOSE, "SbTMVP:%d ", m_sbTmvpEnableFlag);
-    msg( VERBOSE, "DualITree:%d ", m_dualTree );
-    msg( VERBOSE, "IMV:%d ", m_ImvMode );
-    msg( VERBOSE, "BIO:%d ", m_BIO );
-    msg( VERBOSE, "LMChroma:%d ", m_LMChroma );
-    msg( VERBOSE, "HorCollocatedChroma:%d ", m_horCollocatedChromaFlag );
-    msg( VERBOSE, "VerCollocatedChroma:%d ", m_verCollocatedChromaFlag );
-    msg( VERBOSE, "MTS: %1d(intra) %1d(inter) ", m_MTS & 1, ( m_MTS >> 1 ) & 1 );
-    msg( VERBOSE, "SBT:%d ", m_SBT );
-    msg( VERBOSE, "ISP:%d ", m_ISP );
-    msg( VERBOSE, "SMVD:%d ", m_SMVD );
-    msg( VERBOSE, "CompositeLTReference:%d ", m_compositeRefEnabled);
-    msg( VERBOSE, "Bcw:%d ", m_bcw );
-    msg( VERBOSE, "BcwFast:%d ", m_BcwFast );
+    msg(VTM_VERBOSE, "PROF:%d ", m_PROF);
+    msg(VTM_VERBOSE, "SbTMVP:%d ", m_sbTmvpEnableFlag);
+    msg( VTM_VERBOSE, "DualITree:%d ", m_dualTree );
+    msg( VTM_VERBOSE, "IMV:%d ", m_ImvMode );
+    msg( VTM_VERBOSE, "BIO:%d ", m_BIO );
+    msg( VTM_VERBOSE, "LMChroma:%d ", m_LMChroma );
+    msg( VTM_VERBOSE, "HorCollocatedChroma:%d ", m_horCollocatedChromaFlag );
+    msg( VTM_VERBOSE, "VerCollocatedChroma:%d ", m_verCollocatedChromaFlag );
+    msg( VTM_VERBOSE, "MTS: %1d(intra) %1d(inter) ", m_MTS & 1, ( m_MTS >> 1 ) & 1 );
+    msg( VTM_VERBOSE, "SBT:%d ", m_SBT );
+    msg( VTM_VERBOSE, "ISP:%d ", m_ISP );
+    msg( VTM_VERBOSE, "SMVD:%d ", m_SMVD );
+    msg( VTM_VERBOSE, "CompositeLTReference:%d ", m_compositeRefEnabled);
+    msg( VTM_VERBOSE, "Bcw:%d ", m_bcw );
+    msg( VTM_VERBOSE, "BcwFast:%d ", m_BcwFast );
 #if LUMA_ADAPTIVE_DEBLOCKING_FILTER_QP_OFFSET
-    msg( VERBOSE, "LADF:%d ", m_LadfEnabed );
+    msg( VTM_VERBOSE, "LADF:%d ", m_LadfEnabed );
 #endif
-    msg(VERBOSE, "CIIP:%d ", m_ciip);
-    msg( VERBOSE, "Geo:%d ", m_Geo );
+    msg(VTM_VERBOSE, "CIIP:%d ", m_ciip);
+    msg( VTM_VERBOSE, "Geo:%d ", m_Geo );
     m_allowDisFracMMVD = m_MMVD ? m_allowDisFracMMVD : false;
     if ( m_MMVD )
-      msg(VERBOSE, "AllowDisFracMMVD:%d ", m_allowDisFracMMVD);
-    msg( VERBOSE, "AffineAmvr:%d ", m_AffineAmvr );
+      msg(VTM_VERBOSE, "AllowDisFracMMVD:%d ", m_allowDisFracMMVD);
+    msg( VTM_VERBOSE, "AffineAmvr:%d ", m_AffineAmvr );
     m_AffineAmvrEncOpt = m_AffineAmvr ? m_AffineAmvrEncOpt : false;
-    msg( VERBOSE, "AffineAmvrEncOpt:%d ", m_AffineAmvrEncOpt );
-    msg(VERBOSE, "DMVR:%d ", m_DMVR);
-    msg(VERBOSE, "MmvdDisNum:%d ", m_MmvdDisNum);
-    msg(VERBOSE, "JointCbCr:%d ", m_JointCbCrMode);
+    msg( VTM_VERBOSE, "AffineAmvrEncOpt:%d ", m_AffineAmvrEncOpt );
+    msg(VTM_VERBOSE, "DMVR:%d ", m_DMVR);
+    msg(VTM_VERBOSE, "MmvdDisNum:%d ", m_MmvdDisNum);
+    msg(VTM_VERBOSE, "JointCbCr:%d ", m_JointCbCrMode);
   }
   m_useColorTrans = (m_chromaFormatIDC == CHROMA_444) ? m_useColorTrans : 0u;
-  msg(VERBOSE, "ACT:%d ", m_useColorTrans);
-    msg(VERBOSE, "PLT:%d ", m_PLTMode);
-    msg(VERBOSE, "IBC:%d ", m_IBCMode);
-  msg( VERBOSE, "HashME:%d ", m_HashME );
-  msg( VERBOSE, "WrapAround:%d ", m_wrapAround);
+  msg(VTM_VERBOSE, "ACT:%d ", m_useColorTrans);
+    msg(VTM_VERBOSE, "PLT:%d ", m_PLTMode);
+    msg(VTM_VERBOSE, "IBC:%d ", m_IBCMode);
+  msg( VTM_VERBOSE, "HashME:%d ", m_HashME );
+  msg( VTM_VERBOSE, "WrapAround:%d ", m_wrapAround);
   if( m_wrapAround )
   {
-    msg( VERBOSE, "WrapAroundOffset:%d ", m_wrapAroundOffset );
+    msg( VTM_VERBOSE, "WrapAroundOffset:%d ", m_wrapAroundOffset );
   }
   // ADD_NEW_TOOL (add some output indicating the usage of tools)
-  msg( VERBOSE, "VirtualBoundariesEnabledFlag:%d ", m_virtualBoundariesEnabledFlag );
-  msg( VERBOSE, "VirtualBoundariesPresentInSPSFlag:%d ", m_virtualBoundariesPresentFlag );
+  msg( VTM_VERBOSE, "VirtualBoundariesEnabledFlag:%d ", m_virtualBoundariesEnabledFlag );
+  msg( VTM_VERBOSE, "VirtualBoundariesPresentInSPSFlag:%d ", m_virtualBoundariesPresentFlag );
   if( m_virtualBoundariesPresentFlag )
   {
-    msg(VERBOSE, "vertical virtual boundaries:[");
+    msg(VTM_VERBOSE, "vertical virtual boundaries:[");
     for (unsigned i = 0; i < m_numVerVirtualBoundaries; i++)
     {
-      msg(VERBOSE, " %d", m_virtualBoundariesPosX[i]);
+      msg(VTM_VERBOSE, " %d", m_virtualBoundariesPosX[i]);
     }
-    msg(VERBOSE, " ] horizontal virtual boundaries:[");
+    msg(VTM_VERBOSE, " ] horizontal virtual boundaries:[");
     for (unsigned i = 0; i < m_numHorVirtualBoundaries; i++)
     {
-      msg(VERBOSE, " %d", m_virtualBoundariesPosY[i]);
+      msg(VTM_VERBOSE, " %d", m_virtualBoundariesPosY[i]);
     }
-    msg(VERBOSE, " ] ");
+    msg(VTM_VERBOSE, " ] ");
   }
-    msg(VERBOSE, "Reshape:%d ", m_lmcsEnabled);
+    msg(VTM_VERBOSE, "Reshape:%d ", m_lmcsEnabled);
     if (m_lmcsEnabled)
     {
-      msg(VERBOSE, "(Signal:%s ", m_reshapeSignalType == 0 ? "SDR" : (m_reshapeSignalType == 2 ? "HDR-HLG" : "HDR-PQ"));
-      msg(VERBOSE, "Opt:%d", m_adpOption);
-      if (m_adpOption > 0) { msg(VERBOSE, " CW:%d", m_initialCW); }
-      msg(VERBOSE, " CSoffset:%d", m_CSoffset);
-      msg(VERBOSE, ") ");
+      msg(VTM_VERBOSE, "(Signal:%s ", m_reshapeSignalType == 0 ? "SDR" : (m_reshapeSignalType == 2 ? "HDR-HLG" : "HDR-PQ"));
+      msg(VTM_VERBOSE, "Opt:%d", m_adpOption);
+      if (m_adpOption > 0) { msg(VTM_VERBOSE, " CW:%d", m_initialCW); }
+      msg(VTM_VERBOSE, " CSoffset:%d", m_CSoffset);
+      msg(VTM_VERBOSE, ") ");
     }
-    msg(VERBOSE, "MRL:%d ", m_MRL);
-    msg(VERBOSE, "MIP:%d ", m_MIP);
-    msg(VERBOSE, "EncDbOpt:%d ", m_encDbOpt);
-  msg( VERBOSE, "\nFAST TOOL CFG: " );
-  msg( VERBOSE, "LCTUFast:%d ", m_useFastLCTU );
-  msg( VERBOSE, "FastMrg:%d ", m_useFastMrg );
-  msg( VERBOSE, "PBIntraFast:%d ", m_usePbIntraFast );
-  if( m_ImvMode ) msg( VERBOSE, "IMV4PelFast:%d ", m_Imv4PelFast );
-  if( m_MTS ) msg( VERBOSE, "MTSMaxCand: %1d(intra) %1d(inter) ", m_MTSIntraMaxCand, m_MTSInterMaxCand );
-  if( m_ISP ) msg( VERBOSE, "ISPFast:%d ", m_useFastISP );
-  if( m_LFNST ) msg( VERBOSE, "FastLFNST:%d ", m_useFastLFNST );
-  msg( VERBOSE, "AMaxBT:%d ", m_useAMaxBT );
-  msg( VERBOSE, "E0023FastEnc:%d ", m_e0023FastEnc );
-  msg( VERBOSE, "ContentBasedFastQtbt:%d ", m_contentBasedFastQtbt );
-  msg( VERBOSE, "UseNonLinearAlfLuma:%d ", m_useNonLinearAlfLuma );
-  msg( VERBOSE, "UseNonLinearAlfChroma:%d ", m_useNonLinearAlfChroma );
-  msg( VERBOSE, "MaxNumAlfAlternativesChroma:%d ", m_maxNumAlfAlternativesChroma );
-  if( m_MIP ) msg(VERBOSE, "FastMIP:%d ", m_useFastMIP);
-  msg( VERBOSE, "FastLocalDualTree:%d ", m_fastLocalDualTreeMode );
-
-  msg( VERBOSE, "NumSplitThreads:%d ", m_numSplitThreads );
+    msg(VTM_VERBOSE, "MRL:%d ", m_MRL);
+    msg(VTM_VERBOSE, "MIP:%d ", m_MIP);
+    msg(VTM_VERBOSE, "EncDbOpt:%d ", m_encDbOpt);
+  msg( VTM_VERBOSE, "\nFAST TOOL CFG: " );
+  msg( VTM_VERBOSE, "LCTUFast:%d ", m_useFastLCTU );
+  msg( VTM_VERBOSE, "FastMrg:%d ", m_useFastMrg );
+  msg( VTM_VERBOSE, "PBIntraFast:%d ", m_usePbIntraFast );
+  if( m_ImvMode ) msg( VTM_VERBOSE, "IMV4PelFast:%d ", m_Imv4PelFast );
+  if( m_MTS ) msg( VTM_VERBOSE, "MTSMaxCand: %1d(intra) %1d(inter) ", m_MTSIntraMaxCand, m_MTSInterMaxCand );
+  if( m_ISP ) msg( VTM_VERBOSE, "ISPFast:%d ", m_useFastISP );
+  if( m_LFNST ) msg( VTM_VERBOSE, "FastLFNST:%d ", m_useFastLFNST );
+  msg( VTM_VERBOSE, "AMaxBT:%d ", m_useAMaxBT );
+  msg( VTM_VERBOSE, "E0023FastEnc:%d ", m_e0023FastEnc );
+  msg( VTM_VERBOSE, "ContentBasedFastQtbt:%d ", m_contentBasedFastQtbt );
+  msg( VTM_VERBOSE, "UseNonLinearAlfLuma:%d ", m_useNonLinearAlfLuma );
+  msg( VTM_VERBOSE, "UseNonLinearAlfChroma:%d ", m_useNonLinearAlfChroma );
+  msg( VTM_VERBOSE, "MaxNumAlfAlternativesChroma:%d ", m_maxNumAlfAlternativesChroma );
+  if( m_MIP ) msg(VTM_VERBOSE, "FastMIP:%d ", m_useFastMIP);
+  msg( VTM_VERBOSE, "FastLocalDualTree:%d ", m_fastLocalDualTreeMode );
+
+  msg( VTM_VERBOSE, "NumSplitThreads:%d ", m_numSplitThreads );
   if( m_numSplitThreads > 1 )
   {
-    msg( VERBOSE, "ForceSingleSplitThread:%d ", m_forceSplitSequential );
+    msg( VTM_VERBOSE, "ForceSingleSplitThread:%d ", m_forceSplitSequential );
   }
-  msg( VERBOSE, "NumWppThreads:%d+%d ", m_numWppThreads, m_numWppExtraLines );
-  msg( VERBOSE, "EnsureWppBitEqual:%d ", m_ensureWppBitEqual );
+  msg( VTM_VERBOSE, "NumWppThreads:%d+%d ", m_numWppThreads, m_numWppExtraLines );
+  msg( VTM_VERBOSE, "EnsureWppBitEqual:%d ", m_ensureWppBitEqual );
 
   if (m_resChangeInClvsEnabled)
   {
-    msg( VERBOSE, "RPR:(%1.2lfx, %1.2lfx)|%d ", m_scalingRatioHor, m_scalingRatioVer, m_switchPocPeriod );
+    msg( VTM_VERBOSE, "RPR:(%1.2lfx, %1.2lfx)|%d ", m_scalingRatioHor, m_scalingRatioVer, m_switchPocPeriod );
   }
   else
   {
-    msg( VERBOSE, "RPR:%d ", 0 );
+    msg( VTM_VERBOSE, "RPR:%d ", 0 );
   }
-  msg(VERBOSE, "TemporalFilter:%d ", m_gopBasedTemporalFilterEnabled);
+  msg(VTM_VERBOSE, "TemporalFilter:%d ", m_gopBasedTemporalFilterEnabled);
 #if EXTENSION_360_VIDEO
   m_ext360.outputConfigurationSummary();
 #endif
 
-  msg( VERBOSE, "\n\n");
+  msg( VTM_VERBOSE, "\n\n");
 
   msg( NOTICE, "\n");
 
@@ -4120,7 +4120,7 @@ bool confirmPara(bool bflag, const char* message)
     return false;
   }
 
-  msg( ERROR, "Error: %s\n",message);
+  msg( VTM_ERROR, "Error: %s\n",message);
   return true;
 }
 
diff --git a/source/App/SEIRemovalApp/seiremovalmain.cpp b/source/App/SEIRemovalApp/seiremovalmain.cpp
index 309bb72c..f797e2f6 100644
--- a/source/App/SEIRemovalApp/seiremovalmain.cpp
+++ b/source/App/SEIRemovalApp/seiremovalmain.cpp
@@ -90,7 +90,7 @@ int main(int argc, char* argv[])
 #endif // !_DEBUG
     if( 0 != pcDecApp->decode() )
     {
-      printf( "\n\n***ERROR*** A decoding mismatch occured: signalled md5sum does not match\n" );
+      printf( "\n\n***VTM_ERROR*** A decoding mismatch occured: signalled md5sum does not match\n" );
       returnCode = EXIT_FAILURE;
     }
 #ifndef _DEBUG
diff --git a/source/App/StreamMergeApp/StreamMergeApp.cpp b/source/App/StreamMergeApp/StreamMergeApp.cpp
index f7b6acf1..13312a09 100644
--- a/source/App/StreamMergeApp/StreamMergeApp.cpp
+++ b/source/App/StreamMergeApp/StreamMergeApp.cpp
@@ -229,7 +229,7 @@ bool StreamMergeApp::isNewPicture(std::ifstream *bitstreamFile, InputByteStream
     byteStreamNALUnit(*bytestream, nalu.getBitstream().getFifo(), stats);
     if (nalu.getBitstream().getFifo().empty())
     {
-      msg(ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+      msg(VTM_ERROR, "Warning: Attempt to decode an empty NAL unit\n");
     }
     else
     {
@@ -325,7 +325,7 @@ bool StreamMergeApp::isNewAccessUnit(bool newPicture, std::ifstream *bitstreamFi
     byteStreamNALUnit(*bytestream, nalu.getBitstream().getFifo(), stats);
     if (nalu.getBitstream().getFifo().empty())
     {
-      msg(ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+      msg(VTM_ERROR, "Warning: Attempt to decode an empty NAL unit\n");
     }
     else
     {
@@ -414,7 +414,7 @@ bool StreamMergeApp::preInjectNalu(MergeLayer &layer, InputNALUnit &inNalu, Outp
     layer.psManager.storeVPS(vps, hlsReader.getBitstream()->getFifo());
     hlsWriter.codeVPS(vps);
     outNalu.m_nalUnitType = NAL_UNIT_VPS;
-    msg(INFO, " layer %i, nalu type VPS%i injected\n", layer.id, vps->getVPSId());
+    msg(VTM_INFO, " layer %i, nalu type VPS%i injected\n", layer.id, vps->getVPSId());
     return true;
   }
   default:
@@ -433,7 +433,7 @@ void StreamMergeApp::decodeAndRewriteNalu(MergeLayer &layer, InputNALUnit &inNal
   hlsReader.setBitstream(&inNalu.getBitstream());
   hlsWriter.setBitstream(&outNalu.m_Bitstream);
 
-  msg(INFO, " layer %i, nalu type ", layer.id);
+  msg(VTM_INFO, " layer %i, nalu type ", layer.id);
   switch (inNalu.m_nalUnitType)
   {
   case NAL_UNIT_SPS:
@@ -454,7 +454,7 @@ void StreamMergeApp::decodeAndRewriteNalu(MergeLayer &layer, InputNALUnit &inNal
     layer.oldIDsPsManager.storeSPS(oldSps, hlsReader.getBitstream()->getFifo());
     layer.psManager.storeSPS(newSps, hlsReader.getBitstream()->getFifo());
     hlsWriter.codeSPS(newSps);
-    msg(INFO, "SPS%i", newSps->getSPSId());
+    msg(VTM_INFO, "SPS%i", newSps->getSPSId());
     break;
   }
   case NAL_UNIT_PPS:
@@ -475,7 +475,7 @@ void StreamMergeApp::decodeAndRewriteNalu(MergeLayer &layer, InputNALUnit &inNal
     layer.oldIDsPsManager.storePPS(oldPps, hlsReader.getBitstream()->getFifo());
     layer.psManager.storePPS(newPps, hlsReader.getBitstream()->getFifo());
     hlsWriter.codePPS(newPps);
-    msg(INFO, "PPS%i", newPps->getPPSId());
+    msg(VTM_INFO, "PPS%i", newPps->getPPSId());
     break;
   }
   case NAL_UNIT_PREFIX_APS:
@@ -488,7 +488,7 @@ void StreamMergeApp::decodeAndRewriteNalu(MergeLayer &layer, InputNALUnit &inNal
     aps->setAPSId(idIncrement);
     layer.psManager.storeAPS(aps, hlsReader.getBitstream()->getFifo());
     hlsWriter.codeAPS(aps);
-    msg(INFO, "APS%s%i", inNalu.m_nalUnitType == NAL_UNIT_PREFIX_APS ? "p" : "s", aps->getAPSId());
+    msg(VTM_INFO, "APS%s%i", inNalu.m_nalUnitType == NAL_UNIT_PREFIX_APS ? "p" : "s", aps->getAPSId());
     break;
   }
   case NAL_UNIT_PH:
@@ -501,24 +501,24 @@ void StreamMergeApp::decodeAndRewriteNalu(MergeLayer &layer, InputNALUnit &inNal
     slice.setPOC(ph.getPocLsb());
     ph.setPPSId(layer.ppsIdMapping.at(ph.getPPSId()));
     hlsWriter.codePictureHeader(&ph, true, &slice);
-    msg(INFO, "PH");
+    msg(VTM_INFO, "PH");
     break;
   }
   default:
   {
     if (inNalu.isVcl())
     {
-      msg(INFO, "VCL");
+      msg(VTM_INFO, "VCL");
     }
     else if (inNalu.isSei())
     {
-      msg(INFO, "SEI");
+      msg(VTM_INFO, "SEI");
     }
     else
     {
-      msg(INFO, "NNN");   // Any other NAL unit that is not handled above
+      msg(VTM_INFO, "NNN");   // Any other NAL unit that is not handled above
     }
-    msg(INFO, " with index %i", inNalu.m_nalUnitType);
+    msg(VTM_INFO, " with index %i", inNalu.m_nalUnitType);
     // Copy payload from input nalu to output nalu. Code copied from SubpicMergeApp::copyInputNaluToOutputNalu().
     vector<uint8_t> &inFifo  = inNalu.getBitstream().getFifo();
     vector<uint8_t> &outFifo = outNalu.m_Bitstream.getFIFO();
@@ -526,7 +526,7 @@ void StreamMergeApp::decodeAndRewriteNalu(MergeLayer &layer, InputNALUnit &inNal
     break;
   }
   }
-  msg(INFO, "\n");
+  msg(VTM_INFO, "\n");
 }
 
 uint32_t StreamMergeApp::mergeStreams()
@@ -593,7 +593,7 @@ uint32_t StreamMergeApp::mergeStreams()
 
         if (inNalu.getBitstream().getFifo().empty())
         {
-          msg(ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+          msg(VTM_ERROR, "Warning: Attempt to decode an empty NAL unit\n");
           continue;
         }
 
diff --git a/source/App/StreamMergeApp/StreamMergeMain.cpp b/source/App/StreamMergeApp/StreamMergeMain.cpp
index ad7c0473..fd9c065a 100644
--- a/source/App/StreamMergeApp/StreamMergeMain.cpp
+++ b/source/App/StreamMergeApp/StreamMergeMain.cpp
@@ -78,7 +78,7 @@ int main(int argc, char* argv[])
   // call decoding function
   if (0 != pStrMergeApp->mergeStreams())
   {
-    printf("\n\n***ERROR*** A merge error happened\n");
+    printf("\n\n***VTM_ERROR*** A merge error happened\n");
     returnCode = EXIT_FAILURE;
   }
 
diff --git a/source/App/SubpicMergeApp/SubpicMergeApp.cpp b/source/App/SubpicMergeApp/SubpicMergeApp.cpp
index 9c607eb0..fa88f57c 100644
--- a/source/App/SubpicMergeApp/SubpicMergeApp.cpp
+++ b/source/App/SubpicMergeApp/SubpicMergeApp.cpp
@@ -156,7 +156,7 @@ bool SubpicMergeApp::isNewPicture(std::ifstream *bitstreamFile, InputByteStream
     byteStreamNALUnit(*bytestream, nalu.getBitstream().getFifo(), stats);
     if (nalu.getBitstream().getFifo().empty())
     {
-      msg( ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+      msg( VTM_ERROR, "Warning: Attempt to decode an empty NAL unit\n");
     }
     else
     {
@@ -241,7 +241,7 @@ bool SubpicMergeApp::isNewPicture(std::ifstream *bitstreamFile, InputByteStream
 bool SubpicMergeApp::parseDCI(HLSyntaxReader &hlsReader, DCI &dci)
 {
   hlsReader.parseDCI(&dci);
-  msg( INFO, "  DCI");
+  msg( VTM_INFO, "  DCI");
   return true;
 }
 
@@ -254,7 +254,7 @@ int SubpicMergeApp::parseVPS(HLSyntaxReader &hlsReader, ParameterSetManager &psM
   hlsReader.parseVPS(vps);
   int vpsId = vps->getVPSId();
   psManager.storeVPS(vps, hlsReader.getBitstream()->getFifo());
-  msg( INFO, "  VPS%i", vpsId);
+  msg( VTM_INFO, "  VPS%i", vpsId);
   return vpsId;
 }
 
@@ -267,7 +267,7 @@ int SubpicMergeApp::parseSPS(HLSyntaxReader &hlsReader, ParameterSetManager &psM
   hlsReader.parseSPS(sps);
   int spsId = sps->getSPSId();
   psManager.storeSPS(sps, hlsReader.getBitstream()->getFifo());
-  msg( INFO, "  SPS%i", spsId);
+  msg( VTM_INFO, "  SPS%i", spsId);
   return spsId;
 }
 
@@ -280,7 +280,7 @@ int SubpicMergeApp::parsePPS(HLSyntaxReader &hlsReader, ParameterSetManager &psM
   hlsReader.parsePPS(pps);
   int ppsId = pps->getPPSId();
   psManager.storePPS(pps, hlsReader.getBitstream()->getFifo());
-  msg( INFO, "  PPS%i", ppsId);
+  msg( VTM_INFO, "  PPS%i", ppsId);
   return ppsId;
 }
 
@@ -294,7 +294,7 @@ void SubpicMergeApp::parseAPS(HLSyntaxReader &hlsReader, ParameterSetManager &ps
   apsId = aps->getAPSId();
   apsType = (int)aps->getAPSType();
   psManager.storeAPS(aps, hlsReader.getBitstream()->getFifo());
-  msg( INFO, "  APS%i", apsId);
+  msg( VTM_INFO, "  APS%i", apsId);
 }
 
 /**
@@ -304,7 +304,7 @@ void SubpicMergeApp::parsePictureHeader(HLSyntaxReader &hlsReader, PicHeader &pi
 {
   hlsReader.parsePictureHeader(&picHeader, &psManager, true);
   picHeader.setValid();
-  msg( INFO, "  PH");
+  msg( VTM_INFO, "  PH");
 }
 
 /**
@@ -328,7 +328,7 @@ void SubpicMergeApp::parseSliceHeader(HLSyntaxReader &hlsReader, InputNALUnit &n
     sliceData.write(inBs.readByte(), 8);
   }
 
-  msg( INFO, "  VCL%i", slice.getPOC());
+  msg( VTM_INFO, "  VCL%i", slice.getPOC());
 }
 
 /**
@@ -371,11 +371,11 @@ void SubpicMergeApp::decodeNalu(Subpicture &subpic, InputNALUnit &nalu)
     }
     else if (nalu.isSei())
     {
-      msg( INFO, "  SEI");
+      msg( VTM_INFO, "  SEI");
     }
     else
     {
-      msg( INFO, "  NNN");  // Any other NAL unit that is not handled above
+      msg( VTM_INFO, "  NNN");  // Any other NAL unit that is not handled above
     }
     break;
   }
@@ -421,7 +421,7 @@ void SubpicMergeApp::parseSubpic(Subpicture &subpic, bool &morePictures)
     {
       subpic.nalus.pop_back();  // Remove empty nalu
       subpic.stats.pop_back();
-      msg( ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+      msg( VTM_ERROR, "Warning: Attempt to decode an empty NAL unit\n");
       continue;
     }
 
@@ -1095,7 +1095,7 @@ void SubpicMergeApp::mergeStreams(bool mixedNaluFlag)
   ParameterSetManager psManager;  // Parameter sets for merged stream
   int picNum = 0;
 
-  msg( INFO, "Output picture size is %ix%i\n", m_picWidth, m_picHeight);
+  msg( VTM_INFO, "Output picture size is %ix%i\n", m_picWidth, m_picHeight);
 
   for (auto &subpic : *m_subpics)
   {
@@ -1107,15 +1107,15 @@ void SubpicMergeApp::mergeStreams(bool mixedNaluFlag)
   bool morePictures = true;
   while (morePictures)
   {
-    msg( INFO, "Picture %i\n", picNum);
+    msg( VTM_INFO, "Picture %i\n", picNum);
     int subPicNum = 0;
 
     for (auto &subpic : *m_subpics)
     {
-      msg( INFO, " Subpicture %i\n", subPicNum);
+      msg( VTM_INFO, " Subpicture %i\n", subPicNum);
       parseSubpic(subpic, morePictures);
       subPicNum++;
-      msg( INFO, "\n");
+      msg( VTM_INFO, "\n");
     }
 
     validateSubpics();
@@ -1194,7 +1194,7 @@ void SubpicMergeApp::mergeYuvFiles(int bitdepth, int chromaFormat)
         m_outputStream.write(reinterpret_cast<char*>(destPic[cIdx]), cIdx == 0 ? numBytesPerPicY : numBytesPerPicUV);
       }
 
-      msg( INFO, "Merged YUV picture %i\n", picNum);
+      msg( VTM_INFO, "Merged YUV picture %i\n", picNum);
     }
 
     picNum++;
diff --git a/source/Lib/CommonLib/ChromaFormat.h b/source/Lib/CommonLib/ChromaFormat.h
index 141351f5..caa2656c 100644
--- a/source/Lib/CommonLib/ChromaFormat.h
+++ b/source/Lib/CommonLib/ChromaFormat.h
@@ -76,7 +76,7 @@ static inline uint32_t getTotalSamples(const uint32_t width, const uint32_t heig
     case CHROMA_422: return  samplesPerChannel * 2;       break;
     case CHROMA_444: return  samplesPerChannel * 3;       break;
     default:
-      EXIT( "ERROR: Unrecognised chroma format in getTotalSamples() " );
+      EXIT( "VTM_ERROR: Unrecognised chroma format in getTotalSamples() " );
       break;
   }
 
@@ -95,7 +95,7 @@ static inline uint64_t getTotalFracBits(const uint32_t width, const uint32_t hei
   case CHROMA_422: bitsPerSampleTimes2 =   2 * (bitDepths[CHANNEL_TYPE_LUMA]   +   bitDepths[CHANNEL_TYPE_CHROMA]);        break;
   case CHROMA_444: bitsPerSampleTimes2 =   2 * (bitDepths[CHANNEL_TYPE_LUMA]   + 2*bitDepths[CHANNEL_TYPE_CHROMA]);        break;
   default:
-      EXIT( "ERROR: Unrecognised chroma format in getTotalFracBits() " );
+      EXIT( "VTM_ERROR: Unrecognised chroma format in getTotalFracBits() " );
     break;
   }
   return uint64_t( width * height * bitsPerSampleTimes2 ) << ( SCALE_BITS - 1 );
diff --git a/source/Lib/CommonLib/CommonDef.h b/source/Lib/CommonLib/CommonDef.h
index 8f0c64f4..c295e5a8 100644
--- a/source/Lib/CommonLib/CommonDef.h
+++ b/source/Lib/CommonLib/CommonDef.h
@@ -497,7 +497,7 @@ template <typename T> inline T ClipPel (const T a, const ClpRng& clpRng)
 
 template <typename T> inline void Check3( T minVal, T maxVal, T a)
 {
-  CHECK( ( a > maxVal ) || ( a < minVal ), "ERROR: Range check " << minVal << " >= " << a << " <= " << maxVal << " failed" );
+  CHECK( ( a > maxVal ) || ( a < minVal ), "VTM_ERROR: Range check " << minVal << " >= " << a << " <= " << maxVal << " failed" );
 }  ///< general min/max clip
 
 extern MsgLevel g_verbosity;
@@ -509,7 +509,7 @@ inline void msg( MsgLevel level, const char* fmt, ... )
   {
     va_list args;
     va_start( args, fmt );
-    vfprintf( level == ERROR ? stderr : stdout, fmt, args );
+    vfprintf( level == VTM_ERROR ? stderr : stdout, fmt, args );
     va_end( args );
   }
 }
diff --git a/source/Lib/CommonLib/DepQuant.cpp b/source/Lib/CommonLib/DepQuant.cpp
index 1cacfd01..0f5a5a55 100644
--- a/source/Lib/CommonLib/DepQuant.cpp
+++ b/source/Lib/CommonLib/DepQuant.cpp
@@ -150,10 +150,10 @@ namespace DQIntern
 
   void Rom::xInitScanArrays()
   {
-    if( m_scansInitialized )
-    {
-      return;
-    }
+//    if( m_scansInitialized )
+//    {
+//      return;
+//    }
     ::memset( m_scanId2NbInfoSbbArray, 0, sizeof(m_scanId2NbInfoSbbArray) );
     ::memset( m_scanId2NbInfoOutArray, 0, sizeof(m_scanId2NbInfoOutArray) );
     ::memset( m_tuParameters,          0, sizeof(m_tuParameters) );
diff --git a/source/Lib/CommonLib/IntraPrediction.cpp b/source/Lib/CommonLib/IntraPrediction.cpp
index a195c476..438c8ab3 100644
--- a/source/Lib/CommonLib/IntraPrediction.cpp
+++ b/source/Lib/CommonLib/IntraPrediction.cpp
@@ -1814,7 +1814,7 @@ void IntraPrediction::initIntraMip( const PredictionUnit &pu, const CompArea &ar
   CHECK( area.width > MIP_MAX_WIDTH || area.height > MIP_MAX_HEIGHT, "Error: block size not supported for MIP" );
 
   // prepare input (boundary) data for prediction
-  CHECK( m_ipaParam.refFilterFlag, "ERROR: unfiltered refs expected for MIP" );
+  CHECK( m_ipaParam.refFilterFlag, "VTM_ERROR: unfiltered refs expected for MIP" );
   Pel       *ptrSrc     = getPredictorPtr(area.compID);
   const int  srcStride  = m_refBufferStride[area.compID];
   const int  srcHStride = 2;
diff --git a/source/Lib/CommonLib/MCTS.cpp b/source/Lib/CommonLib/MCTS.cpp
index 1690bd4b..60e137b7 100644
--- a/source/Lib/CommonLib/MCTS.cpp
+++ b/source/Lib/CommonLib/MCTS.cpp
@@ -181,7 +181,7 @@ static bool checkMVRange( const Mv& mv, const Area& tileArea, int predXLeft, int
   {
     if( msgFlag )
     {
-      msg( WARNING, "%s: pu motion vector across tile boundaries MV(%d,%d) RangeLR(%d,%d) PredLR(%d,%d)\n", (isLuma ? "LUMA": "CHROMA"), mv.getHor(), mv.getVer(), rangeXLeft, rangeXRight, predXLeft, predXRight );
+      msg( VTM_WARNING, "%s: pu motion vector across tile boundaries MV(%d,%d) RangeLR(%d,%d) PredLR(%d,%d)\n", (isLuma ? "LUMA": "CHROMA"), mv.getHor(), mv.getVer(), rangeXLeft, rangeXRight, predXLeft, predXRight );
     }
     return false;
   }
@@ -189,7 +189,7 @@ static bool checkMVRange( const Mv& mv, const Area& tileArea, int predXLeft, int
   {
     if( msgFlag )
     {
-      msg( WARNING, "%s: pu motion vector across tile boundaries MV(%d,%d) RangeTB(%d,%d) PredTB(%d,%d)\n", (isLuma ? "LUMA" : "CHROMA"), mv.getHor(), mv.getVer(), rangeYTop, rangeYBottom, predYTop, predYBottom );
+      msg( VTM_WARNING, "%s: pu motion vector across tile boundaries MV(%d,%d) RangeTB(%d,%d) PredTB(%d,%d)\n", (isLuma ? "LUMA" : "CHROMA"), mv.getHor(), mv.getVer(), rangeYTop, rangeYBottom, predYTop, predYBottom );
     }
     return false;
   }
diff --git a/source/Lib/CommonLib/ParameterSetManager.cpp b/source/Lib/CommonLib/ParameterSetManager.cpp
index 49975baf..75311946 100644
--- a/source/Lib/CommonLib/ParameterSetManager.cpp
+++ b/source/Lib/CommonLib/ParameterSetManager.cpp
@@ -92,7 +92,7 @@ bool ParameterSetManager::activatePPS(int ppsId, bool isIRAP)
         }
         else
         {
-          msg( WARNING, "Warning: tried to activate a PPS that refers to a non-existing VPS." );
+          msg( VTM_WARNING, "Warning: tried to activate a PPS that refers to a non-existing VPS." );
         }
 
         m_spsMap.clearActive();
@@ -104,13 +104,13 @@ bool ParameterSetManager::activatePPS(int ppsId, bool isIRAP)
       }
       else
       {
-        msg( WARNING, "Warning: tried to activate a PPS that refers to a non-existing SPS.");
+        msg( VTM_WARNING, "Warning: tried to activate a PPS that refers to a non-existing SPS.");
       }
     }
   }
   else
   {
-    msg( WARNING, "Warning: tried to activate a non-existing PPS.");
+    msg( VTM_WARNING, "Warning: tried to activate a non-existing PPS.");
   }
 
   // Failed to activate if reach here.
@@ -128,7 +128,7 @@ bool ParameterSetManager::activateAPS(int apsId, int apsType)
   }
   else
   {
-    msg(WARNING, "Warning: tried to activate a non-existing APS.");
+    msg(VTM_WARNING, "Warning: tried to activate a non-existing APS.");
   }
   return false;
 }
diff --git a/source/Lib/CommonLib/PicYuvMD5.cpp b/source/Lib/CommonLib/PicYuvMD5.cpp
index a15f81ac..2be13372 100644
--- a/source/Lib/CommonLib/PicYuvMD5.cpp
+++ b/source/Lib/CommonLib/PicYuvMD5.cpp
@@ -291,7 +291,7 @@ int calcAndPrintHashStatus(const CPelUnitBuf& pic, const SEIDecodedPictureHash*
     ok = "(OK)";
     if (recon_digest != pictureHashSEI->m_pictureHash)
     {
-      ok = "(***ERROR***)";
+      ok = "(***VTM_ERROR***)";
       mismatch = true;
     }
   }
diff --git a/source/Lib/CommonLib/RdCost.cpp b/source/Lib/CommonLib/RdCost.cpp
index 8e6c7cfd..2fbfb4e8 100644
--- a/source/Lib/CommonLib/RdCost.cpp
+++ b/source/Lib/CommonLib/RdCost.cpp
@@ -3044,7 +3044,7 @@ void RdCost::updateReshapeLumaLevelToWeightTable(SliceReshapeInfo &sliceReshape,
     }
     else
     {
-      THROW("updateReshapeLumaLevelToWeightTable ERROR!!");
+      THROW("updateReshapeLumaLevelToWeightTable VTM_ERROR!!");
     }
   }
   else
diff --git a/source/Lib/CommonLib/Rom.cpp b/source/Lib/CommonLib/Rom.cpp
index c2f196d0..15e3355f 100644
--- a/source/Lib/CommonLib/Rom.cpp
+++ b/source/Lib/CommonLib/Rom.cpp
@@ -56,7 +56,7 @@ bool g_mctsDecCheckEnabled = false;
 //! \ingroup CommonLib
 //! \{
 
-MsgLevel g_verbosity = VERBOSE;
+MsgLevel g_verbosity = VTM_VERBOSE;
 
 const char* nalUnitTypeToString(NalUnitType type)
 {
@@ -191,7 +191,7 @@ public:
 
       default:
 
-        THROW("ERROR: Unknown scan type \"" << m_scanType << "\"in ScanGenerator::GetNextIndex");
+        THROW("VTM_ERROR: Unknown scan type \"" << m_scanType << "\"in ScanGenerator::GetNextIndex");
         break;
     }
 
diff --git a/source/Lib/CommonLib/Slice.cpp b/source/Lib/CommonLib/Slice.cpp
index 59b3fcf3..f4dd81f3 100644
--- a/source/Lib/CommonLib/Slice.cpp
+++ b/source/Lib/CommonLib/Slice.cpp
@@ -1813,7 +1813,7 @@ int Slice::checkThatAllRefPicsAreAvailable(PicList& rcListPic, const ReferencePi
     {
       if (printErrors)
       {
-        msg(ERROR, "\nCurrent picture: %d Long-term reference picture with POC = %3d seems to have been removed or not correctly decoded.", this->getPOC(), notPresentPoc);
+        msg(VTM_ERROR, "\nCurrent picture: %d Long-term reference picture with POC = %3d seems to have been removed or not correctly decoded.", this->getPOC(), notPresentPoc);
       }
       return notPresentPoc;
     }
@@ -1844,7 +1844,7 @@ int Slice::checkThatAllRefPicsAreAvailable(PicList& rcListPic, const ReferencePi
     {
       if (printErrors)
       {
-        msg(ERROR, "\nCurrent picture: %d Short-term reference picture with POC = %3d seems to have been removed or not correctly decoded.", this->getPOC(), notPresentPoc);
+        msg(VTM_ERROR, "\nCurrent picture: %d Short-term reference picture with POC = %3d seems to have been removed or not correctly decoded.", this->getPOC(), notPresentPoc);
       }
       return notPresentPoc;
     }
@@ -1923,7 +1923,7 @@ int Slice::checkThatAllRefPicsAreAvailable(PicList& rcListPic, const ReferencePi
     {
       if (printErrors)
       {
-        msg(ERROR, "\nCurrent picture: %d Long-term reference picture with POC = %3d seems to have been removed or not correctly decoded.", this->getPOC(), notPresentPoc);
+        msg(VTM_ERROR, "\nCurrent picture: %d Long-term reference picture with POC = %3d seems to have been removed or not correctly decoded.", this->getPOC(), notPresentPoc);
       }
       *refPicIndex = ii;
       return notPresentPoc;
@@ -1955,7 +1955,7 @@ int Slice::checkThatAllRefPicsAreAvailable(PicList& rcListPic, const ReferencePi
     {
       if (printErrors)
       {
-        msg(ERROR, "\nCurrent picture: %d Short-term reference picture with POC = %3d seems to have been removed or not correctly decoded.", this->getPOC(), notPresentPoc);
+        msg(VTM_ERROR, "\nCurrent picture: %d Short-term reference picture with POC = %3d seems to have been removed or not correctly decoded.", this->getPOC(), notPresentPoc);
       }
       *refPicIndex = ii;
       return notPresentPoc;
@@ -2019,17 +2019,17 @@ void Slice::checkConformanceForDRAP( uint32_t temporalId )
     if (!(getNalUnitType() == NalUnitType::NAL_UNIT_CODED_SLICE_TRAIL ||
           getNalUnitType() == NalUnitType::NAL_UNIT_CODED_SLICE_STSA))
     {
-      msg( WARNING, "Warning, non-conforming bitstream. The DRAP picture should be a trailing picture.\n");
+      msg( VTM_WARNING, "Warning, non-conforming bitstream. The DRAP picture should be a trailing picture.\n");
     }
     if ( temporalId != 0)
     {
-      msg( WARNING, "Warning, non-conforming bitstream. The DRAP picture shall have a temporal sublayer identifier equal to 0.\n");
+      msg( VTM_WARNING, "Warning, non-conforming bitstream. The DRAP picture shall have a temporal sublayer identifier equal to 0.\n");
     }
     for (int i = 0; i < getNumRefIdx(REF_PIC_LIST_0); i++)
     {
       if (getRefPic(REF_PIC_LIST_0,i)->getPOC() != getAssociatedIRAPPOC())
       {
-        msg( WARNING, "Warning, non-conforming bitstream. The DRAP picture shall not include any pictures in the active "
+        msg( VTM_WARNING, "Warning, non-conforming bitstream. The DRAP picture shall not include any pictures in the active "
                       "entries of its reference picture lists except the preceding IRAP picture in decoding order.\n");
       }
     }
@@ -2037,7 +2037,7 @@ void Slice::checkConformanceForDRAP( uint32_t temporalId )
     {
       if (getRefPic(REF_PIC_LIST_1,i)->getPOC() != getAssociatedIRAPPOC())
       {
-        msg( WARNING, "Warning, non-conforming bitstream. The DRAP picture shall not include any pictures in the active "
+        msg( VTM_WARNING, "Warning, non-conforming bitstream. The DRAP picture shall not include any pictures in the active "
                       "entries of its reference picture lists except the preceding IRAP picture in decoding order.\n");
       }
     }
@@ -2049,7 +2049,7 @@ void Slice::checkConformanceForDRAP( uint32_t temporalId )
     {
       if (getRefPic(REF_PIC_LIST_0,i)->getPOC() < getLatestDRAPPOC() && getRefPic(REF_PIC_LIST_0,i)->getPOC() != getAssociatedIRAPPOC())
       {
-        msg( WARNING, "Warning, non-conforming bitstream. Any picture that follows the DRAP picture in both decoding order "
+        msg( VTM_WARNING, "Warning, non-conforming bitstream. Any picture that follows the DRAP picture in both decoding order "
                     "and output order shall not include, in the active entries of its reference picture lists, any picture "
                     "that precedes the DRAP picture in decoding order or output order, with the exception of the preceding "
                     "IRAP picture in decoding order. Problem is POC %d in RPL0.\n", getRefPic(REF_PIC_LIST_0,i)->getPOC());
@@ -2059,7 +2059,7 @@ void Slice::checkConformanceForDRAP( uint32_t temporalId )
     {
       if (getRefPic(REF_PIC_LIST_1,i)->getPOC() < getLatestDRAPPOC() && getRefPic(REF_PIC_LIST_1,i)->getPOC() != getAssociatedIRAPPOC())
       {
-        msg( WARNING, "Warning, non-conforming bitstream. Any picture that follows the DRAP picture in both decoding order "
+        msg( VTM_WARNING, "Warning, non-conforming bitstream. Any picture that follows the DRAP picture in both decoding order "
                     "and output order shall not include, in the active entries of its reference picture lists, any picture "
                     "that precedes the DRAP picture in decoding order or output order, with the exception of the preceding "
                     "IRAP picture in decoding order. Problem is POC %d in RPL1", getRefPic(REF_PIC_LIST_1,i)->getPOC());
@@ -4008,7 +4008,7 @@ bool ScalingList::xParseScalingList(const std::string &fileName)
 
   if (fileName.empty())
   {
-    msg( ERROR, "Error: no scaling list file specified. Help on scaling lists being output\n");
+    msg( VTM_ERROR, "Error: no scaling list file specified. Help on scaling lists being output\n");
     outputScalingListHelp(std::cout);
     std::cout << "\n\nExample scaling list file using default values:\n\n";
     outputScalingLists(std::cout);
@@ -4016,7 +4016,7 @@ bool ScalingList::xParseScalingList(const std::string &fileName)
   }
   else if ((fp = fopen(fileName.c_str(),"r")) == (FILE*)NULL)
   {
-    msg( ERROR, "Error: cannot open scaling list file %s for reading\n", fileName.c_str());
+    msg( VTM_ERROR, "Error: cannot open scaling list file %s for reading\n", fileName.c_str());
     return true;
   }
 
@@ -4050,7 +4050,7 @@ bool ScalingList::xParseScalingList(const std::string &fileName)
           }
           if (!bFound)
           {
-            msg( ERROR, "Error: cannot find Matrix %s from scaling list file %s\n", MatrixType[sizeIdc][listIdc], fileName.c_str());
+            msg( VTM_ERROR, "Error: cannot find Matrix %s from scaling list file %s\n", MatrixType[sizeIdc][listIdc], fileName.c_str());
             return true;
 
           }
@@ -4060,12 +4060,12 @@ bool ScalingList::xParseScalingList(const std::string &fileName)
           int data;
           if (fscanf(fp, "%d,", &data)!=1)
           {
-            msg( ERROR, "Error: cannot read value #%d for Matrix %s from scaling list file %s at file position %ld\n", i, MatrixType[sizeIdc][listIdc], fileName.c_str(), ftell(fp));
+            msg( VTM_ERROR, "Error: cannot read value #%d for Matrix %s from scaling list file %s at file position %ld\n", i, MatrixType[sizeIdc][listIdc], fileName.c_str(), ftell(fp));
             return true;
           }
           if (data<0 || data>255)
           {
-            msg( ERROR, "Error: QMatrix entry #%d of value %d for Matrix %s from scaling list file %s at file position %ld is out of range (0 to 255)\n", i, data, MatrixType[sizeIdc][listIdc], fileName.c_str(), ftell(fp));
+            msg( VTM_ERROR, "Error: QMatrix entry #%d of value %d for Matrix %s from scaling list file %s at file position %ld is out of range (0 to 255)\n", i, data, MatrixType[sizeIdc][listIdc], fileName.c_str(), ftell(fp));
             return true;
           }
           src[i] = data;
@@ -4091,19 +4091,19 @@ bool ScalingList::xParseScalingList(const std::string &fileName)
             }
             if (!bFound)
             {
-              msg( ERROR, "Error: cannot find DC Matrix %s from scaling list file %s\n", MatrixType_DC[sizeIdc][listIdc], fileName.c_str());
+              msg( VTM_ERROR, "Error: cannot find DC Matrix %s from scaling list file %s\n", MatrixType_DC[sizeIdc][listIdc], fileName.c_str());
               return true;
             }
           }
           int data;
           if (fscanf(fp, "%d,", &data)!=1)
           {
-            msg( ERROR, "Error: cannot read DC %s from scaling list file %s at file position %ld\n", MatrixType_DC[sizeIdc][listIdc], fileName.c_str(), ftell(fp));
+            msg( VTM_ERROR, "Error: cannot read DC %s from scaling list file %s at file position %ld\n", MatrixType_DC[sizeIdc][listIdc], fileName.c_str(), ftell(fp));
             return true;
           }
           if (data<0 || data>255)
           {
-            msg( ERROR, "Error: DC value %d for Matrix %s from scaling list file %s at file position %ld is out of range (0 to 255)\n", data, MatrixType[sizeIdc][listIdc], fileName.c_str(), ftell(fp));
+            msg( VTM_ERROR, "Error: DC value %d for Matrix %s from scaling list file %s at file position %ld is out of range (0 to 255)\n", data, MatrixType[sizeIdc][listIdc], fileName.c_str(), ftell(fp));
             return true;
           }
           //overwrite DC value when size of matrix is larger than 16x16
diff --git a/source/Lib/CommonLib/TypeDef.h b/source/Lib/CommonLib/TypeDef.h
index 30a7c430..1f3601a0 100644
--- a/source/Lib/CommonLib/TypeDef.h
+++ b/source/Lib/CommonLib/TypeDef.h
@@ -244,7 +244,7 @@ typedef std::pair<int, int>  TrCost;
 // ====================================================================================================================
 
 #if ((RExt__HIGH_PRECISION_FORWARD_TRANSFORM != 0) && (RExt__HIGH_BIT_DEPTH_SUPPORT == 0))
-#error ERROR: cannot enable RExt__HIGH_PRECISION_FORWARD_TRANSFORM without RExt__HIGH_BIT_DEPTH_SUPPORT
+#error VTM_ERROR: cannot enable RExt__HIGH_PRECISION_FORWARD_TRANSFORM without RExt__HIGH_BIT_DEPTH_SUPPORT
 #endif
 
 // ====================================================================================================================
@@ -1029,13 +1029,13 @@ public:
 
 enum MsgLevel
 {
-  SILENT  = 0,
-  ERROR   = 1,
-  WARNING = 2,
-  INFO    = 3,
-  NOTICE  = 4,
-  VERBOSE = 5,
-  DETAILS = 6
+  VTM_SILENT  = 0,
+  VTM_ERROR   = 1,
+  VTM_WARNING = 2,
+  VTM_INFO    = 3,
+  VTM_NOTICE  = 4,
+  VTM_VERBOSE = 5,
+  VTM_DETAILS = 6
 };
 enum RESHAPE_SIGNAL_TYPE
 {
diff --git a/source/Lib/CommonLib/dtrace.cpp b/source/Lib/CommonLib/dtrace.cpp
index 5e732a0b..483169e3 100644
--- a/source/Lib/CommonLib/dtrace.cpp
+++ b/source/Lib/CommonLib/dtrace.cpp
@@ -273,12 +273,12 @@ std::string CDTrace::getErrMessage()
   if( m_error_code )
   {
     if( m_error_code == -2 )
-      str = ( " - DTrace ERROR: Add tracing rule failed: DECERR_DTRACE_BAD_RULE" );
+      str = ( " - DTrace VTM_ERROR: Add tracing rule failed: DECERR_DTRACE_BAD_RULE" );
     else if( m_error_code == -3 )
-      str = ( " - DTrace ERROR: Add tracing rule failed: DECERR_DTRACE_UNKNOWN_CHANNEL" );
+      str = ( " - DTrace VTM_ERROR: Add tracing rule failed: DECERR_DTRACE_UNKNOWN_CHANNEL" );
     else
     {
-      str = " - DTrace ERROR: Undefined error";
+      str = " - DTrace VTM_ERROR: Undefined error";
     }
   }
 
diff --git a/source/Lib/CommonLib/dtrace_next.h b/source/Lib/CommonLib/dtrace_next.h
index 8281ae76..193b551d 100644
--- a/source/Lib/CommonLib/dtrace_next.h
+++ b/source/Lib/CommonLib/dtrace_next.h
@@ -253,14 +253,14 @@ inline CDTrace* tracing_init( std::string& sTracingFile, std::string& sTracingRu
 
   if( !sTracingFile.empty() || !sTracingRule.empty() )
   {
-    msg( VERBOSE, "\n" );
-    msg( VERBOSE, "Tracing is enabled: %s : %s\n", sTracingFile.c_str(), sTracingRule.c_str() );
+    msg( VTM_VERBOSE, "\n" );
+    msg( VTM_VERBOSE, "Tracing is enabled: %s : %s\n", sTracingFile.c_str(), sTracingRule.c_str() );
   }
 
   CDTrace *pDtrace = new CDTrace( sTracingFile, sTracingRule, channels );
   if( pDtrace->getLastError() )
   {
-    msg( WARNING, "%s\n", pDtrace->getErrMessage().c_str() );
+    msg( VTM_WARNING, "%s\n", pDtrace->getErrMessage().c_str() );
     //return NULL;
   }
 
diff --git a/source/Lib/DecoderLib/DecLib.cpp b/source/Lib/DecoderLib/DecLib.cpp
index 4c06188e..8ef94c99 100644
--- a/source/Lib/DecoderLib/DecLib.cpp
+++ b/source/Lib/DecoderLib/DecLib.cpp
@@ -99,7 +99,7 @@ bool tryDecodePicture( Picture* pcEncPic, const int expectedPoc, const std::stri
       pcDecLib->setAPSMapEnc( apsMap );
 
       bFirstCall = false;
-      msg( INFO, "start to decode %s \n", bitstreamFileName.c_str() );
+      msg( VTM_INFO, "start to decode %s \n", bitstreamFileName.c_str() );
     }
 
     bool goOn = true;
@@ -128,7 +128,7 @@ bool tryDecodePicture( Picture* pcEncPic, const int expectedPoc, const std::stri
          *  - two back-to-back start_code_prefixes
          *  - start_code_prefix immediately followed by EOF
          */
-        msg( ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+        msg( VTM_ERROR, "Warning: Attempt to decode an empty NAL unit\n");
       }
       else
       {
@@ -251,7 +251,7 @@ bool tryDecodePicture( Picture* pcEncPic, const int expectedPoc, const std::stri
             pcDecLib->executeLoopFilters();
           }
 
-          pcDecLib->finishPicture( poc, pcListPic, DETAILS );
+          pcDecLib->finishPicture( poc, pcListPic, VTM_DETAILS );
 
           // write output
           if( ! pcListPic->empty())
@@ -467,10 +467,10 @@ DecLib::DecLib()
   for (int i = 0; i < MAX_VPS_LAYERS; i++)
   {
     m_associatedIRAPType[i] = NAL_UNIT_INVALID;
-    std::fill_n(m_prevGDRSubpicPOC[i], MAX_NUM_SUB_PICS, -MAX_INT);
-    std::fill_n(m_prevIRAPSubpicPOC[i], MAX_NUM_SUB_PICS, -MAX_INT);
-    memset(m_prevIRAPSubpicDecOrderNo[i], 0, sizeof(int)*MAX_NUM_SUB_PICS);
-    std::fill_n(m_prevIRAPSubpicType[i], MAX_NUM_SUB_PICS, NAL_UNIT_INVALID);
+//    std::fill_n(m_prevGDRSubpicPOC[i], MAX_NUM_SUB_PICS, -MAX_INT);
+//    std::fill_n(m_prevIRAPSubpicPOC[i], MAX_NUM_SUB_PICS, -MAX_INT);
+//    memset(m_prevIRAPSubpicDecOrderNo[i], 0, sizeof(int)*MAX_NUM_SUB_PICS);
+//    std::fill_n(m_prevIRAPSubpicType[i], MAX_NUM_SUB_PICS, NAL_UNIT_INVALID);
   }
 }
 
@@ -764,7 +764,7 @@ void DecLib::finishPicture(int &poc, PicList *&rpcListPic, MsgLevel msgl, bool a
     const SEIDecodedPictureHash *hash = ( pictureHashes.size() > 0 ) ? (SEIDecodedPictureHash*) *(pictureHashes.begin()) : NULL;
     if (pictureHashes.size() > 1)
     {
-      msg( WARNING, "Warning: Got multiple decoded picture hash SEI messages. Using first.");
+      msg( VTM_WARNING, "Warning: Got multiple decoded picture hash SEI messages. Using first.");
     }
     m_numberOfChecksumErrorsDetected += calcAndPrintHashStatus(((const Picture*) m_pcPic)->getRecoBuf(), hash, pcSlice->getSPS()->getBitDepths(), msgl);
   }
@@ -854,7 +854,7 @@ void DecLib::xUpdateRasInit(Slice* slice)
 
 void DecLib::xCreateLostPicture( int iLostPoc, const int layerId )
 {
-  msg( INFO, "\ninserting lost poc : %d\n",iLostPoc);
+  msg( VTM_INFO, "\ninserting lost poc : %d\n",iLostPoc);
   Picture *cFillPic = xGetNewPicBuffer( *( m_parameterSetManager.getFirstSPS() ), *( m_parameterSetManager.getFirstPPS() ), 0, layerId );
 
   CHECK( !cFillPic->slices.size(), "No slices in picture" );
@@ -877,7 +877,7 @@ void DecLib::xCreateLostPicture( int iLostPoc, const int layerId )
     Picture *rpcPic = *(iterPic++);
     if(abs(rpcPic->getPOC() -iLostPoc)==closestPoc&&rpcPic->getPOC()!=m_apcSlicePilot->getPOC())
     {
-      msg( INFO, "copying picture %d to %d (%d)\n",rpcPic->getPOC() ,iLostPoc,m_apcSlicePilot->getPOC());
+      msg( VTM_INFO, "copying picture %d to %d (%d)\n",rpcPic->getPOC() ,iLostPoc,m_apcSlicePilot->getPOC());
       cFillPic->getRecoBuf().copyFrom( rpcPic->getRecoBuf() );
       break;
     }
@@ -898,7 +898,7 @@ void DecLib::xCreateLostPicture( int iLostPoc, const int layerId )
 
 void  DecLib::xCreateUnavailablePicture( const PPS *pps, const int iUnavailablePoc, const bool longTermFlag, const int temporalId, const int layerId, const bool interLayerRefPicFlag )
 {
-  msg(INFO, "\ninserting unavailable poc : %d\n", iUnavailablePoc);
+  msg(VTM_INFO, "\ninserting unavailable poc : %d\n", iUnavailablePoc);
   Picture* cFillPic = xGetNewPicBuffer( *( m_parameterSetManager.getFirstSPS() ), *( m_parameterSetManager.getFirstPPS() ), 0, layerId );
 
   CHECK(!cFillPic->slices.size(), "No slices in picture");
@@ -1950,7 +1950,7 @@ void DecLib::xCheckParameterSetConstraints(const int layerId)
   else
   {
     CHECK(sps->getProfileTierLevel()->getProfileIdc() != Profile::NONE, "Unknown profile");
-    msg(WARNING, "Warning: Profile set to none or unknown value\n");
+    msg(VTM_WARNING, "Warning: Profile set to none or unknown value\n");
   }
   const LevelTierFeatures *levelTierFeatures = ptlFeatures.getLevelTierFeatures();
   if (levelTierFeatures != nullptr)
@@ -1963,7 +1963,7 @@ void DecLib::xCheckParameterSetConstraints(const int layerId)
   {
     CHECK(sps->getProfileTierLevel()->getLevelIdc() == Level::LEVEL15_5, "Cannot use level 15.5 with given profile");
     CHECK(sps->getProfileTierLevel()->getLevelIdc() != Level::NONE, "Unknown level");
-    msg(WARNING, "Warning: Level set to none, invalid or unknown value\n");
+    msg(VTM_WARNING, "Warning: Level set to none, invalid or unknown value\n");
   }
 }
 
@@ -1973,7 +1973,7 @@ void DecLib::xParsePrefixSEIsForUnknownVCLNal()
   while (!m_prefixSEINALUs.empty())
   {
     // do nothing?
-    msg( NOTICE, "Discarding Prefix SEI associated with unknown VCL NAL unit.\n");
+    msg( VTM_NOTICE, "Discarding Prefix SEI associated with unknown VCL NAL unit.\n");
     delete m_prefixSEINALUs.front();
   }
   // TODO: discard following suffix SEIs as well?
@@ -2010,7 +2010,7 @@ void DecLib::xCheckPrefixSEIMessages( SEIMessages& prefixSEIs )
     SEIFrameFieldInfo *ff = (SEIFrameFieldInfo*) frameFieldSEIs.front();
     if( pt->m_ptDisplayElementalPeriodsMinus1 != ff->m_displayElementalPeriodsMinus1 )
     {
-      msg( WARNING, "Warning: ffi_display_elemental_periods_minus1 is different in picture timing and frame field information SEI messages!");
+      msg( VTM_WARNING, "Warning: ffi_display_elemental_periods_minus1 is different in picture timing and frame field information SEI messages!");
     }
   }
 }
@@ -2290,7 +2290,7 @@ bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDispl
   //we should only get a different poc for a new picture (with CTU address==0)
   if (m_apcSlicePilot->getPOC() != m_prevPOC && !m_firstSliceInSequence[nalu.m_nuhLayerId] && (m_apcSlicePilot->getFirstCtuRsAddrInSlice() != 0))
   {
-    msg( WARNING, "Warning, the first slice of a picture might have been lost!\n");
+    msg( VTM_WARNING, "Warning, the first slice of a picture might have been lost!\n");
   }
   m_prevLayerID = nalu.m_nuhLayerId;
 
@@ -2441,10 +2441,10 @@ bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDispl
   pcSlice->getPic()->sliceSubpicIdx.push_back(pps->getSubPicIdxFromSubPicId(pcSlice->getSliceSubPicId()));
   pcSlice->checkCRA(pcSlice->getRPL0(), pcSlice->getRPL1(), m_pocCRA[nalu.m_nuhLayerId], m_cListPic);
   pcSlice->constructRefPicList(m_cListPic);
-  pcSlice->setPrevGDRSubpicPOC(m_prevGDRSubpicPOC[nalu.m_nuhLayerId][currSubPicIdx]);
-  pcSlice->setPrevIRAPSubpicPOC(m_prevIRAPSubpicPOC[nalu.m_nuhLayerId][currSubPicIdx]);
-  pcSlice->setPrevIRAPSubpicType(m_prevIRAPSubpicType[nalu.m_nuhLayerId][currSubPicIdx]);
-  pcSlice->checkSubpicTypeConstraints(m_cListPic, pcSlice->getRPL0(), pcSlice->getRPL1(), m_prevIRAPSubpicDecOrderNo[nalu.m_nuhLayerId][currSubPicIdx]);
+//  pcSlice->setPrevGDRSubpicPOC(m_prevGDRSubpicPOC[nalu.m_nuhLayerId][currSubPicIdx]);
+//  pcSlice->setPrevIRAPSubpicPOC(m_prevIRAPSubpicPOC[nalu.m_nuhLayerId][currSubPicIdx]);
+//  pcSlice->setPrevIRAPSubpicType(m_prevIRAPSubpicType[nalu.m_nuhLayerId][currSubPicIdx]);
+//  pcSlice->checkSubpicTypeConstraints(m_cListPic, pcSlice->getRPL0(), pcSlice->getRPL1(), m_prevIRAPSubpicDecOrderNo[nalu.m_nuhLayerId][currSubPicIdx]);
   pcSlice->checkRPL(pcSlice->getRPL0(), pcSlice->getRPL1(), m_associatedIRAPDecodingOrderNumber[nalu.m_nuhLayerId], m_cListPic);
   pcSlice->checkSTSA(m_cListPic);
   if (m_pcPic->cs->vps && !m_pcPic->cs->vps->getIndependentLayerFlag(m_pcPic->cs->vps->getGeneralLayerIdx(nalu.m_nuhLayerId)) && m_pcPic->cs->pps->getNumSubPics() > 1)
@@ -2577,7 +2577,7 @@ bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDispl
     SEIMessages drapSEIs = getSeisByType(m_pcPic->SEIs, SEI::DEPENDENT_RAP_INDICATION );
     if (!drapSEIs.empty())
     {
-      msg( NOTICE, "Dependent RAP indication SEI decoded\n");
+      msg( VTM_NOTICE, "Dependent RAP indication SEI decoded\n");
       pcSlice->setDRAP(true);
       pcSlice->setLatestDRAPPOC(pcSlice->getPOC());
     }
@@ -2750,16 +2750,16 @@ void DecLib::updatePrevIRAPAndGDRSubpic()
     if (pcSlice->getCtuAddrInSlice(0) == m_pcPic->cs->pps->getSubPic(subpicIdx).getFirstCTUInSubPic())
     {
       const NalUnitType subpicType = pcSlice->getNalUnitType();
-      if (subpicType == NAL_UNIT_CODED_SLICE_IDR_W_RADL || subpicType == NAL_UNIT_CODED_SLICE_IDR_N_LP || subpicType == NAL_UNIT_CODED_SLICE_CRA)
-      {
-        m_prevIRAPSubpicPOC[m_pcPic->layerId][subpicIdx] = m_pcPic->getPOC();
-        m_prevIRAPSubpicType[m_pcPic->layerId][subpicIdx] = subpicType;
-        m_prevIRAPSubpicDecOrderNo[m_pcPic->layerId][subpicIdx] = m_pcPic->getDecodingOrderNumber();
-      }
-      else if (subpicType == NAL_UNIT_CODED_SLICE_GDR)
-      {
-        m_prevGDRSubpicPOC[m_pcPic->layerId][subpicIdx] = m_pcPic->getPOC();
-      }
+//      if (subpicType == NAL_UNIT_CODED_SLICE_IDR_W_RADL || subpicType == NAL_UNIT_CODED_SLICE_IDR_N_LP || subpicType == NAL_UNIT_CODED_SLICE_CRA)
+//      {
+//        m_prevIRAPSubpicPOC[m_pcPic->layerId][subpicIdx] = m_pcPic->getPOC();
+//        m_prevIRAPSubpicType[m_pcPic->layerId][subpicIdx] = subpicType;
+//        m_prevIRAPSubpicDecOrderNo[m_pcPic->layerId][subpicIdx] = m_pcPic->getDecodingOrderNumber();
+//      }
+//      else if (subpicType == NAL_UNIT_CODED_SLICE_GDR)
+//      {
+//        m_prevGDRSubpicPOC[m_pcPic->layerId][subpicIdx] = m_pcPic->getPOC();
+//      }
     }
   }
 }
@@ -2955,7 +2955,7 @@ bool DecLib::decode(InputNALUnit& nalu, int& iSkipFrame, int& iPOCLastDisplay, i
       }
       else
       {
-        msg( NOTICE, "Note: received suffix SEI but no picture currently active.\n");
+        msg( VTM_NOTICE, "Note: received suffix SEI but no picture currently active.\n");
       }
       return false;
 
@@ -2974,10 +2974,10 @@ bool DecLib::decode(InputNALUnit& nalu, int& iSkipFrame, int& iPOCLastDisplay, i
       m_associatedIRAPType[nalu.m_nuhLayerId] = NAL_UNIT_INVALID;
       m_pocCRA[nalu.m_nuhLayerId] = -MAX_INT;
       m_prevGDRInSameLayerPOC[nalu.m_nuhLayerId] = -MAX_INT;
-      std::fill_n(m_prevGDRSubpicPOC[nalu.m_nuhLayerId], MAX_NUM_SUB_PICS, -MAX_INT);
-      std::fill_n(m_prevIRAPSubpicPOC[nalu.m_nuhLayerId], MAX_NUM_SUB_PICS, -MAX_INT);
-      memset(m_prevIRAPSubpicDecOrderNo[nalu.m_nuhLayerId], 0, sizeof(int)*MAX_NUM_SUB_PICS);
-      std::fill_n(m_prevIRAPSubpicType[nalu.m_nuhLayerId], MAX_NUM_SUB_PICS, NAL_UNIT_INVALID);
+//      std::fill_n(m_prevGDRSubpicPOC[nalu.m_nuhLayerId], MAX_NUM_SUB_PICS, -MAX_INT);
+//      std::fill_n(m_prevIRAPSubpicPOC[nalu.m_nuhLayerId], MAX_NUM_SUB_PICS, -MAX_INT);
+//      memset(m_prevIRAPSubpicDecOrderNo[nalu.m_nuhLayerId], 0, sizeof(int)*MAX_NUM_SUB_PICS);
+//      std::fill_n(m_prevIRAPSubpicType[nalu.m_nuhLayerId], MAX_NUM_SUB_PICS, NAL_UNIT_INVALID);
       m_pocRandomAccess = MAX_INT;
       m_prevLayerID = MAX_INT;
       m_prevPOC = -MAX_INT;
@@ -3003,12 +3003,12 @@ bool DecLib::decode(InputNALUnit& nalu, int& iSkipFrame, int& iPOCLastDisplay, i
       FDReader fdReader;
       uint32_t fdSize;
       fdReader.parseFillerData(&(nalu.getBitstream()), fdSize);
-      msg( NOTICE, "Note: found NAL_UNIT_FD with %u bytes payload.\n", fdSize);
+      msg( VTM_NOTICE, "Note: found NAL_UNIT_FD with %u bytes payload.\n", fdSize);
       return false;
     }
 
     case NAL_UNIT_RESERVED_IRAP_VCL_11:
-      msg( NOTICE, "Note: found reserved VCL NAL unit.\n");
+      msg( VTM_NOTICE, "Note: found reserved VCL NAL unit.\n");
       xParsePrefixSEIsForUnknownVCLNal();
       return false;
     case NAL_UNIT_RESERVED_VCL_4:
@@ -3016,13 +3016,13 @@ bool DecLib::decode(InputNALUnit& nalu, int& iSkipFrame, int& iPOCLastDisplay, i
     case NAL_UNIT_RESERVED_VCL_6:
     case NAL_UNIT_RESERVED_NVCL_26:
     case NAL_UNIT_RESERVED_NVCL_27:
-      msg( NOTICE, "Note: found reserved NAL unit.\n");
+      msg( VTM_NOTICE, "Note: found reserved NAL unit.\n");
       return false;
     case NAL_UNIT_UNSPECIFIED_28:
     case NAL_UNIT_UNSPECIFIED_29:
     case NAL_UNIT_UNSPECIFIED_30:
     case NAL_UNIT_UNSPECIFIED_31:
-      msg( NOTICE, "Note: found unspecified NAL unit.\n");
+      msg( VTM_NOTICE, "Note: found unspecified NAL unit.\n");
       return false;
     default:
       THROW( "Invalid NAL unit type" );
@@ -3064,7 +3064,7 @@ bool DecLib::isRandomAccessSkipPicture( int& iSkipFrame, int& iPOCLastDisplay )
     {
       if(!m_warningMessageSkipPicture)
       {
-        msg( WARNING, "\nWarning: this is not a valid random access point and the data is discarded until the first CRA picture");
+        msg( VTM_WARNING, "\nWarning: this is not a valid random access point and the data is discarded until the first CRA picture");
         m_warningMessageSkipPicture = true;
       }
       return true;
@@ -3191,7 +3191,7 @@ bool DecLib::isNewPicture(std::ifstream *bitstreamFile, class InputByteStream *b
     byteStreamNALUnit(*bytestream, nalu.getBitstream().getFifo(), stats);
     if (nalu.getBitstream().getFifo().empty())
     {
-      msg( ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+      msg( VTM_ERROR, "Warning: Attempt to decode an empty NAL unit\n");
     }
     else
     {
@@ -3300,7 +3300,7 @@ bool DecLib::isNewAccessUnit( bool newPicture, std::ifstream *bitstreamFile, cla
     byteStreamNALUnit(*bytestream, nalu.getBitstream().getFifo(), stats);
     if (nalu.getBitstream().getFifo().empty())
     {
-      msg( ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+      msg( VTM_ERROR, "Warning: Attempt to decode an empty NAL unit\n");
     }
     else
     {
diff --git a/source/Lib/DecoderLib/DecLib.h b/source/Lib/DecoderLib/DecLib.h
index 4dc88e65..4757a557 100644
--- a/source/Lib/DecoderLib/DecLib.h
+++ b/source/Lib/DecoderLib/DecLib.h
@@ -79,10 +79,10 @@ private:
   int                     m_decodingOrderCounter;
   int                     m_puCounter;
   bool                    m_seiInclusionFlag;
-  int                     m_prevGDRSubpicPOC[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
-  int                     m_prevIRAPSubpicPOC[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
-  NalUnitType             m_prevIRAPSubpicType[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
-  int                     m_prevIRAPSubpicDecOrderNo[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
+//  int                     m_prevGDRSubpicPOC[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
+//  int                     m_prevIRAPSubpicPOC[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
+//  NalUnitType             m_prevIRAPSubpicType[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
+//  int                     m_prevIRAPSubpicDecOrderNo[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
   int                     m_pocRandomAccess;   ///< POC number of the random access point (the first IDR or CRA picture)
   int                     m_lastRasPoc;
   bool                    m_prevEOS[MAX_VPS_LAYERS];
@@ -220,7 +220,7 @@ public:
   void  deletePicBuffer();
 
   void  executeLoopFilters();
-  void finishPicture(int &poc, PicList *&rpcListPic, MsgLevel msgl = INFO, bool associatedWithNewClvs = false);
+  void finishPicture(int &poc, PicList *&rpcListPic, MsgLevel msgl = VTM_INFO, bool associatedWithNewClvs = false);
   void  finishPictureLight(int& poc, PicList*& rpcListPic );
   void  checkNoOutputPriorPics (PicList* rpcListPic);
   void  checkNalUnitConstraints( uint32_t naluType );
diff --git a/source/Lib/DecoderLib/NALread.cpp b/source/Lib/DecoderLib/NALread.cpp
index ccda0068..56209415 100644
--- a/source/Lib/DecoderLib/NALread.cpp
+++ b/source/Lib/DecoderLib/NALread.cpp
@@ -99,7 +99,7 @@ static void convertPayloadToRBSP(vector<uint8_t>& nalUnitBuf, InputBitstream *bi
 
     if (n > 0)
     {
-      msg( NOTICE, "\nDetected %d instances of cabac_zero_word\n", n/2);
+      msg( VTM_NOTICE, "\nDetected %d instances of cabac_zero_word\n", n/2);
     }
   }
 
diff --git a/source/Lib/DecoderLib/SEIread.cpp b/source/Lib/DecoderLib/SEIread.cpp
index b8ca0dec..714b7640 100644
--- a/source/Lib/DecoderLib/SEIread.cpp
+++ b/source/Lib/DecoderLib/SEIread.cpp
@@ -190,7 +190,7 @@ void SEIReader::xReadSEImessage(SEIMessages& seis, const NalUnitType nalUnitType
       bp = hrd.getBufferingPeriodSEI();
       if (!bp)
       {
-        msg( WARNING, "Warning: Found Decoding unit information SEI message, but no active buffering period is available. Ignoring.");
+        msg( VTM_WARNING, "Warning: Found Decoding unit information SEI message, but no active buffering period is available. Ignoring.");
       }
       else
       {
@@ -208,7 +208,7 @@ void SEIReader::xReadSEImessage(SEIMessages& seis, const NalUnitType nalUnitType
         bp = hrd.getBufferingPeriodSEI();
         if (!bp)
         {
-          msg( WARNING, "Warning: Found Picture timing SEI message, but no active buffering period is available. Ignoring.");
+          msg( VTM_WARNING, "Warning: Found Picture timing SEI message, but no active buffering period is available. Ignoring.");
         }
         else
         {
@@ -306,7 +306,7 @@ void SEIReader::xReadSEImessage(SEIMessages& seis, const NalUnitType nalUnitType
         uint32_t seiByte;
         sei_read_code (NULL, 8, seiByte, "unknown prefix SEI payload byte");
       }
-      msg( WARNING, "Unknown prefix SEI message (payloadType = %d) was found!\n", payloadType);
+      msg( VTM_WARNING, "Unknown prefix SEI message (payloadType = %d) was found!\n", payloadType);
       if (pDecodedMessageOutputStream)
       {
         (*pDecodedMessageOutputStream) << "Unknown prefix SEI message (payloadType = " << payloadType << ") was found!\n";
@@ -336,7 +336,7 @@ void SEIReader::xReadSEImessage(SEIMessages& seis, const NalUnitType nalUnitType
           uint32_t seiByte;
           sei_read_code( NULL, 8, seiByte, "unknown suffix SEI payload byte");
         }
-        msg( WARNING, "Unknown suffix SEI message (payloadType = %d) was found!\n", payloadType);
+        msg( VTM_WARNING, "Unknown suffix SEI message (payloadType = %d) was found!\n", payloadType);
         if (pDecodedMessageOutputStream)
         {
           (*pDecodedMessageOutputStream) << "Unknown suffix SEI message (payloadType = " << payloadType << ") was found!\n";
@@ -1690,7 +1690,7 @@ void SeiCfgFileDump::xDumpSEIEquirectangularProjection     (SEIEquirectangularPr
     }
     else
     {
-      msg( ERROR, "File %s could not be opened.\n", decoded360MessageFileName.c_str() );
+      msg( VTM_ERROR, "File %s could not be opened.\n", decoded360MessageFileName.c_str() );
     }
   }
 }
@@ -1773,7 +1773,7 @@ void SeiCfgFileDump::xDumpSEIGeneralizedCubemapProjection  (SEIGeneralizedCubema
       }
       else
       {
-        msg( ERROR, "File %s could not be opened.\n", decoded360MessageFileName.c_str() );
+        msg( VTM_ERROR, "File %s could not be opened.\n", decoded360MessageFileName.c_str() );
       }
     }
   }
diff --git a/source/Lib/DecoderLib/VLCReader.cpp b/source/Lib/DecoderLib/VLCReader.cpp
index 87e5c12e..9f301a20 100644
--- a/source/Lib/DecoderLib/VLCReader.cpp
+++ b/source/Lib/DecoderLib/VLCReader.cpp
@@ -4046,8 +4046,8 @@ void HLSyntaxReader::parseSliceHeader (Slice* pcSlice, PicHeader* picHeader, Par
     {
       if (pps->getWpInfoInPhFlag())
       {
-        CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_0) > picHeader->getNumL0Weights(), "ERROR: Number of active reference picture L0 is greater than the number of weighted prediction signalled in Picture Header");
-        CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_1) > picHeader->getNumL1Weights(), "ERROR: Number of active reference picture L1 is greater than the number of weighted prediction signalled in Picture Header");
+        CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_0) > picHeader->getNumL0Weights(), "VTM_ERROR: Number of active reference picture L0 is greater than the number of weighted prediction signalled in Picture Header");
+        CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_1) > picHeader->getNumL1Weights(), "VTM_ERROR: Number of active reference picture L1 is greater than the number of weighted prediction signalled in Picture Header");
         pcSlice->setWpScaling(picHeader->getWpScalingAll());
       }
       else
@@ -4609,7 +4609,7 @@ void HLSyntaxReader::parseRemainingBytes( bool noTrailingBytesExpected )
       uint32_t trailingNullByte=m_pcBitstream->readByte();
       if (trailingNullByte!=0)
       {
-        msg( ERROR, "Trailing byte should be 0, but has value %02x\n", trailingNullByte);
+        msg( VTM_ERROR, "Trailing byte should be 0, but has value %02x\n", trailingNullByte);
         THROW("Invalid trailing '0' byte");
       }
     }
diff --git a/source/Lib/EncoderLib/Analyze.h b/source/Lib/EncoderLib/Analyze.h
index 1518c26f..7bea8493 100644
--- a/source/Lib/EncoderLib/Analyze.h
+++ b/source/Lib/EncoderLib/Analyze.h
@@ -206,9 +206,9 @@ public:
 #endif
   {
 #if !WCG_WPSNR
-    MsgLevel e_msg_level = cDelim == 'a' ? INFO: DETAILS;
+    MsgLevel e_msg_level = cDelim == 'a' ? VTM_INFO: VTM_DETAILS;
 #else
-    MsgLevel e_msg_level = (cDelim == 'a') || (cDelim == 'w') ? INFO : DETAILS;
+    MsgLevel e_msg_level = (cDelim == 'a') || (cDelim == 'w') ? VTM_INFO : VTM_DETAILS;
 #endif
     double dFps     =   m_dFrmRate; //--CFG_KDY
     double dScale   = dFps / 1000 / (double)m_uiNumPic;
@@ -630,7 +630,7 @@ public:
         }
         break;
       default:
-        msg( ERROR, "Unknown format during print out\n");
+        msg( VTM_ERROR, "Unknown format during print out\n");
         exit(1);
         break;
     }
@@ -683,7 +683,7 @@ public:
         }
 
       default:
-          msg( ERROR, "Unknown format during print out\n");
+          msg( VTM_ERROR, "Unknown format during print out\n");
           exit(1);
           break;
     }
diff --git a/source/Lib/EncoderLib/EncGOP.cpp b/source/Lib/EncoderLib/EncGOP.cpp
index 6c754a25..3c57723a 100644
--- a/source/Lib/EncoderLib/EncGOP.cpp
+++ b/source/Lib/EncoderLib/EncGOP.cpp
@@ -1250,7 +1250,7 @@ validateMinCrRequirements(const ProfileLevelTierFeatures &plt, std::size_t numBy
 
       if (numBytesInVclNalUnits > threshold)
       {
-        msg( WARNING, "WARNING: Encoded stream does not meet MinCr requirements numBytesInVclNalUnits (%.0f) must be <= %.0f. Try increasing Qp, tier or level\n",
+        msg( VTM_WARNING, "VTM_WARNING: Encoded stream does not meet MinCr requirements numBytesInVclNalUnits (%.0f) must be <= %.0f. Try increasing Qp, tier or level\n",
                       (double) numBytesInVclNalUnits, threshold );
       }
     }
@@ -1298,11 +1298,11 @@ cabac_zero_word_padding(const Slice *const pcSlice,
           zeroBytesPadding[i*3+2]=3;  // 00 00 03
         }
         nalUnitData.write(reinterpret_cast<const char*>(&(zeroBytesPadding[0])), numberOfAdditionalCabacZeroBytes);
-        msg( NOTICE, "Adding %d bytes of padding\n", uint32_t( numberOfAdditionalCabacZeroWords * 3 ) );
+        msg( VTM_NOTICE, "Adding %d bytes of padding\n", uint32_t( numberOfAdditionalCabacZeroWords * 3 ) );
       }
       else
       {
-        msg( NOTICE, "Standard would normally require adding %d bytes of padding\n", uint32_t( numberOfAdditionalCabacZeroWords * 3 ) );
+        msg( VTM_NOTICE, "Standard would normally require adding %d bytes of padding\n", uint32_t( numberOfAdditionalCabacZeroWords * 3 ) );
       }
       return numberOfAdditionalCabacZeroWords;
     }
@@ -1462,11 +1462,11 @@ printHash(const HashType hashType, const std::string &digestStr)
   {
     if (digestStr.empty())
     {
-      msg( NOTICE, " [%s:%s]", decodedPictureHashModeName, "?");
+      msg( VTM_NOTICE, " [%s:%s]", decodedPictureHashModeName, "?");
     }
     else
     {
-      msg( NOTICE, " [%s:%s]", decodedPictureHashModeName, digestStr.c_str());
+      msg( VTM_NOTICE, " [%s:%s]", decodedPictureHashModeName, digestStr.c_str());
     }
   }
 }
@@ -3583,7 +3583,7 @@ void EncGOP::compressGOP( int iPOCLast, int iNumPicRcvd, PicList& rcListPic,
         if (m_pcRateCtrl->getCpbSaturationEnabled())
         {
           m_pcRateCtrl->updateCpbState(actualTotalBits);
-          msg( NOTICE, " [CPB %6d bits]", m_pcRateCtrl->getCpbState() );
+          msg( VTM_NOTICE, " [CPB %6d bits]", m_pcRateCtrl->getCpbState() );
         }
   #endif
       }
@@ -3631,7 +3631,7 @@ void EncGOP::compressGOP( int iPOCLast, int iNumPicRcvd, PicList& rcListPic,
 
       m_AUWriterIf->outputAU( accessUnit );
 
-      msg( NOTICE, "\n" );
+      msg( VTM_NOTICE, "\n" );
       fflush( stdout );
     }
 
@@ -3697,8 +3697,8 @@ void EncGOP::printOutSummary( uint32_t uiNumAllPicCoded, bool isField, const boo
   const ChromaFormat chFmt = m_pcCfg->getChromaFormatIdc();
 
   //-- all
-  msg( INFO, "\n" );
-  msg( DETAILS,"\nSUMMARY --------------------------------------------------------\n" );
+  msg( VTM_INFO, "\n" );
+  msg( VTM_DETAILS,"\nSUMMARY --------------------------------------------------------\n" );
 #if JVET_O0756_CALCULATE_HDRMETRICS
   const bool calculateHdrMetrics = m_pcEncLib->getCalcluateHdrMetrics();
 #endif
@@ -3716,22 +3716,22 @@ void EncGOP::printOutSummary( uint32_t uiNumAllPicCoded, bool isField, const boo
 #endif
                           );
 #endif
-  msg( DETAILS, "\n\nI Slices--------------------------------------------------------\n" );
+  msg( VTM_DETAILS, "\n\nI Slices--------------------------------------------------------\n" );
   m_gcAnalyzeI.printOut( 'i', chFmt, printMSEBasedSNR, printSequenceMSE, printMSSSIM, 
     printHexPsnr, printRprPSNR, bitDepths );
 
-  msg( DETAILS, "\n\nP Slices--------------------------------------------------------\n" );
+  msg( VTM_DETAILS, "\n\nP Slices--------------------------------------------------------\n" );
   m_gcAnalyzeP.printOut( 'p', chFmt, printMSEBasedSNR, printSequenceMSE, printMSSSIM,
     printHexPsnr, printRprPSNR, bitDepths );
 
-  msg( DETAILS, "\n\nB Slices--------------------------------------------------------\n" );
+  msg( VTM_DETAILS, "\n\nB Slices--------------------------------------------------------\n" );
   m_gcAnalyzeB.printOut( 'b', chFmt, printMSEBasedSNR, printSequenceMSE, printMSSSIM, 
     printHexPsnr, printRprPSNR, bitDepths );
 
 #if WCG_WPSNR
   if (useLumaWPSNR)
   {
-    msg(DETAILS, "\nWPSNR SUMMARY --------------------------------------------------------\n");
+    msg(VTM_DETAILS, "\nWPSNR SUMMARY --------------------------------------------------------\n");
     m_gcAnalyzeWPSNR.printOut( 'w', chFmt, printMSEBasedSNR, printSequenceMSE, printMSSSIM,
       printHexPsnr, printRprPSNR, bitDepths, useLumaWPSNR );
   }
@@ -3761,7 +3761,7 @@ void EncGOP::printOutSummary( uint32_t uiNumAllPicCoded, bool isField, const boo
     m_gcAnalyzeAll_in.setBits(m_gcAnalyzeAll.getBits());
     // prior to the above statement, the interlace analyser does not contain the correct total number of bits.
 
-    msg( INFO,"\n\nSUMMARY INTERLACED ---------------------------------------------\n" );
+    msg( VTM_INFO,"\n\nSUMMARY INTERLACED ---------------------------------------------\n" );
 #if ENABLE_QPA
     m_gcAnalyzeAll_in.printOut( 'a', chFmt, printMSEBasedSNR, printSequenceMSE, printMSSSIM,
       printHexPsnr, printRprPSNR, bitDepths, useWPSNR );
@@ -3781,7 +3781,7 @@ void EncGOP::printOutSummary( uint32_t uiNumAllPicCoded, bool isField, const boo
     }
   }
 
-  msg( DETAILS,"\nRVM: %.3lf\n", xCalculateRVM() );
+  msg( VTM_DETAILS,"\nRVM: %.3lf\n", xCalculateRVM() );
 }
 
 #if W0038_DB_OPT
@@ -4327,7 +4327,7 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
     uint32_t numRBSPBytes_nal = uint32_t((*it)->m_nalUnitData.str().size());
     if (m_pcCfg->getSummaryVerboseness() > 0)
     {
-      msg( NOTICE, "*** %6s numBytesInNALunit: %u\n", nalUnitTypeToString((*it)->m_nalUnitType), numRBSPBytes_nal);
+      msg( VTM_NOTICE, "*** %6s numBytesInNALunit: %u\n", nalUnitTypeToString((*it)->m_nalUnitType), numRBSPBytes_nal);
     }
     if( ( *it )->m_nalUnitType != NAL_UNIT_PREFIX_SEI && ( *it )->m_nalUnitType != NAL_UNIT_SUFFIX_SEI )
     {
@@ -4413,9 +4413,9 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
   }
   if (m_pcCfg->getDependentRAPIndicationSEIEnabled() && pcSlice->isDRAP()) c = 'D';
 
-  if( g_verbosity >= NOTICE )
+  if( g_verbosity >= VTM_NOTICE )
   {
-    msg( NOTICE, "POC %4d LId: %2d TId: %1d ( %s, %c-SLICE, QP %d ) %10d bits",
+    msg( VTM_NOTICE, "POC %4d LId: %2d TId: %1d ( %s, %c-SLICE, QP %d ) %10d bits",
          pcSlice->getPOC(),
          pcSlice->getPic()->layerId,
          pcSlice->getTLayer(),
@@ -4424,10 +4424,10 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
          pcSlice->getSliceQp(),
          uibits );
 
-    msg( NOTICE, " [Y %6.4lf dB    U %6.4lf dB    V %6.4lf dB]", dPSNR[COMPONENT_Y], dPSNR[COMPONENT_Cb], dPSNR[COMPONENT_Cr] );
+    msg( VTM_NOTICE, " [Y %6.4lf dB    U %6.4lf dB    V %6.4lf dB]", dPSNR[COMPONENT_Y], dPSNR[COMPONENT_Cb], dPSNR[COMPONENT_Cr] );
 
 #if EXTENSION_360_VIDEO
-    m_ext360.printPerPOCInfo(NOTICE);
+    m_ext360.printPerPOCInfo(VTM_NOTICE);
 #endif
 
     if (m_pcEncLib->getPrintHexPsnr())
@@ -4439,25 +4439,25 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
              reinterpret_cast<uint8_t *>(&dPSNR[i]) + sizeof(dPSNR[i]),
              reinterpret_cast<uint8_t *>(&xPsnr[i]));
       }
-      msg(NOTICE, " [xY %16" PRIx64 " xU %16" PRIx64 " xV %16" PRIx64 "]", xPsnr[COMPONENT_Y], xPsnr[COMPONENT_Cb], xPsnr[COMPONENT_Cr]);
+      msg(VTM_NOTICE, " [xY %16" PRIx64 " xU %16" PRIx64 " xV %16" PRIx64 "]", xPsnr[COMPONENT_Y], xPsnr[COMPONENT_Cb], xPsnr[COMPONENT_Cr]);
 
 #if EXTENSION_360_VIDEO
-      m_ext360.printPerPOCInfo(NOTICE, true);
+      m_ext360.printPerPOCInfo(VTM_NOTICE, true);
 #endif
     }
     if (printMSSSIM)
     {
-      msg( NOTICE, " [MS-SSIM Y %1.6lf    U %1.6lf    V %1.6lf]", msssim[COMPONENT_Y], msssim[COMPONENT_Cb], msssim[COMPONENT_Cr] );
+      msg( VTM_NOTICE, " [MS-SSIM Y %1.6lf    U %1.6lf    V %1.6lf]", msssim[COMPONENT_Y], msssim[COMPONENT_Cb], msssim[COMPONENT_Cr] );
     }  
 
     if( printFrameMSE )
     {
-      msg( NOTICE, " [Y MSE %6.4lf  U MSE %6.4lf  V MSE %6.4lf]", MSEyuvframe[COMPONENT_Y], MSEyuvframe[COMPONENT_Cb], MSEyuvframe[COMPONENT_Cr] );
+      msg( VTM_NOTICE, " [Y MSE %6.4lf  U MSE %6.4lf  V MSE %6.4lf]", MSEyuvframe[COMPONENT_Y], MSEyuvframe[COMPONENT_Cb], MSEyuvframe[COMPONENT_Cr] );
     }
 #if WCG_WPSNR
     if (useLumaWPSNR)
     {
-      msg(NOTICE, " [WY %6.4lf dB    WU %6.4lf dB    WV %6.4lf dB]", dPSNRWeighted[COMPONENT_Y], dPSNRWeighted[COMPONENT_Cb], dPSNRWeighted[COMPONENT_Cr]);
+      msg(VTM_NOTICE, " [WY %6.4lf dB    WU %6.4lf dB    WV %6.4lf dB]", dPSNRWeighted[COMPONENT_Y], dPSNRWeighted[COMPONENT_Cb], dPSNRWeighted[COMPONENT_Cr]);
 
       if (m_pcEncLib->getPrintHexPsnr())
       {
@@ -4468,7 +4468,7 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
                reinterpret_cast<uint8_t *>(&dPSNRWeighted[i]) + sizeof(dPSNRWeighted[i]),
                reinterpret_cast<uint8_t *>(&xPsnrWeighted[i]));
         }
-        msg(NOTICE, " [xWY %16" PRIx64 " xWU %16" PRIx64 " xWV %16" PRIx64 "]", xPsnrWeighted[COMPONENT_Y], xPsnrWeighted[COMPONENT_Cb], xPsnrWeighted[COMPONENT_Cr]);
+        msg(VTM_NOTICE, " [xWY %16" PRIx64 " xWU %16" PRIx64 " xWV %16" PRIx64 "]", xPsnrWeighted[COMPONENT_Y], xPsnrWeighted[COMPONENT_Cb], xPsnrWeighted[COMPONENT_Cr]);
       }
     }
 #endif
@@ -4477,7 +4477,7 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
     {
       for (int i=0; i<1; i++)
       {
-        msg(NOTICE, " [DeltaE%d %6.4lf dB]", (int)m_pcCfg->getWhitePointDeltaE(i), deltaE[i]);
+        msg(VTM_NOTICE, " [DeltaE%d %6.4lf dB]", (int)m_pcCfg->getWhitePointDeltaE(i), deltaE[i]);
         if (m_pcEncLib->getPrintHexPsnr())
         {
           int64_t xdeltaE[MAX_NUM_COMPONENT];
@@ -4487,12 +4487,12 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
                  reinterpret_cast<uint8_t *>(&deltaE[i]) + sizeof(deltaE[i]),
                  reinterpret_cast<uint8_t *>(&xdeltaE[i]));
           }
-          msg(NOTICE, " [xDeltaE%d %16" PRIx64 "]", (int)m_pcCfg->getWhitePointDeltaE(i), xdeltaE[0]);
+          msg(VTM_NOTICE, " [xDeltaE%d %16" PRIx64 "]", (int)m_pcCfg->getWhitePointDeltaE(i), xdeltaE[0]);
         }
       }
       for (int i=0; i<1; i++)
       {
-        msg(NOTICE, " [PSNRL%d %6.4lf dB]", (int)m_pcCfg->getWhitePointDeltaE(i), psnrL[i]);
+        msg(VTM_NOTICE, " [PSNRL%d %6.4lf dB]", (int)m_pcCfg->getWhitePointDeltaE(i), psnrL[i]);
 
         if (m_pcEncLib->getPrintHexPsnr())
         {
@@ -4503,19 +4503,19 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
                  reinterpret_cast<uint8_t *>(&psnrL[i]) + sizeof(psnrL[i]),
                  reinterpret_cast<uint8_t *>(&xpsnrL[i]));
           }
-          msg(NOTICE, " [xPSNRL%d %16" PRIx64 "]", (int)m_pcCfg->getWhitePointDeltaE(i), xpsnrL[0]);
+          msg(VTM_NOTICE, " [xPSNRL%d %16" PRIx64 "]", (int)m_pcCfg->getWhitePointDeltaE(i), xpsnrL[0]);
 
         }
       }
     }
 #endif
-    msg( NOTICE, " [ET %5.0f ]", dEncTime );
+    msg( VTM_NOTICE, " [ET %5.0f ]", dEncTime );
 
     // msg( SOME, " [WP %d]", pcSlice->getUseWeightedPrediction());
 
     for( int iRefList = 0; iRefList < 2; iRefList++ )
     {
-      msg( NOTICE, " [L%d", iRefList );
+      msg( VTM_NOTICE, " [L%d", iRefList );
       for( int iRefIndex = 0; iRefIndex < pcSlice->getNumRefIdx( RefPicList( iRefList ) ); iRefIndex++ )
       {
         const std::pair<int, int>& scaleRatio = pcSlice->getScalingRatio( RefPicList( iRefList ), iRefIndex );
@@ -4524,38 +4524,38 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
         {
           if( scaleRatio.first != 1 << SCALE_RATIO_BITS || scaleRatio.second != 1 << SCALE_RATIO_BITS )
           {
-            msg( NOTICE, " %dc(%1.2lfx, %1.2lfx)", pcSlice->getRefPOC( RefPicList( iRefList ), iRefIndex ), double( scaleRatio.first ) / ( 1 << SCALE_RATIO_BITS ), double( scaleRatio.second ) / ( 1 << SCALE_RATIO_BITS ) );
+            msg( VTM_NOTICE, " %dc(%1.2lfx, %1.2lfx)", pcSlice->getRefPOC( RefPicList( iRefList ), iRefIndex ), double( scaleRatio.first ) / ( 1 << SCALE_RATIO_BITS ), double( scaleRatio.second ) / ( 1 << SCALE_RATIO_BITS ) );
           }
           else
           {
-            msg( NOTICE, " %dc", pcSlice->getRefPOC( RefPicList( iRefList ), iRefIndex ) );
+            msg( VTM_NOTICE, " %dc", pcSlice->getRefPOC( RefPicList( iRefList ), iRefIndex ) );
           }
         }
         else
         {
           if( scaleRatio.first != 1 << SCALE_RATIO_BITS || scaleRatio.second != 1 << SCALE_RATIO_BITS )
           {
-            msg( NOTICE, " %d(%1.2lfx, %1.2lfx)", pcSlice->getRefPOC( RefPicList( iRefList ), iRefIndex ), double( scaleRatio.first ) / ( 1 << SCALE_RATIO_BITS ), double( scaleRatio.second ) / ( 1 << SCALE_RATIO_BITS ) );
+            msg( VTM_NOTICE, " %d(%1.2lfx, %1.2lfx)", pcSlice->getRefPOC( RefPicList( iRefList ), iRefIndex ), double( scaleRatio.first ) / ( 1 << SCALE_RATIO_BITS ), double( scaleRatio.second ) / ( 1 << SCALE_RATIO_BITS ) );
           }
           else
           {
-            msg( NOTICE, " %d", pcSlice->getRefPOC( RefPicList( iRefList ), iRefIndex ) );
+            msg( VTM_NOTICE, " %d", pcSlice->getRefPOC( RefPicList( iRefList ), iRefIndex ) );
           }
         }
 
         if( pcSlice->getRefPOC( RefPicList( iRefList ), iRefIndex ) == pcSlice->getPOC() )
         {
-          msg( NOTICE, ".%d", pcSlice->getRefPic( RefPicList( iRefList ), iRefIndex )->layerId );
+          msg( VTM_NOTICE, ".%d", pcSlice->getRefPic( RefPicList( iRefList ), iRefIndex )->layerId );
         }
       }
-      msg( NOTICE, "]" );
+      msg( VTM_NOTICE, "]" );
     }
     if (m_pcEncLib->isResChangeInClvsEnabled())
     {
-      msg( NOTICE, "\nPSNR2: [Y %6.4lf dB    U %6.4lf dB    V %6.4lf dB]", upscaledPSNR[COMPONENT_Y], upscaledPSNR[COMPONENT_Cb], upscaledPSNR[COMPONENT_Cr] );
+      msg( VTM_NOTICE, "\nPSNR2: [Y %6.4lf dB    U %6.4lf dB    V %6.4lf dB]", upscaledPSNR[COMPONENT_Y], upscaledPSNR[COMPONENT_Cb], upscaledPSNR[COMPONENT_Cr] );
     }
   }
-  else if( g_verbosity >= INFO )
+  else if( g_verbosity >= VTM_INFO )
   {
     std::cout << "\r\t" << pcSlice->getPOC();
     std::cout.flush();
@@ -4909,14 +4909,14 @@ void EncGOP::xCalculateInterlacedAddPSNR( Picture* pcPicOrgFirstField, Picture*
 
   *PSNR_Y = dPSNR[COMPONENT_Y];
 
-  msg( INFO, "\n                                      Interlaced frame %d: [Y %6.4lf dB    U %6.4lf dB    V %6.4lf dB]", pcPicOrgSecondField->getPOC()/2, dPSNR[COMPONENT_Y], dPSNR[COMPONENT_Cb], dPSNR[COMPONENT_Cr] );
+  msg( VTM_INFO, "\n                                      Interlaced frame %d: [Y %6.4lf dB    U %6.4lf dB    V %6.4lf dB]", pcPicOrgSecondField->getPOC()/2, dPSNR[COMPONENT_Y], dPSNR[COMPONENT_Cb], dPSNR[COMPONENT_Cr] );
   if (printMSSSIM)
   {
     printf(" [MS-SSIM Y %1.6lf    U %1.6lf    V %1.6lf]", msssim[COMPONENT_Y], msssim[COMPONENT_Cb], msssim[COMPONENT_Cr] );
   }
   if (printFrameMSE)
   {
-    msg( DETAILS, " [Y MSE %6.4lf  U MSE %6.4lf  V MSE %6.4lf]", MSEyuvframe[COMPONENT_Y], MSEyuvframe[COMPONENT_Cb], MSEyuvframe[COMPONENT_Cr] );
+    msg( VTM_DETAILS, " [Y MSE %6.4lf  U MSE %6.4lf  V MSE %6.4lf]", MSEyuvframe[COMPONENT_Y], MSEyuvframe[COMPONENT_Cb], MSEyuvframe[COMPONENT_Cr] );
   }
 
   for(uint32_t fieldNum=0; fieldNum<2; fieldNum++)
diff --git a/source/Lib/EncoderLib/RateCtrl.cpp b/source/Lib/EncoderLib/RateCtrl.cpp
index 0e33acb6..4eb0c3d1 100644
--- a/source/Lib/EncoderLib/RateCtrl.cpp
+++ b/source/Lib/EncoderLib/RateCtrl.cpp
@@ -516,7 +516,7 @@ void EncRCGOP::create( EncRCSeq* encRCSeq, int numPic )
     }
     else
     {
-      msg( WARNING, "Warning: Current rate control does not support this coding configuration." );
+      msg( VTM_WARNING, "Warning: Current rate control does not support this coding configuration." );
     }
 
     xCalEquaCoeff( encRCSeq, lambdaRatio, equaCoeffA, equaCoeffB, encRCSeq->getGOPSize() );
@@ -1753,7 +1753,7 @@ void RateCtrl::init(int totalFrames, int targetBitrate, int frameRate, int GOPSi
     }
     else
     {
-      msg( WARNING, "\n hierarchical bit allocation is not support for the specified coding structure currently.\n" );
+      msg( VTM_WARNING, "\n hierarchical bit allocation is not support for the specified coding structure currently.\n" );
     }
   }
 
@@ -1944,7 +1944,7 @@ void RateCtrl::initHrdParam(const GeneralHrdParams* generalHrd, const OlsHrdPara
   m_cpbSize = (olsHrd->getCpbSizeValueMinus1(0, 0) + 1) << (4 + generalHrd->getCpbSizeScale());
   m_cpbState = (uint32_t)(m_cpbSize*fInitialCpbFullness);
   m_bufferingRate = (uint32_t)(((olsHrd->getBitRateValueMinus1(0, 0) + 1) << (6 + generalHrd->getBitRateScale())) / iFrameRate);
-  msg(NOTICE, "\nHRD - [Initial CPB state %6d] [CPB Size %6d] [Buffering Rate %6d]\n", m_cpbState, m_cpbSize, m_bufferingRate);
+  msg(VTM_NOTICE, "\nHRD - [Initial CPB state %6d] [CPB Size %6d] [Buffering Rate %6d]\n", m_cpbState, m_cpbSize, m_bufferingRate);
 }
 #endif
 
diff --git a/source/Lib/Utilities/VideoIOYuv.cpp b/source/Lib/Utilities/VideoIOYuv.cpp
index 8148d5e3..235d9e21 100644
--- a/source/Lib/Utilities/VideoIOYuv.cpp
+++ b/source/Lib/Utilities/VideoIOYuv.cpp
@@ -141,7 +141,7 @@ void VideoIOYuv::open( const std::string &fileName, bool bWriteMode, const int f
       }
       else
       {
-        EXIT( "ERROR: Cannot read a yuv file of bit depth greater than 16" );
+        EXIT( "VTM_ERROR: Cannot read a yuv file of bit depth greater than 16" );
       }
     }
   }
@@ -1057,7 +1057,7 @@ bool VideoIOYuv::write( uint32_t orgWidth, uint32_t orgHeight, const CPelUnitBuf
 
   if ((width444 == 0) || (height444 == 0))
   {
-    msg( WARNING, "\nWarning: writing %d x %d luma sample output picture!", width444, height444);
+    msg( VTM_WARNING, "\nWarning: writing %d x %d luma sample output picture!", width444, height444);
   }
 
   for(uint32_t comp=0; retval && comp < ::getNumberValidComponents(format); comp++)
@@ -1167,7 +1167,7 @@ bool VideoIOYuv::write( const CPelUnitBuf& picTop, const CPelUnitBuf& picBottom,
 
     if ((width444 == 0) || (height444 == 0))
     {
-      msg( WARNING, "\nWarning: writing %d x %d luma sample output picture!", width444, height444);
+      msg( VTM_WARNING, "\nWarning: writing %d x %d luma sample output picture!", width444, height444);
     }
 
     const uint32_t csx = ::getComponentScaleX(compID, dstChrFormat );
